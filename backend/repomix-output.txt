This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.env.backup
activity-handler.js
api/activity.js
api/activity.ts
api/auth.js
api/auth.js.new
api/auth.ts
api/auth.ts.new
api/comments.js
api/comments.js.new
api/comments.ts
api/communities.js
api/communities.js.new
api/communities.js.new.part2
api/communities.ts
api/communities.ts.new
api/community_fix.js
api/community/community-core.js
api/community/community-members.js
api/community/community-requests.js
api/community/community-rules.js
api/community/community-search.js
api/community/community-settings.js
api/community/index.js
api/community/README.md
api/moderation.ts
api/moderation.ts.new
api/posts_enhanced.js
api/posts.js
api/posts.js.new
api/posts.ts
api/routes/communities.js
api/routes/community-members.js
api/users.ts
api/votes.js
api/votes.js.new
api/votes.ts
check-community.js
check-tables.js
db/add_admin_user.js
db/apply_auth_schema.js
db/apply_comments_schema.js
db/apply_community_updates.js
db/apply_moderator_schema.js
db/apply_new_schema.js
db/apply_user_auth_schema.js
db/apply_user_statistics_schema.js
db/apply_votes_schema.js
db/comments_schema_updates.sql
db/community_schema_updates.sql
db/connection.d.ts
db/connection.js
db/connection.ts
db/fetch_usernames.js
db/fix_community_api.js
db/fix_community_join_request.js
db/fix_community_join_request.sql
db/fix_community_join_table.bat
db/fix_join_request_name.js
db/fix_join_request.bat
db/fixed_schema.sql
db/generate_sample_data.js
db/init_schema.js
db/init.js
db/migrate_data.js
db/migrate_database.bat
db/moderator_schema_updates.sql
db/new_schema.sql
db/README_DATABASE_REFACTORING.md
db/schema.sql
db/seed_communities.js
db/simple_schema.sql
db/update_auth_files.js
db/update_connection.js
db/user_auth_schema.sql
db/user_statistics_schema.sql
db/votes_schema_update.sql
fix_moderator_usernames.js
fix-table-names.js
index.js
index.ts
middleware/activity.js
middleware/auth.js
middleware/moderation.js
middleware/moderation.js.new
package.json
routes/activity.js
routes/auth.js
routes/auth.js.new
routes/comments.js
routes/comments.js.new
routes/communities.js
routes/communities.js.new
routes/community-members.js
routes/moderation.js
routes/moderation.js.new
routes/posts.js
routes/posts.js.new
routes/users.js
routes/votes.js
routes/votes.js.new
test-api.js
testServer.js
tsconfig.json
types/index.ts

================================================================
Files
================================================================

================
File: .env.backup
================
API_KEY=AIzaSyCqBgYt00ik2BzpxDKz2b6aNHK6yt2cdeE
DB_HOST=192.168.0.139
DB_PORT=3306
DB_USER=root
DB_PASSWORD=Oswald1986!
DB_NAME=rumfor1
JWT_SECRET=rumfor-secret-key-for-jwt-authentication

================
File: activity-handler.js
================
// Simple activity endpoint handler that works with singular table names
const express = require('express');
const router = express.Router();
const mysql = require('mysql2/promise');
require('dotenv').config();

// Create a database connection pool
const pool = mysql.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 5
});

/**
 * @route GET /api/activity/community/:communityId
 * @desc Get activities for a specific community
 */
router.get('/community/:communityId', async (req, res) => {
  try {
    const { communityId } = req.params;
    
    // Extract query parameters
    const limit = parseInt(req.query.limit || '10', 10);
    const offset = parseInt(req.query.offset || '0', 10);
    
    // Just return minimum data for now
    res.json([]);
  } catch (error) {
    console.error('Error fetching community activities:', error);
    res.status(500).json({ error: 'Failed to fetch community activities' });
  }
});

module.exports = router;

================
File: api/activity.js
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

/**
 * Get activities for a specific user
 * @param {string} userId - The user ID to get activities for
 * @param {Object} options - Query options
 * @param {number} options.limit - Maximum number of activities to return
 * @param {number} options.offset - Number of activities to skip
 * @param {string} options.activityType - Filter by activity type
 * @param {string} options.actionType - Filter by action type
 * @param {string} options.entityType - Filter by entity type
 * @param {string} options.startDate - Filter by start date (ISO format)
 * @param {string} options.endDate - Filter by end date (ISO format)
 * @returns {Promise<Array>} - Array of activities
 */
async function getUserActivities(userId, options = {}) {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      WHERE a.user_id = ?
    `;
    
    const queryParams = [userId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit), parseInt(offset));
    
    const activities = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(activities)) {
      for (let activity of activities) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = null;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof activities);
    }
    
    return activities;
  } catch (error) {
    console.error("Error fetching user activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific community
 * @param {string} communityId - The community ID to get activities for
 * @param {Object} options - Query options
 * @param {number} options.limit - Maximum number of activities to return
 * @param {number} options.offset - Number of activities to skip
 * @param {string} options.activityType - Filter by activity type
 * @param {string} options.actionType - Filter by action type
 * @param {string} options.entityType - Filter by entity type
 * @param {string} options.startDate - Filter by start date (ISO format)
 * @param {string} options.endDate - Filter by end date (ISO format)
 * @returns {Promise<Array>} - Array of activities
 */
async function getCommunityActivities(communityId, options = {}) {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'community' AND a.entity_id = ?) OR
        (a.entity_type = 'post' AND a.entity_id IN (
          SELECT id FROM post WHERE community_id = ?
        )) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT c.id FROM comment c
          JOIN post p ON c.post_id = p.id
          WHERE p.community_id = ?
        ))
      )
    `;
    
    const queryParams = [communityId, communityId, communityId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit), parseInt(offset));
    
    const activities = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(activities)) {
      for (let activity of activities) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = null;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof activities);
    }
    
    return activities;
  } catch (error) {
    console.error("Error fetching community activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific post
 * @param {string} postId - The post ID to get activities for
 * @param {Object} options - Query options
 * @param {number} options.limit - Maximum number of activities to return
 * @param {number} options.offset - Number of activities to skip
 * @returns {Promise<Array>} - Array of activities
 */
async function getPostActivities(postId, options = {}) {
  const { limit = 20, offset = 0 } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'post' AND a.entity_id = ?) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT id FROM comment WHERE post_id = ?
        ))
      )
      ORDER BY a.created_at DESC
      LIMIT ? OFFSET ?
    `;
    
    const activities = await conn.query(query, [postId, postId, parseInt(limit), parseInt(offset)]);
    
    // Enrich activities with entity details
    if (Array.isArray(activities)) {
      for (let activity of activities) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = null;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof activities);
    }
    
    return activities;
  } catch (error) {
    console.error("Error fetching post activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all activity types
 * @returns {Promise<Array>} - Array of activity types
 */
async function getActivityTypes() {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const activityTypes = await conn.query(
      "SELECT * FROM activity_type ORDER BY name"
    );
    
    return activityTypes || [];
  } catch (error) {
    console.error("Error fetching activity types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all action types
 * @returns {Promise<Array>} - Array of action types
 */
async function getActionTypes() {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const actionTypes = await conn.query(
      "SELECT * FROM action ORDER BY name"
    );
    
    return actionTypes || [];
  } catch (error) {
    console.error("Error fetching action types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Log an activity
 * @param {Object} activityData - Activity data
 * @param {string} activityData.userId - User ID
 * @param {string} activityData.activityType - Activity type name
 * @param {string} activityData.actionType - Action type name
 * @param {string} activityData.entityId - Entity ID
 * @param {string} activityData.entityType - Entity type
 * @param {Object} activityData.metadata - Additional metadata
 * @param {string} activityData.ipAddress - IP address
 * @param {string} activityData.userAgent - User agent
 * @returns {Promise<Object>} - Created activity
 */
async function logActivity(activityData) {
  if (!activityData || !activityData.userId) {
    console.warn("Attempted to log activity without user ID:", activityData);
    return null;
  }
  
  const {
    userId,
    activityType,
    actionType,
    entityId,
    entityType,
    metadata,
    ipAddress,
    userAgent
  } = activityData;

  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get activity type ID
    const [activityTypeRecord] = await conn.query(
      "SELECT id FROM activity_type WHERE name = ?",
      [activityType]
    );
    
    if (!activityTypeRecord) {
      // Create the activity type if it doesn't exist
      console.warn(`Activity type '${activityType}' not found, creating it.`);
      const activityTypeId = uuidv4();
      await conn.query(
        "INSERT INTO activity_type (id, name) VALUES (?, ?)",
        [activityTypeId, activityType]
      );
      activityTypeRecord = { id: activityTypeId };
    }
    
    // Get action type ID
    const [actionTypeRecord] = await conn.query(
      "SELECT id FROM action WHERE name = ?",
      [actionType]
    );
    
    if (!actionTypeRecord) {
      // Create the action type if it doesn't exist
      console.warn(`Action type '${actionType}' not found, creating it.`);
      const actionTypeId = uuidv4();
      await conn.query(
        "INSERT INTO action (id, name) VALUES (?, ?)",
        [actionTypeId, actionType]
      );
      actionTypeRecord = { id: actionTypeId };
    }
    
    // Create activity
    const activityId = uuidv4();
    
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, 
        metadata, ip_address, user_agent
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        activityId,
        userId,
        activityTypeRecord.id,
        actionTypeRecord.id,
        entityId,
        entityType,
        metadata ? JSON.stringify(metadata) : null,
        ipAddress,
        userAgent
      ]
    );
    
    // Get the created activity
    const [activity] = await conn.query(
      `SELECT a.*, at.name as activity_type_name, act.name as action_name
       FROM activity a
       JOIN activity_type at ON a.activity_type_id = at.id
       JOIN action act ON a.action_id = act.id
       WHERE a.id = ?`,
      [activityId]
    );
    
    return activity;
  } catch (error) {
    console.error("Error logging activity:", error);
    // Don't throw - we don't want activity logging to break the application
    return null;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get entity details based on entity ID and type
 * @param {Object} conn - Database connection
 * @param {string} entityId - Entity ID
 * @param {string} entityType - Entity type
 * @returns {Promise<Object>} - Entity details
 */
async function getEntityDetails(conn, entityId, entityType) {
  if (!entityId || !entityType) {
    return null;
  }
  
  try {
    switch (entityType) {
      case 'post': {
        const [post] = await conn.query(
          `SELECT p.id, p.title, p.content, p.community_id, c.name as community_name, u.username
           FROM post p
           LEFT JOIN community c ON p.community_id = c.id
           LEFT JOIN user u ON p.user_id = u.id
           WHERE p.id = ?`,
          [entityId]
        );
        return post;
      }
      case 'comment': {
        const [comment] = await conn.query(
          `SELECT c.id, c.content, c.post_id, p.title as post_title, u.username
           FROM comment c
           LEFT JOIN post p ON c.post_id = p.id
           LEFT JOIN user u ON c.user_id = u.id
           WHERE c.id = ?`,
          [entityId]
        );
        return comment;
      }
      case 'community': {
        const [community] = await conn.query(
          "SELECT id, name, description FROM community WHERE id = ?",
          [entityId]
        );
        return community;
      }
      case 'user': {
        const [user] = await conn.query(
          "SELECT id, username, display_name FROM user WHERE id = ?",
          [entityId]
        );
        return user;
      }
      default:
        return null;
    }
  } catch (error) {
    console.error(`Error getting ${entityType} details:`, error);
    return null;
  }
}

module.exports = {
  getUserActivities,
  getCommunityActivities,
  getPostActivities,
  getActivityTypes,
  getActionTypes,
  logActivity
};

================
File: api/activity.ts
================
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection';
import type { ActivityOptions, ActivityData, Activity, ActivityType, ActionType } from '../types/index';

// Custom type for activity row data
interface ActivityRow {
  entity_id?: string;
  entity_type?: string;
  entity_details?: any;
  [key: string]: any;
}

/**
 * Get activities for a specific user
 */
export async function getUserActivities(userId: string, options: ActivityOptions = {}): Promise<Activity[]> {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      WHERE a.user_id = ?
    `;
    
    const queryParams: any[] = [userId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit.toString()), parseInt(offset.toString()));
    
    const [rows] = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(rows)) {
      for (let activity of rows as ActivityRow[]) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = undefined;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof rows);
    }
    
    return rows as Activity[];
  } catch (error) {
    console.error("Error fetching user activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific community
 */
export async function getCommunityActivities(communityId: string, options: ActivityOptions = {}): Promise<Activity[]> {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'community' AND a.entity_id = ?) OR
        (a.entity_type = 'post' AND a.entity_id IN (
          SELECT id FROM post WHERE community_id = ?
        )) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT c.id FROM comment c
          JOIN post p ON c.post_id = p.id
          WHERE p.community_id = ?
        ))
      )
    `;
    
    const queryParams: any[] = [communityId, communityId, communityId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit.toString()), parseInt(offset.toString()));
    
    const [rows] = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(rows)) {
      for (let activity of rows as ActivityRow[]) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = undefined;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof rows);
    }
    
    return rows as Activity[];
  } catch (error) {
    console.error("Error fetching community activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific post
 */
export async function getPostActivities(postId: string, options: ActivityOptions = {}): Promise<Activity[]> {
  const { limit = 20, offset = 0 } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'post' AND a.entity_id = ?) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT id FROM comment WHERE post_id = ?
        ))
      )
      ORDER BY a.created_at DESC
      LIMIT ? OFFSET ?
    `;
    
    const [rows] = await conn.query(query, [postId, postId, parseInt(limit.toString()), parseInt(offset.toString())]);
    
    // Enrich activities with entity details
    if (Array.isArray(rows)) {
      for (let activity of rows as ActivityRow[]) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = undefined;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof rows);
    }
    
    return rows as Activity[];
  } catch (error) {
    console.error("Error fetching post activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all activity types
 */
export async function getActivityTypes(): Promise<ActivityType[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [rows] = await conn.query("SELECT * FROM activity_type ORDER BY name");
    
    return rows as ActivityType[];
  } catch (error) {
    console.error("Error fetching activity types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all action types
 */
export async function getActionTypes(): Promise<ActionType[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [rows] = await conn.query("SELECT * FROM action ORDER BY name");
    
    return rows as ActionType[];
  } catch (error) {
    console.error("Error fetching action types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Log an activity
 */
export async function logActivity(activityData: ActivityData): Promise<Activity | null> {
  if (!activityData || !activityData.userId) {
    console.warn("Attempted to log activity without user ID:", activityData);
    return null;
  }
  
  const {
    userId,
    activityType,
    actionType,
    entityId,
    entityType,
    metadata,
    ipAddress,
    userAgent
  } = activityData;

  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get activity type ID
    const [activityTypeRows] = await conn.query(
      "SELECT id FROM activity_type WHERE name = ?",
      [activityType]
    );
    
    let activityTypeId: string;
    if (!activityTypeRows || (Array.isArray(activityTypeRows) && activityTypeRows.length === 0)) {
      // Create the activity type if it doesn't exist
      console.warn(`Activity type '${activityType}' not found, creating it.`);
      activityTypeId = uuidv4();
      await conn.query(
        "INSERT INTO activity_type (id, name) VALUES (?, ?)",
        [activityTypeId, activityType]
      );
    } else {
      // Access as object with indexed property
      const rows = activityTypeRows as any[];
      activityTypeId = rows[0]['id'];
    }
    
    // Get action type ID
    const [actionTypeRows] = await conn.query(
      "SELECT id FROM action WHERE name = ?",
      [actionType]
    );
    
    let actionTypeId: string;
    if (!actionTypeRows || (Array.isArray(actionTypeRows) && actionTypeRows.length === 0)) {
      // Create the action type if it doesn't exist
      console.warn(`Action type '${actionType}' not found, creating it.`);
      actionTypeId = uuidv4();
      await conn.query(
        "INSERT INTO action (id, name) VALUES (?, ?)",
        [actionTypeId, actionType]
      );
    } else {
      // Access as object with indexed property
      const rows = actionTypeRows as any[];
      actionTypeId = rows[0]['id'];
    }
    
    // Create activity
    const activityId = uuidv4();
    
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, 
        metadata, ip_address, user_agent
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        activityId,
        userId,
        activityTypeId,
        actionTypeId,
        entityId,
        entityType,
        metadata ? JSON.stringify(metadata) : null,
        ipAddress,
        userAgent
      ]
    );
    
    // Get the created activity
    const [activityRows] = await conn.query(
      `SELECT a.*, at.name as activity_type_name, act.name as action_name
       FROM activity a
       JOIN activity_type at ON a.activity_type_id = at.id
       JOIN action act ON a.action_id = act.id
       WHERE a.id = ?`,
      [activityId]
    );
    
    return Array.isArray(activityRows) && activityRows.length > 0 ? activityRows[0] as Activity : null;
  } catch (error) {
    console.error("Error logging activity:", error);
    // Don't throw - we don't want activity logging to break the application
    return null;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get entity details based on entity ID and type
 */
async function getEntityDetails(conn: any, entityId: string, entityType: string): Promise<any | null> {
  if (!entityId || !entityType) {
    return null;
  }
  
  try {
    switch (entityType) {
      case 'post': {
        const [rows] = await conn.query(
          `SELECT p.id, p.title, p.content, p.community_id, c.name as community_name, u.username
           FROM post p
           LEFT JOIN community c ON p.community_id = c.id
           LEFT JOIN user u ON p.user_id = u.id
           WHERE p.id = ?`,
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      case 'comment': {
        const [rows] = await conn.query(
          `SELECT c.id, c.content, c.post_id, p.title as post_title, u.username
           FROM comment c
           LEFT JOIN post p ON c.post_id = p.id
           LEFT JOIN user u ON c.user_id = u.id
           WHERE c.id = ?`,
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      case 'community': {
        const [rows] = await conn.query(
          "SELECT id, name, description FROM community WHERE id = ?",
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      case 'user': {
        const [rows] = await conn.query(
          "SELECT id, username, display_name FROM user WHERE id = ?",
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      default:
        return null;
    }
  } catch (error) {
    console.error(`Error getting ${entityType} details:`, error);
    return null;
  }
}

================
File: api/auth.js
================
// Updated auth.js for the new database schema
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');
const { logActivity } = require('./activity.js');

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Password validation
const isStrongPassword = (password) => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// Register a new user
const register = async (userData) => {
  const { username, email, password } = userData;
  let conn;
  
  try {
    // Validate password strength
    if (!isStrongPassword(password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    try {
      // Check if username or email already exists
      const [existingUsers] = await conn.query(
        "SELECT username, email FROM user WHERE username = ? OR email = ?",
        [username, email]
      );
      
      if (Array.isArray(existingUsers) && existingUsers.length > 0) {
        if (existingUsers.some(user => user.username === username)) {
          throw new Error('Username already exists');
        }
        if (existingUsers.some(user => user.email === email)) {
          throw new Error('Email already exists');
        }
        throw new Error('Username or email already exists');
      }
      
      // Hash the password
      const salt = await bcrypt.genSalt(10);
      const password_hash = await bcrypt.hash(password, salt);
      
      // Create a new user
      const id = uuidv4();
      const now = new Date();
      
      await conn.query(
        `INSERT INTO user (
          id, username, email, password_hash, role, 
          created_at, updated_at, cake_day, last_active
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [id, username, email, password_hash, 'user', now, now, now, now]
      );
      
      // Create user statistics record
      await conn.query(
        `INSERT INTO user_statistic (
          user_id, karma, posts_count, comments_count, 
          upvotes_received, downvotes_received, upvotes_given, 
          downvotes_given, communities_joined, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
      );
      
      // Create user settings record
      await conn.query(
        `INSERT INTO user_setting (
          user_id, email_notifications, push_notifications, 
          theme, content_filter, allow_followers, 
          display_online_status, language, timezone, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
      );
      
      // Commit transaction
      await conn.commit();
      
      // Return user without password
      const [results] = await conn.query(
        `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
          s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
          s.downvotes_received, s.upvotes_given, s.downvotes_given, 
          s.communities_joined
        FROM user u
        LEFT JOIN user_statistic s ON u.id = s.user_id
        WHERE u.id = ?`,
        [id]
      );
      
      const newUser = Array.isArray(results) && results.length > 0 ? results[0] : null;
      
      if (!newUser) {
        throw new Error('Failed to retrieve created user');
      }
      
      // Log activity (don't wait for it to complete)
      logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username, email },
        ipAddress: null,
        userAgent: null
      }).catch(error => {
        console.error("Error logging registration activity:", error);
        // Don't throw, just log the error
      });
      
      return { user: newUser };
    } catch (transactionError) {
      // Rollback transaction on error
      await conn.rollback();
      throw transactionError;
    }
  } catch (error) {
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Login a user
const login = async (credentials) => {
  const { username, password } = credentials;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [users] = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [username]
    );
    
    const user = Array.isArray(users) && users.length > 0 ? users[0] : null;
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Check password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id, 
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    // Log activity (don't wait for it to complete)
    logActivity({
      userId: user.id,
      activityType: 'USER',
      actionType: 'LOGIN',
      entityId: user.id,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    }).catch(error => {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    });
    
    // Return user and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get current user
const getCurrentUser = async (userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [users] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    const user = Array.isArray(users) && users.length > 0 ? users[0] : null;
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Verify JWT token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Logout (just for activity logging)
const logout = async (userId) => {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
};

module.exports = {
  register,
  login,
  getCurrentUser,
  verifyToken,
  logout
};

================
File: api/auth.js.new
================
// Updated auth.js for the new database schema
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');
const { logActivity } = require('./activity.js');

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Password validation
const isStrongPassword = (password) => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// Register a new user
const register = async (userData) => {
  const { username, email, password } = userData;
  let conn;
  
  try {
    // Validate password strength
    if (!isStrongPassword(password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [username, email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const password_hash = await bcrypt.hash(password, salt);
    
    // Create a new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, username, email, password_hash, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Return user without password
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username, email },
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Login a user
const login = async (credentials) => {
  const { username, password } = credentials;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [user] = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [username]
    );
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Check password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id, 
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get current user
const getCurrentUser = async (userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [user] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Verify JWT token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Logout (just for activity logging)
const logout = async (userId) => {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
};

module.exports = {
  register,
  login,
  getCurrentUser,
  verifyToken,
  logout
};

================
File: api/auth.ts
================
// Updated auth.ts for the new database schema
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { logActivity } from './activity';
import pool from '../db/connection';
import { QueryResult } from 'mysql2';

dotenv.config();

// JWT secret key
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
// Token expiration (1 day)
const TOKEN_EXPIRATION = '1d';

// User interface
interface User {
  id: string;
  username: string;
  email: string;
  password_hash?: string;
  role: string;
  first_name?: string;
  last_name?: string;
  display_name?: string;
  date_of_birth?: Date;
  bio?: string;
  avatar_url?: string;
  profile_banner_url?: string;
  website?: string;
  location?: string;
  is_verified?: boolean;
  status?: string;
  cake_day?: Date;
  created_at: Date;
  updated_at: Date;
  last_active?: Date;
  karma?: number;
  posts_count?: number;
  comments_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
}

// Password validation
const isStrongPassword = (password: string): boolean => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// User registration
export async function register(userData: { username: string; email: string; password: string }) {
  let conn;
  try {
    // Validate password strength
    if (!isStrongPassword(userData.password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [userData.username, userData.email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
    
    // Create new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, userData.username, userData.email, hashedPassword, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Get the created user (without password)
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username: userData.username, email: userData.email },
        ipAddress: undefined,
        userAgent: undefined
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// User login
export async function login(credentials: { username: string; password: string }) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const userResult = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [credentials.username]
    );
    
    const [rows] = userResult as [any[], any];
    const user = rows[0] as User;
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Compare passwords
    const passwordMatch = await bcrypt.compare(credentials.password, user.password_hash || '');
    
    if (!passwordMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRATION }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: undefined,
        userAgent: undefined
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user info and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get current user from token
export async function getCurrentUser(userId: string) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const userResult = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    const [rows] = userResult as [any[], any];
    const user = rows[0] as User;
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Middleware to verify JWT token
export function verifyToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// User logout
export async function logout(userId: string) {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: undefined,
      userAgent: undefined
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
}

================
File: api/auth.ts.new
================
// Updated auth.ts for the new database schema
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { logActivity } from './activity';
import pool from '../db/connection';

dotenv.config();

// JWT secret key
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
// Token expiration (1 day)
const TOKEN_EXPIRATION = '1d';

// User interface
interface User {
  id: string;
  username: string;
  email: string;
  password_hash?: string;
  role: string;
  first_name?: string;
  last_name?: string;
  display_name?: string;
  date_of_birth?: Date;
  bio?: string;
  avatar_url?: string;
  profile_banner_url?: string;
  website?: string;
  location?: string;
  is_verified?: boolean;
  status?: string;
  cake_day?: Date;
  created_at: Date;
  updated_at: Date;
  last_active?: Date;
  karma?: number;
  posts_count?: number;
  comments_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
}

// Password validation
const isStrongPassword = (password: string): boolean => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// User registration
export async function register(userData: { username: string; email: string; password: string }) {
  let conn;
  try {
    // Validate password strength
    if (!isStrongPassword(userData.password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [userData.username, userData.email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
    
    // Create new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, userData.username, userData.email, hashedPassword, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Get the created user (without password)
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username: userData.username, email: userData.email },
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// User login
export async function login(credentials: { username: string; password: string }) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [user] = await conn.query<User[]>(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [credentials.username]
    );
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Compare passwords
    const passwordMatch = await bcrypt.compare(credentials.password, user.password_hash || '');
    
    if (!passwordMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRATION }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user info and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get current user from token
export async function getCurrentUser(userId: string) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [user] = await conn.query<User[]>(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Middleware to verify JWT token
export function verifyToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// Logout (just for activity logging)
export async function logout(userId: string) {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
}

================
File: api/comments.js
================
// JavaScript version of comments.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all comments for a post
const getPostComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching post comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get a specific comment
const getComment = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [comment] = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.id = ?
    `, [commentId]);
    
    return comment || null;
  } catch (error) {
    console.error("Error fetching comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Create a new comment
const createComment = async (userId, commentData) => {
  const { content, post_id, parent_comment_id } = commentData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if post exists
      const [post] = await conn.query(
        "SELECT * FROM post WHERE id = ?",
        [post_id]
      );
      
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if parent comment exists if provided
      if (parent_comment_id) {
        const [parentComment] = await conn.query(
          "SELECT * FROM comment WHERE id = ?",
          [parent_comment_id]
        );
        
        if (!parentComment) {
          throw new Error('Parent comment not found');
        }
      }
      
      // Create the comment
      const id = uuidv4();
      
      let query = "INSERT INTO comment (id, content, user_id, post_id";
      let values = [id, content, userId, post_id];
      
      if (parent_comment_id) {
        query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
        values.push(parent_comment_id);
      } else {
        query += ") VALUES (?, ?, ?, ?)";
      }
      
      await conn.query(query, values);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'CREATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          id,
          'comment',
          JSON.stringify({
            post_id: post_id,
            parent_comment_id: parent_comment_id || null
          })
        ]
      );
      
      // Get the created comment with username
      const [newComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      return newComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Update a comment
const updateComment = async (commentId, userId, content) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return null;
      }
      
      if (comment.user_id !== userId) {
        throw new Error('You can only update your own comments');
      }
      
      // Update the comment
      await conn.query(
        "UPDATE comment SET content = ? WHERE id = ?",
        [content, commentId]
      );
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Get the updated comment with username
      const [updatedComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [commentId]);
      
      // Commit the transaction
      await conn.commit();
      
      return updatedComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Delete a comment
const deleteComment = async (commentId, userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return false;
      }
      
      // Check if user is the comment author or a moderator of the community
      if (comment.user_id !== userId) {
        // Get the post to find the community
        const [post] = await conn.query(
          "SELECT community_id FROM post WHERE id = ?",
          [comment.post_id]
        );
        
        if (!post) {
          throw new Error('Post not found');
        }
        
        // Check if user is a moderator
        const [moderator] = await conn.query(
          "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
          [post.community_id, userId]
        );
        
        if (!moderator) {
          throw new Error('You can only delete your own comments or comments in communities you moderate');
        }
      }
      
      // Find all replies to this comment recursively
      const findReplies = async (parentId, replyIds = []) => {
        const replies = await conn.query(
          "SELECT id FROM comment WHERE parent_comment_id = ?",
          [parentId]
        );
        
        for (const reply of replies) {
          replyIds.push(reply.id);
          await findReplies(reply.id, replyIds);
        }
        
        return replyIds;
      };
      
      const replyIds = await findReplies(commentId);
      
      // Log activity for the main comment
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Delete all replies
      if (replyIds.length > 0) {
        // Log activity for each reply
        for (const replyId of replyIds) {
          const [reply] = await conn.query(
            "SELECT * FROM comment WHERE id = ?",
            [replyId]
          );
          
          if (reply) {
            await conn.query(
              `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
               VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                uuidv4(),
                userId,
                activityTypeId,
                actionId,
                replyId,
                'comment',
                JSON.stringify({
                  post_id: reply.post_id,
                  parent_comment_id: reply.parent_comment_id || null
                })
              ]
            );
          }
        }
        
        const placeholders = replyIds.map(() => '?').join(',');
        await conn.query(
          `DELETE FROM comment WHERE id IN (${placeholders})`,
          replyIds
        );
      }
      
      // Delete the comment
      await conn.query(
        "DELETE FROM comment WHERE id = ?",
        [commentId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      return true;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get replies to a comment
const getCommentReplies = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const replies = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.parent_comment_id = ?
      ORDER BY c.created_at ASC
    `, [commentId]);
    
    return replies;
  } catch (error) {
    console.error("Error fetching comment replies:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get threaded comments for a post
const getThreadedComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get all comments for the post with usernames
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    // Add replies array to each comment
    const commentsWithReplies = comments.map(comment => ({
      ...comment,
      username: comment.username || 'Anonymous',
      replies: []
    }));
    
    // Create a map for quick lookup
    const commentMap = new Map();
    commentsWithReplies.forEach(comment => {
      commentMap.set(comment.id, comment);
    });
    
    // Organize into a tree structure
    const rootComments = [];
    
    commentsWithReplies.forEach(comment => {
      if (comment.parent_comment_id) {
        const parent = commentMap.get(comment.parent_comment_id);
        if (parent) {
          parent.replies.push(comment);
        } else {
          rootComments.push(comment);
        }
      } else {
        rootComments.push(comment);
      }
    });
    
    return rootComments;
  } catch (error) {
    console.error("Error fetching threaded comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get user comments
const getUserComments = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username, p.title as post_title, p.community_id
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      LEFT JOIN post p ON c.post_id = p.id
      WHERE c.user_id = ?
      ORDER BY c.created_at DESC
    `, [userId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching user comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPostComments,
  getComment,
  createComment,
  updateComment,
  deleteComment,
  getCommentReplies,
  getThreadedComments,
  getUserComments
};

================
File: api/comments.js.new
================
// JavaScript version of comments.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all comments for a post
const getPostComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching post comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get a specific comment
const getComment = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [comment] = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.id = ?
    `, [commentId]);
    
    return comment || null;
  } catch (error) {
    console.error("Error fetching comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Create a new comment
const createComment = async (userId, commentData) => {
  const { content, post_id, parent_comment_id } = commentData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if post exists
      const [post] = await conn.query(
        "SELECT * FROM post WHERE id = ?",
        [post_id]
      );
      
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if parent comment exists if provided
      if (parent_comment_id) {
        const [parentComment] = await conn.query(
          "SELECT * FROM comment WHERE id = ?",
          [parent_comment_id]
        );
        
        if (!parentComment) {
          throw new Error('Parent comment not found');
        }
      }
      
      // Create the comment
      const id = uuidv4();
      
      let query = "INSERT INTO comment (id, content, user_id, post_id";
      let values = [id, content, userId, post_id];
      
      if (parent_comment_id) {
        query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
        values.push(parent_comment_id);
      } else {
        query += ") VALUES (?, ?, ?, ?)";
      }
      
      await conn.query(query, values);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'CREATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          id,
          'comment',
          JSON.stringify({
            post_id: post_id,
            parent_comment_id: parent_comment_id || null
          })
        ]
      );
      
      // Get the created comment with username
      const [newComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      return newComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Update a comment
const updateComment = async (commentId, userId, content) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return null;
      }
      
      if (comment.user_id !== userId) {
        throw new Error('You can only update your own comments');
      }
      
      // Update the comment
      await conn.query(
        "UPDATE comment SET content = ? WHERE id = ?",
        [content, commentId]
      );
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Get the updated comment with username
      const [updatedComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [commentId]);
      
      // Commit the transaction
      await conn.commit();
      
      return updatedComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Delete a comment
const deleteComment = async (commentId, userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return false;
      }
      
      // Check if user is the comment author or a moderator of the community
      if (comment.user_id !== userId) {
        // Get the post to find the community
        const [post] = await conn.query(
          "SELECT community_id FROM post WHERE id = ?",
          [comment.post_id]
        );
        
        if (!post) {
          throw new Error('Post not found');
        }
        
        // Check if user is a moderator
        const [moderator] = await conn.query(
          "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
          [post.community_id, userId]
        );
        
        if (!moderator) {
          throw new Error('You can only delete your own comments or comments in communities you moderate');
        }
      }
      
      // Find all replies to this comment recursively
      const findReplies = async (parentId, replyIds = []) => {
        const replies = await conn.query(
          "SELECT id FROM comment WHERE parent_comment_id = ?",
          [parentId]
        );
        
        for (const reply of replies) {
          replyIds.push(reply.id);
          await findReplies(reply.id, replyIds);
        }
        
        return replyIds;
      };
      
      const replyIds = await findReplies(commentId);
      
      // Log activity for the main comment
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Delete all replies
      if (replyIds.length > 0) {
        // Log activity for each reply
        for (const replyId of replyIds) {
          const [reply] = await conn.query(
            "SELECT * FROM comment WHERE id = ?",
            [replyId]
          );
          
          if (reply) {
            await conn.query(
              `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
               VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                uuidv4(),
                userId,
                activityTypeId,
                actionId,
                replyId,
                'comment',
                JSON.stringify({
                  post_id: reply.post_id,
                  parent_comment_id: reply.parent_comment_id || null
                })
              ]
            );
          }
        }
        
        const placeholders = replyIds.map(() => '?').join(',');
        await conn.query(
          `DELETE FROM comment WHERE id IN (${placeholders})`,
          replyIds
        );
      }
      
      // Delete the comment
      await conn.query(
        "DELETE FROM comment WHERE id = ?",
        [commentId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      return true;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get replies to a comment
const getCommentReplies = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const replies = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.parent_comment_id = ?
      ORDER BY c.created_at ASC
    `, [commentId]);
    
    return replies;
  } catch (error) {
    console.error("Error fetching comment replies:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get threaded comments for a post
const getThreadedComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get all comments for the post with usernames
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    // Add replies array to each comment
    const commentsWithReplies = comments.map(comment => ({
      ...comment,
      username: comment.username || 'Anonymous',
      replies: []
    }));
    
    // Create a map for quick lookup
    const commentMap = new Map();
    commentsWithReplies.forEach(comment => {
      commentMap.set(comment.id, comment);
    });
    
    // Organize into a tree structure
    const rootComments = [];
    
    commentsWithReplies.forEach(comment => {
      if (comment.parent_comment_id) {
        const parent = commentMap.get(comment.parent_comment_id);
        if (parent) {
          parent.replies.push(comment);
        } else {
          rootComments.push(comment);
        }
      } else {
        rootComments.push(comment);
      }
    });
    
    return rootComments;
  } catch (error) {
    console.error("Error fetching threaded comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get user comments
const getUserComments = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username, p.title as post_title, p.community_id
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      LEFT JOIN post p ON c.post_id = p.id
      WHERE c.user_id = ?
      ORDER BY c.created_at DESC
    `, [userId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching user comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPostComments,
  getComment,
  createComment,
  updateComment,
  deleteComment,
  getCommentReplies,
  getThreadedComments,
  getUserComments
};

================
File: api/comments.ts
================
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Comment {
    id: string;
    content: string;
    user_id: string;
    post_id: string;
    parent_comment_id?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommentInput {
    content: string;
    post_id: string;
    parent_comment_id?: string;
}

// Get all comments for a post
export async function getPostComments(postId: string): Promise<Comment[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const comments = await conn.query(
            "SELECT * FROM comments WHERE post_id = ? ORDER BY created_at ASC",
            [postId]
        );
        return comments;
    } catch (error) {
        console.error("Error fetching comments:", error);
        throw new Error('Failed to fetch comments');
    } finally {
        if (conn) conn.end();
    }
}

// Get a specific comment
export async function getComment(commentId: string): Promise<Comment | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [comment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        return comment || null;
    } catch (error) {
        console.error("Error fetching comment:", error);
        throw new Error('Failed to fetch comment');
    } finally {
        if (conn) conn.end();
    }
}

// Create a new comment
export async function createComment(userId: string, commentData: CommentInput): Promise<Comment> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Build the query based on whether parent_comment_id is provided
        let query = "INSERT INTO comments (id, content, user_id, post_id";
        let values = [id, commentData.content, userId, commentData.post_id];
        
        if (commentData.parent_comment_id) {
            query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
            values.push(commentData.parent_comment_id);
        } else {
            query += ") VALUES (?, ?, ?, ?)";
        }
        
        await conn.query(query, values);
        
        const [newComment] = await conn.query("SELECT * FROM comments WHERE id = ?", [id]);
        return newComment;
    } catch (error) {
        console.error("Error creating comment:", error);
        throw new Error('Failed to create comment');
    } finally {
        if (conn) conn.end();
    }
}

// Update a comment
export async function updateComment(
    commentId: string, 
    userId: string, 
    content: string
): Promise<Comment | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if the user is the author of the comment
        const [comment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        
        if (!comment) {
            return null;
        }
        
        if (comment.user_id !== userId) {
            throw new Error('You can only update your own comments');
        }
        
        await conn.query(
            "UPDATE comments SET content = ?, updated_at = NOW() WHERE id = ?",
            [content, commentId]
        );
        
        const [updatedComment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        return updatedComment;
    } catch (error) {
        console.error("Error updating comment:", error);
        throw error;
    } finally {
        if (conn) conn.end();
    }
}

// Delete a comment
export async function deleteComment(commentId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if the user is the author of the comment
        const [comment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        
        if (!comment) {
            return false;
        }
        
        if (comment.user_id !== userId) {
            throw new Error('You can only delete your own comments');
        }
        
        // Start a transaction to handle deleting the comment and its replies
        await conn.beginTransaction();
        
        // Delete all replies to this comment
        await conn.query(
            "DELETE FROM comments WHERE parent_comment_id = ?",
            [commentId]
        );
        
        // Delete the comment itself
        const result = await conn.query(
            "DELETE FROM comments WHERE id = ?",
            [commentId]
        );
        
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (conn) {
            await conn.rollback();
        }
        throw error;
    } finally {
        if (conn) conn.end();
    }
}

// Get replies to a comment
export async function getCommentReplies(commentId: string): Promise<Comment[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const replies = await conn.query(
            "SELECT * FROM comments WHERE parent_comment_id = ? ORDER BY created_at ASC",
            [commentId]
        );
        return replies;
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        throw new Error('Failed to fetch comment replies');
    } finally {
        if (conn) conn.end();
    }
}

// Define a type for threaded comments
export interface ThreadedComment extends Comment {
    username: string;
    replies: ThreadedComment[];
}

// Get threaded comments for a post
export async function getThreadedComments(postId: string): Promise<ThreadedComment[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get all comments for the post
        const comments: ThreadedComment[] = await conn.query(
            "SELECT c.*, u.username FROM comments c " +
            "JOIN users u ON c.user_id = u.id " +
            "WHERE c.post_id = ? " +
            "ORDER BY c.created_at ASC",
            [postId]
        );
        
        // Organize comments into a threaded structure
        const commentMap = new Map<string, ThreadedComment>();
        const rootComments: ThreadedComment[] = [];
        
        // First pass: create a map of all comments
        comments.forEach((comment: ThreadedComment) => {
            comment.replies = [];
            commentMap.set(comment.id, comment);
        });
        
        // Second pass: organize into a tree structure
        comments.forEach((comment: ThreadedComment) => {
            if (comment.parent_comment_id) {
                const parent = commentMap.get(comment.parent_comment_id);
                if (parent) {
                    parent.replies.push(comment);
                } else {
                    rootComments.push(comment);
                }
            } else {
                rootComments.push(comment);
            }
        });
        
        return rootComments;
    } catch (error) {
        console.error("Error fetching threaded comments:", error);
        throw new Error('Failed to fetch threaded comments');
    } finally {
        if (conn) conn.end();
    }
}

================
File: api/communities.js
================
// Fix for the community join request functionality
// This file extends the communities.ts code to handle both singular/plural naming issues

const mariadb = require('mariadb');
const dotenv = require('dotenv');
const { v4: uuidv4 } = require('uuid');

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

// Override the addCommunityMember function to handle the table name issue
exports.addCommunityMember = async function(communityId, userId, role = 'member') {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if user is already a member
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // Just update their role if needed
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // If they had a pending join request, try to mark it as approved
            // We catch errors here to handle the case where the table might not exist
            try {
                await conn.query(
                    "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
                    [communityId, userId]
                );
            } catch (error) {
                console.log("Note: community_join_request table might not exist yet. Continuing anyway.");
            }
            
            // Get user details
            const [user] = await conn.query(
                "SELECT username FROM user WHERE id = ?",
                [userId]
            );
            
            // Commit the transaction
            await conn.commit();
            
            return {
                community_id: communityId,
                user_id: userId,
                username: user.username,
                role: role,
                joined_at: existingMember.joined_at
            };
        }
        
        // Insert new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role, joined_at) VALUES (?, ?, ?, NOW())",
            [communityId, userId, role]
        );
        
        // If they had a pending join request, try to mark it as approved
        try {
            await conn.query(
                "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
                [communityId, userId]
            );
        } catch (error) {
            console.log("Note: community_join_request table might not exist yet. Continuing anyway.");
        }
        
        // Get user details
        const [user] = await conn.query(
            "SELECT username FROM user WHERE id = ?",
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ role })
            ]
        );
        
        // Update user statistics
        await conn.query(
            "UPDATE user_statistic SET communities_joined = communities_joined + 1 WHERE user_id = ?",
            [userId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return {
            community_id: communityId,
            user_id: userId,
            username: user.username,
            role,
            joined_at: new Date()
        };
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
};

================
File: api/communities.js.new
================
llconst mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community CRUD operations
const getCommunities = async () => {
  let conn;
  try {
    conn = await pool.getConnection();
    const communities = await conn.query("SELECT * FROM community");
    return communities;
  } catch (error) {
    console.error("Error fetching communities:", error);
    throw new Error('Failed to fetch communities');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunity = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    return community || null;
  } catch (error) {
    console.error("Error fetching community:", error);
    throw new Error('Failed to fetch community');
  } finally {
    if (conn) conn.end();
  }
};

const createCommunity = async (communityData) => {
  const { name, description, privacy, icon_url, banner_url, theme_color, creator_id } = communityData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Include all fields in the insert
    await conn.query(
      `INSERT INTO community (
        id, name, description, privacy, icon_url, banner_url, theme_color
      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        id, 
        name, 
        description, 
        privacy || 'public',
        icon_url || null,
        banner_url || null,
        theme_color || null
      ]
    );
    
    // Create default settings for the community
    await conn.query(
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, allow_post_videos,
        allow_polls, require_post_flair, show_in_discovery,
        join_method, content_filter_level
      ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
      [id]
    );
    
    // Log activity if creator_id is provided
    if (creator_id) {
      const activityId = uuidv4();
      await conn.query(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'community', NOW()
        )`,
        [activityId, creator_id, id]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
    return newCommunity;
  } catch (error) {
    console.error("Error creating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create community');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunity = async (communityId, communityData, userId) => {
  const { name, description, privacy, icon_url, banner_url, theme_color } = communityData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (name !== undefined) {
      updates.push("name = ?");
      values.push(name);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (privacy !== undefined) {
      updates.push("privacy = ?");
      values.push(privacy);
    }
    
    if (icon_url !== undefined) {
      updates.push("icon_url = ?");
      values.push(icon_url);
    }
    
    if (banner_url !== undefined) {
      updates.push("banner_url = ?");
      values.push(banner_url);
    }
    
    if (theme_color !== undefined) {
      updates.push("theme_color = ?");
      values.push(theme_color);
    }
    
    if (updates.length === 0) {
      // No fields to update
      return await getCommunity(communityId);
    }
    
    // Add the ID to the values array
    values.push(communityId);
    
    await conn.query(
      `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return await getCommunity(communityId);
  } catch (error) {
    console.error("Error updating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunity = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction to ensure all related data is deleted
    await conn.beginTransaction();
    
    // Delete community settings
    await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
    
    // Delete community rules
    await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
    
    // Delete community members
    await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
    
    // Delete join requests
    await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
    
    // Log activity before deleting the community
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Delete the community itself
    const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community');
  } finally {
    if (conn) conn.end();
  }
};

// Community Rules operations
const getCommunityRules = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const rules = await conn.query(
      "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
      [communityId]
    );
    return rules;
  } catch (error) {
    console.error("Error fetching community rules:", error);
    throw new Error('Failed to fetch community rules');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityRule = async (communityId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the highest position to determine the next position
    const [positionResult] = await conn.query(
      "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
      [communityId]
    );
    const nextPosition = (positionResult.maxPosition || 0) + 1;
    
    await conn.query(
      "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
      [id, communityId, title, description, position || nextPosition]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [id]
    );
    return newRule;
  } catch (error) {
    console.error("Error adding community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community rule');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityRule = async (ruleId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (title !== undefined) {
      updates.push("title = ?");
      values.push(title);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (position !== undefined) {
      updates.push("position = ?");
      values.push(position);
    }
    
    if (updates.length === 0) {
      // No fields to update
      const [rule] = await conn.query(
        "SELECT * FROM community_rule WHERE id = ?",
        [ruleId]
      );
      return rule || null;
    }
    
    // Add the ID to the values array
    values.push(ruleId);
    
    await conn.query(
      `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [updatedRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [ruleId]
    );
    return updatedRule || null;
  } catch (error) {
    console.error("Error updating community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community rule');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunityRule = async (ruleId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the rule to log its community_id
    const [rule] = await conn.query(
      "SELECT community_id FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    if (!rule) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_rule', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        ruleId, 
        JSON.stringify({ community_id: rule.community_id })
      ]
    );
    
    // Delete the rule
    const result = await conn.query(
      "DELETE FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community rule');
  } finally {
    if (conn) conn.end();
  }
};

// Community Settings operations
const getCommunitySettings = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get settings from the community_setting table
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    // If settings don't exist, create default settings
    if (!settings) {
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
        [communityId]
      );
      
      const [newSettings] = await conn.query(
        "SELECT * FROM community_setting WHERE community_id = ?",
        [communityId]
      );
      return newSettings;
    }
    
    return settings;
  } catch (error) {
    console.error("Error fetching community settings:", error);
    throw new Error('Failed to fetch community settings');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunitySettings = async (communityId, settingsData, userId) => {
  const { 
    allow_post_images, 
    allow_post_links, 
    allow_post_videos,
    allow_polls,
    require_post_flair,
    show_in_discovery,
    join_method,
    content_filter_level
  } = settingsData;
  
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if settings exist
    const [existingSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (!existingSettings) {
      // Create settings if they don't exist
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          communityId,
          allow_post_images !== undefined ? allow_post_images : true,
          allow_post_links !== undefined ? allow_post_links : true,
          allow_post_videos !== undefined ? allow_post_videos : true,
          allow_polls !== undefined ? allow_polls : true,
          require_post_flair !== undefined ? require_post_flair : false,
          show_in_discovery !== undefined ? show_in_discovery : true,
          join_method !== undefined ? join_method : 'auto_approve',
          content_filter_level !== undefined ? content_filter_level : 'none'
        ]
      );
    } else {
      // Build the update query dynamically based on provided fields
      const updates = [];
      const values = [];
      
      if (allow_post_images !== undefined) {
        updates.push("allow_post_images = ?");
        values.push(allow_post_images);
      }
      
      if (allow_post_links !== undefined) {
        updates.push("allow_post_links = ?");
        values.push(allow_post_links);
      }
      
      if (allow_post_videos !== undefined) {
        updates.push("allow_post_videos = ?");
        values.push(allow_post_videos);
      }
      
      if (allow_polls !== undefined) {
        updates.push("allow_polls = ?");
        values.push(allow_polls);
      }
      
      if (require_post_flair !== undefined) {
        updates.push("require_post_flair = ?");
        values.push(require_post_flair);
      }
      
      if (show_in_discovery !== undefined) {
        updates.push("show_in_discovery = ?");
        values.push(show_in_discovery);
      }
      
      if (join_method !== undefined) {
        updates.push("join_method = ?");
        values.push(join_method);
      }
      
      if (content_filter_level !== undefined) {
        updates.push("content_filter_level = ?");
        values.push(content_filter_level);
      }
      
      if (updates.length > 0) {
        // Add the community ID to the values array
        values.push(communityId);
        
        await conn.query(
          `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
          values
        );
      }
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_setting', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated settings
    const [updatedSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    return updatedSettings;
  } catch (error) {
    console.error("Error updating community settings:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community settings');
  } finally {
    if (conn) conn.end();
  }
};

// Community Members operations
const getCommunityMembers = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const members = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ?",
      [communityId]
    );
    return members;
  } catch (error) {
    console.error("Error fetching community members:", error);
    throw new Error('Failed to fetch community members');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityMember = async (communityId, userId, role = 'member') => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if the member already exists
    const [existingMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    if (existingMember) {
      // If the member already exists, update their role if different
      if (existingMember.role !== role) {
        await conn.query(
          "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
          [role, communityId, userId]
        );
      }
      
      // Commit the transaction
      await conn.commit();
      
      return existingMember;
    }
    
    // Add the new member
    await conn.query(
      "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
      [communityId, userId, role]
    );
    
    // Update user statistics
    await conn.query(
      `UPDATE user_statistic 
       SET communities_joined = communities_joined + 1
       WHERE user_id = ?`,
      [userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return newMember;
  } catch (error) {
    console.error("Error adding community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community member');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityMemberRole = async (communityId, userId, role, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Update the member's role
    await conn.query(
      "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
      [role, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_member', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        userId, 
        JSON.stringify({ 
          community_id: communityId,
          user_id: userId,
          new_role: role
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated member
    const [updatedMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return updatedMember || null;
  } catch (error) {
    console.error("Error updating community member role:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community member role');
  } finally {
    if (conn) conn.end();
  }
};

const removeCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Log activity before removing the member
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Remove the member
    const result = await conn.query(
      "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    // Update user statistics
    if (result.affectedRows > 0) {
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = GREATEST(communities_joined - 1, 0)
         WHERE user_id = ?`,
        [userId]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error removing community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to remove community member');
  } finally {
    if (conn) conn.end();
  }
};

// Community Join Request operations
const getJoinRequests = async (communityId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
};

const getJoinRequest = async (requestId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
};

const createJoinRequest = async (communityId, userId) => {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
};

const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestI

================
File: api/communities.js.new.part2
================
const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request || request.status !== 'pending') {
      // Only pending requests can be updated
      await conn.rollback();
      return null;
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
      [status, requestId]
    );
    
    // If approved, add the user as a community member
    if (status === 'approved') {
      await conn.query(
        "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, 'member') " +
        "ON DUPLICATE KEY UPDATE role = 'member'",
        [request.community_id, request.user_id]
      );
      
      // Update user statistics
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = communities_joined + 1
         WHERE user_id = ?`,
        [request.user_id]
      );
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id,
          status: status
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest || null;
  } catch (error) {
    console.error("Error updating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request');
  } finally {
    if (conn) conn.end();
  }
};

const deleteJoinRequest = async (requestId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the request to log its details
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Delete the request
    const result = await conn.query(
      "DELETE FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete join request');
  } finally {
    if (conn) conn.end();
  }
};

const getUserJoinRequests = async (userId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE user_id = ?";
    const params = [userId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching user join requests:", error);
    throw new Error('Failed to fetch user join requests');
  } finally {
    if (conn) conn.end();
  }
};

// Enhanced community information
const getCommunityAbout = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get the community
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return null;
    }
    
    // Get the member count
    const [memberCountResult] = await conn.query(
      "SELECT COUNT(*) as memberCount FROM community_member WHERE community_id = ?",
      [communityId]
    );
    const memberCount = memberCountResult.memberCount || 0;
    
    // Get the post count
    const [postCountResult] = await conn.query(
      "SELECT COUNT(*) as postCount FROM post WHERE community_id = ?",
      [communityId]
    );
    const postCount = postCountResult.postCount || 0;
    
    // Get the moderators
    const moderators = await conn.query(
      "SELECT user_id FROM community_member WHERE community_id = ? AND role IN ('moderator', 'admin')",
      [communityId]
    );
    const moderatorIds = moderators.map(mod => mod.user_id);
    
    // Return the enhanced community information
    return {
      ...community,
      memberCount,
      postCount,
      moderators: moderatorIds
    };
  } catch (error) {
    console.error("Error fetching community about:", error);
    throw new Error('Failed to fetch community about');
  } finally {
    if (conn) conn.end();
  }
};

const getUserCommunities = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get the communities the user is a member of
    const communities = await conn.query(
      `SELECT c.* 
       FROM community c
       JOIN community_member cm ON c.id = cm.community_id
       WHERE cm.user_id = ?`,
      [userId]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching user communities:", error);
    throw new Error('Failed to fetch user communities');
  } finally {
    if (conn) conn.end();
  }
};

const searchCommunities = async (searchTerm) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Search for communities by name or description
    const communities = await conn.query(
      `SELECT * FROM community 
       WHERE name LIKE ? OR description LIKE ?`,
      [`%${searchTerm}%`, `%${searchTerm}%`]
    );
    
    return communities;
  } catch (error) {
    console.error("Error searching communities:", error);
    throw new Error('Failed to search communities');
  } finally {
    if (conn) conn.end();
  }
};

// Export all functions
module.exports = {
  getCommunities,
  getCommunity,
  createCommunity,
  updateCommunity,
  deleteCommunity,
  getCommunityRules,
  addCommunityRule,
  updateCommunityRule,
  deleteCommunityRule,
  getCommunitySettings,
  updateCommunitySettings,
  getCommunityMembers,
  getCommunityMember,
  addCommunityMember,
  updateCommunityMemberRole,
  removeCommunityMember,
  getJoinRequests,
  getJoinRequest,
  createJoinRequest,
  updateJoinRequestStatus,
  deleteJoinRequest,
  getUserJoinRequests,
  getCommunityAbout,
  getUserCommunities,
  searchCommunities
};

================
File: api/communities.ts
================
// backend/api/communities.ts
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Community {
    id: string;
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityInput {
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    creator_id?: string;
}

export interface CommunityRule {
    id: string;
    community_id: string;
    title: string;
    description: string;
    position: number;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityRuleInput {
    title: string;
    description: string;
    position?: number;
}

export interface CommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    join_method: 'auto_approve' | 'requires_approval' | 'invite_only';
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface CommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    join_method?: 'auto_approve' | 'requires_approval' | 'invite_only';
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface CommunityMember {
    community_id: string;
    user_id: string;
    username: string;
    role: 'member' | 'moderator' | 'admin';
    joined_at: Date;
}

export interface JoinRequest {
    id: string;
    community_id: string;
    user_id: string;
    status: 'pending' | 'approved' | 'rejected';
    requested_at: Date;
    updated_at: Date;
}

export async function getCommunities(): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query("SELECT * FROM community");
        return communities;
    } catch (error) {
        console.error("Error fetching communities:", error);
        throw new Error('Failed to fetch communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunity(communityId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query("SELECT * FROM community WHERE id = ?", [communityId]);
        return community || null;
    } catch (error) {
        console.error("Error fetching community:", error);
        throw new Error('Failed to fetch community');
    } finally {
        if (conn) conn.end();
    }
}

export async function createCommunity(communityData: CommunityInput): Promise<Community> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Include all fields in the insert
        await conn.query(
            `INSERT INTO community (
                id, name, description, privacy, icon_url, banner_url, theme_color
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                id, 
                communityData.name, 
                communityData.description, 
                communityData.privacy || 'public',
                communityData.icon_url || null,
                communityData.banner_url || null,
                communityData.theme_color || null
            ]
        );
        
        // Create default settings for the community
        await conn.query(
            `INSERT INTO community_setting (
                community_id, allow_post_images, allow_post_links, join_method,
                require_post_approval, restricted_words, custom_theme_color,
                custom_banner_url, minimum_account_age_days, minimum_karma_required,
                updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
            [
                id,
                true, // allow_post_images
                true, // allow_post_links
                'auto_approve', // join_method
                false, // require_post_approval
                null, // restricted_words
                null, // custom_theme_color
                null, // custom_banner_url
                0, // minimum_account_age_days
                0, // minimum_karma_required
            ]
        );
        
        // Log the activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community', NOW()
            )`,
            [
                activityId, 
                communityData.creator_id || null, 
                id
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the created community
        const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
        return newCommunity;
    } catch (error) {
        console.error("Error creating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to create community');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunity(communityId: string, communityData: Partial<CommunityInput>, userId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (communityData.name !== undefined) {
            updates.push("name = ?");
            values.push(communityData.name);
        }
        
        if (communityData.description !== undefined) {
            updates.push("description = ?");
            values.push(communityData.description);
        }
        
        if (communityData.privacy !== undefined) {
            updates.push("privacy = ?");
            values.push(communityData.privacy);
        }
        
        if (communityData.icon_url !== undefined) {
            updates.push("icon_url = ?");
            values.push(communityData.icon_url);
        }
        
        if (communityData.banner_url !== undefined) {
            updates.push("banner_url = ?");
            values.push(communityData.banner_url);
        }
        
        if (communityData.theme_color !== undefined) {
            updates.push("theme_color = ?");
            values.push(communityData.theme_color);
        }
        
        if (updates.length === 0) {
            // No fields to update
            return await getCommunity(communityId);
        }
        
        // Add the ID to the values array
        values.push(communityId);
        
        await conn.query(
            `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify(communityData)
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated community
        return await getCommunity(communityId);
    } catch (error) {
        console.error("Error updating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunity(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Log activity before deletion
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Delete the community itself
        const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community');
    } finally {
        if (conn) conn.end();
    }
}

// Community Rules operations
export async function getCommunityRules(communityId: string): Promise<CommunityRule[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const rules = await conn.query(
            "SELECT * FROM community_rule WHERE community_id = ?",
            [communityId]
        );
        return rules;
    } catch (error) {
        console.error("Error fetching community rules:", error);
        throw new Error('Failed to fetch community rules');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityRule(communityId: string, ruleData: CommunityRuleInput, userId: string): Promise<CommunityRule> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        await conn.query(
            `INSERT INTO community_rule (
                id, community_id, title, description, created_at, updated_at
            ) VALUES (?, ?, ?, ?, NOW(), NOW())`,
            [
                id,
                communityId,
                ruleData.title,
                ruleData.description
            ]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, id]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [id]
        );
        return newRule;
    } catch (error) {
        console.error("Error adding community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityRule(ruleId: string, ruleData: Partial<CommunityRuleInput>, userId: string): Promise<CommunityRule | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (ruleData.title !== undefined) {
            updates.push("title = ?");
            values.push(ruleData.title);
        }
        
        if (ruleData.description !== undefined) {
            updates.push("description = ?");
            values.push(ruleData.description);
        }
        
        if (updates.length === 0) {
            // No fields to update
            const [rule] = await conn.query(
                "SELECT * FROM community_rule WHERE id = ?",
                [ruleId]
            );
            return rule || null;
        }
        
        // Add the ID to the values array
        values.push(ruleId);
        
        await conn.query(
            `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [updatedRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [ruleId]
        );
        return updatedRule || null;
    } catch (error) {
        console.error("Error updating community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunityRule(ruleId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the rule to log its community_id
        const [rule] = await conn.query(
            "SELECT community_id FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        if (!rule) {
            return false;
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community_rule', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                ruleId, 
                JSON.stringify({ community_id: rule.community_id })
            ]
        );
        
        // Delete the rule
        const result = await conn.query(
            "DELETE FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community rule');
    } finally {
        if (conn) conn.end();
    }
}

// Community Settings operations
export async function getCommunitySettings(communityId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        return settings || null;
    } catch (error) {
        console.error("Error fetching community settings:", error);
        throw new Error('Failed to fetch community settings');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunitySettings(communityId: string, settingsData: CommunitySettingsInput, userId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create default settings
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, join_method,
                    require_post_approval, restricted_words, custom_theme_color,
                    custom_banner_url, minimum_account_age_days, minimum_karma_required,
                    updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
                [
                    communityId,
                    settingsData.allow_post_images !== undefined ? settingsData.allow_post_images : true,
                    settingsData.allow_post_links !== undefined ? settingsData.allow_post_links : true,
                    settingsData.join_method || 'auto_approve',
                    settingsData.require_post_approval !== undefined ? settingsData.require_post_approval : false,
                    settingsData.restricted_words || null,
                    settingsData.custom_theme_color || null,
                    settingsData.custom_banner_url || null,
                    settingsData.minimum_account_age_days !== undefined ? settingsData.minimum_account_age_days : 0,
                    settingsData.minimum_karma_required !== undefined ? settingsData.minimum_karma_required : 0
                ]
            );
        } else {
            // Build the update query dynamically based on provided fields
            const updates: string[] = [];
            const values: any[] = [];
            
            if (settingsData.allow_post_images !== undefined) {
                updates.push("allow_post_images = ?");
                values.push(settingsData.allow_post_images);
            }
            
            if (settingsData.allow_post_links !== undefined) {
                updates.push("allow_post_links = ?");
                values.push(settingsData.allow_post_links);
            }
            
            if (settingsData.join_method !== undefined) {
                updates.push("join_method = ?");
                values.push(settingsData.join_method);
            }
            
            if (settingsData.require_post_approval !== undefined) {
                updates.push("require_post_approval = ?");
                values.push(settingsData.require_post_approval);
            }
            
            if (settingsData.restricted_words !== undefined) {
                updates.push("restricted_words = ?");
                values.push(settingsData.restricted_words);
            }
            
            if (settingsData.custom_theme_color !== undefined) {
                updates.push("custom_theme_color = ?");
                values.push(settingsData.custom_theme_color);
            }
            
            if (settingsData.custom_banner_url !== undefined) {
                updates.push("custom_banner_url = ?");
                values.push(settingsData.custom_banner_url);
            }
            
            if (settingsData.minimum_account_age_days !== undefined) {
                updates.push("minimum_account_age_days = ?");
                values.push(settingsData.minimum_account_age_days);
            }
            
            if (settingsData.minimum_karma_required !== undefined) {
                updates.push("minimum_karma_required = ?");
                values.push(settingsData.minimum_karma_required);
            }
            
            if (updates.length > 0) {
                // Add the ID to the values array
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE_SETTINGS'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify(settingsData)
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated settings
        return await getCommunitySettings(communityId);
    } catch (error) {
        console.error("Error updating community settings:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community settings');
    } finally {
        if (conn) conn.end();
    }
}

// Community Members operations
export async function getCommunityMembers(communityId: string): Promise<CommunityMember[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const members = await conn.query(
            `SELECT cm.*, u.username 
             FROM community_member cm
             JOIN user u ON cm.user_id = u.id
             WHERE cm.community_id = ?`,
            [communityId]
        );
        return members;
    } catch (error) {
        console.error("Error fetching community members:", error);
        throw new Error('Failed to fetch community members');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityMember(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin' = 'member'): Promise<CommunityMember> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if user is already a member
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // Just update their role if needed
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // If they had a pending join request, mark it as approved
            await conn.query(
                "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
                [communityId, userId]
            );
            
            // Get user details
            const [user] = await conn.query(
                "SELECT username FROM user WHERE id = ?",
                [userId]
            );
            
            // Commit the transaction
            await conn.commit();
            
            return {
                community_id: communityId,
                user_id: userId,
                username: user.username,
                role: role,
                joined_at: existingMember.joined_at
            };
        }
        
        // Insert new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role, joined_at) VALUES (?, ?, ?, NOW())",
            [communityId, userId, role]
        );
        
        // If they had a pending join request, mark it as approved
        await conn.query(
            "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
            [communityId, userId]
        );
        
        // Get user details
        const [user] = await conn.query(
            "SELECT username FROM user WHERE id = ?",
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ role })
            ]
        );
        
        // Update user statistics
        await conn.query(
            "UPDATE user_statistic SET communities_joined = communities_joined + 1 WHERE user_id = ?",
            [userId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return {
            community_id: communityId,
            user_id: userId,
            username: user.username,
            role,
            joined_at: new Date()
        };
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityMemberRole(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin', updatedBy: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if member exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingMember) {
            return null;
        }
        
        // Update role
        await conn.query(
            "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
            [role, communityId, userId]
        );
        
        // If promoting to moderator, add default permissions
        if (role === 'moderator' && existingMember.role !== 'moderator' && existingMember.role !== 'admin') {
            try {
                await conn.query(
                    `INSERT INTO moderator_permission (
                        community_id, user_id, 
                        can_manage_settings, can_manage_members, can_manage_posts, can_manage_comments,
                        created_at, updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())`,
                    [communityId, userId, true, true, true, true]
                );
            } catch (error) {
                // Ignore duplicate key errors (might already have permissions from before)
                if (error.code !== 'ER_DUP_ENTRY') {
                    throw error;
                }
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE_MEMBER_ROLE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                updatedBy, 
                communityId, 
                JSON.stringify({ user_id: userId, role })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Get user details
        const [user] = await conn.query(
            "SELECT username FROM user WHERE id = ?",
            [userId]
        );
        
        return {
            community_id: communityId,
            user_id: userId,
            username: user.username,
            role,
            joined_at: existingMember.joined_at
        };
    } catch (error) {
        console.error("Error updating community member role:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community member role');
    } finally {
        if (conn) conn.end();
    }
}

export async function removeCommunityMember(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if member exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingMember) {
            return false;
        }
        
        // Remove member
        await conn.query(
            "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Also remove any moderator permissions
        if (existingMember.role === 'moderator' || existingMember.role === 'admin') {
            await conn.query(
                "DELETE FROM moderator_permission WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'LEAVE'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Update user statistics
        await conn.query(
            "UPDATE user_statistic SET communities_joined = GREATEST(0, communities_joined - 1) WHERE user_id = ?",
            [userId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return true;
    } catch (error) {
        console.error("Error removing community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to remove community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityMember(communityId: string, userId: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
        const [member] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        console.log("Query result:", member);
        return member || null;
    } catch (error) {
        console.error("Error fetching community member:", error);
        throw new Error('Failed to fetch community member');
    } finally {
        if (conn) conn.end();
    }
}

// Community Join Request operations
export async function getJoinRequests(communityId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        let query = "SELECT * FROM community_join_request WHERE community_id = ?";
        const params: any[] = [communityId];
        
        if (status) {
            query += " AND status = ?";
            params.push(status);
        }
        
        const requests = await conn.query(query, params);
        return requests;
    } catch (error) {
        console.error("Error fetching join requests:", error);
        throw new Error('Failed to fetch join requests');
    } finally {
        if (conn) conn.end();
    }
}

export async function createJoinRequest(communityId: string, userId: string): Promise<JoinRequest> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Check if user is already a member
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            throw new Error('User is already a member of this community');
        }
        
        // Check if request already exists
        const [existingRequest] = await conn.query(
            "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
            [communityId, userId]
        );
        
        if (existingRequest) {
            throw new Error('Join request already exists');
        }
        
        // Create join request
        await conn.query(
            "INSERT INTO community_join_request (id, community_id, user_id, status, requested_at, updated_at) VALUES (?, ?, ?, 'pending', NOW(), NOW())",
            [id, communityId, userId]
        );
        
        // Get the created request
        const [newRequest] = await conn.query(
            "SELECT * FROM community_join_request WHERE id = ?",
            [id]
        );
        
        return newRequest;
    } catch (error) {
        console.error("Error creating join request:", error);
        throw error;
    } finally {
        if (conn) conn.end();
    }
}

export async function updateJoinRequest(requestId: string, status: 'approved' | 'rejected', moderatorId: string): Promise<JoinRequest | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the request
        const [request] = await conn.query(
            "SELECT * FROM community_join_request WHERE id = ?",
            [requestId]
        );
        
        if (!request) {
            return null;
        }
        
        // Update the request status
        await conn.query(
            "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
            [status, requestId]
        );
        
        // If approved, add the user as a community member
        if (status === 'approved') {
            await addCommunityMember(request.community_id, request.user_id, 'member');
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = ?),
                ?, 'community_join_request', ?, NOW()
            )`,
            [
                activityId, 
                moderatorId, 
                status === 'approved' ? 'APPROVE' : 'REJECT',
                requestId, 
                JSON.stringify({ community_id: request.community_id, user_id: request.user_id })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Get the updated request
        const [updatedRequest] = await conn.query(
            "SELECT * FROM community_join_request WHERE id = ?",
            [requestId]
        );
        
        return updatedRequest || null;
    } catch (error) {
        console.error("Error updating join request:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update join request');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityAbout(communityId: string): Promise<any | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get community details
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return null;
        }
        
        // Get moderators
        const moderators = await conn.query(
            `SELECT cm.*, u.username 
             FROM community_member cm
             JOIN user u ON cm.user_id = u.id
             WHERE cm.community_id = ? AND cm.role IN ('moderator', 'admin')`,
            [communityId]
        );
        
        // Get member count
        const [memberCountRow] = await conn.query(
            "SELECT COUNT(*) as count FROM community_member WHERE community_id = ?",
            [communityId]
        );
        
        // Get post count
        const [postCountRow] = await conn.query(
            "SELECT COUNT(*) as count FROM post WHERE community_id = ?",
            [communityId]
        );
        
        // Get creation date and format it
        const creationDate = new Date(community.created_at);
        const creationDateString = creationDate.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        });
        
        return {
            ...community,
            moderators,
            memberCount: memberCountRow.count,
            postCount: postCountRow.count,
            creationDateFormatted: creationDateString
        };
    } catch (error) {
        console.error("Error fetching community about:", error);
        throw new Error('Failed to fetch community about');
    } finally {
        if (conn) conn.end();
    }
}

export async function getUserCommunities(userId: string): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query(
            `SELECT c.*, cm.role
             FROM community c
             JOIN community_member cm ON c.id = cm.community_id
             WHERE cm.user_id = ?`,
            [userId]
        );
        return communities;
    } catch (error) {
        console.error("Error fetching user communities:", error);
        throw new Error('Failed to fetch user communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function searchCommunities(query: string): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Prepare the search query - simple LIKE search for now
        const searchPattern = `%${query}%`;
        
        const communities = await conn.query(
            `SELECT * FROM community 
             WHERE name LIKE ? OR description LIKE ? 
             ORDER BY name`,
            [searchPattern, searchPattern]
        );
        
        return communities;
    } catch (error) {
        console.error("Error searching communities:", error);
        throw new Error('Failed to search communities');
    } finally {
        if (conn) conn.end();
    }
}

================
File: api/communities.ts.new
================
// backend/api/communities.ts
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Community {
    id: string;
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityInput {
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    creator_id?: string;
}

export interface CommunityRule {
    id: string;
    community_id: string;
    title: string;
    description: string;
    position: number;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityRuleInput {
    title: string;
    description: string;
    position?: number;
}

export interface CommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    allow_post_videos: boolean;
    allow_polls: boolean;
    require_post_flair: boolean;
    show_in_discovery: boolean;
    join_method: 'auto_approve' | 'requires_approval' | 'invite_only';
    content_filter_level: 'none' | 'low' | 'medium' | 'high';
    updated_at: Date;
}

export interface CommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    allow_post_videos?: boolean;
    allow_polls?: boolean;
    require_post_flair?: boolean;
    show_in_discovery?: boolean;
    join_method?: 'auto_approve' | 'requires_approval' | 'invite_only';
    content_filter_level?: 'none' | 'low' | 'medium' | 'high';
}

export interface CommunityMember {
    community_id: string;
    user_id: string;
    role: 'member' | 'moderator' | 'admin';
    joined_at: Date;
}

export interface JoinRequest {
    id: string;
    community_id: string;
    user_id: string;
    status: 'pending' | 'approved' | 'rejected';
    requested_at: Date;
    updated_at: Date;
}

// Community CRUD operations
export async function getCommunities(): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query("SELECT * FROM community");
        return communities;
    } catch (error) {
        console.error("Error fetching communities:", error);
        throw new Error('Failed to fetch communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunity(communityId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query("SELECT * FROM community WHERE id = ?", [communityId]);
        return community || null;
    } catch (error) {
        console.error("Error fetching community:", error);
        throw new Error('Failed to fetch community');
    } finally {
        if (conn) conn.end();
    }
}

export async function createCommunity(communityData: CommunityInput): Promise<Community> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Include all fields in the insert
        await conn.query(
            `INSERT INTO community (
                id, name, description, privacy, icon_url, banner_url, theme_color
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                id, 
                communityData.name, 
                communityData.description, 
                communityData.privacy || 'public',
                communityData.icon_url || null,
                communityData.banner_url || null,
                communityData.theme_color || null
            ]
        );
        
        // Create default settings for the community
        await conn.query(
            `INSERT INTO community_setting (
                community_id, allow_post_images, allow_post_links, allow_post_videos,
                allow_polls, require_post_flair, show_in_discovery,
                join_method, content_filter_level
            ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
            [id]
        );
        
        // Log activity if creator_id is provided
        if (communityData.creator_id) {
            const activityId = uuidv4();
            await conn.query(
                `INSERT INTO activity (
                    id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
                ) VALUES (
                    ?, ?, 
                    (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                    (SELECT id FROM action WHERE name = 'CREATE'),
                    ?, 'community', NOW()
                )`,
                [activityId, communityData.creator_id, id]
            );
        }
        
        // Commit the transaction
        await conn.commit();
        
        const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
        return newCommunity;
    } catch (error) {
        console.error("Error creating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to create community');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunity(communityId: string, communityData: Partial<CommunityInput>, userId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (communityData.name !== undefined) {
            updates.push("name = ?");
            values.push(communityData.name);
        }
        
        if (communityData.description !== undefined) {
            updates.push("description = ?");
            values.push(communityData.description);
        }
        
        if (communityData.privacy !== undefined) {
            updates.push("privacy = ?");
            values.push(communityData.privacy);
        }
        
        if (communityData.icon_url !== undefined) {
            updates.push("icon_url = ?");
            values.push(communityData.icon_url);
        }
        
        if (communityData.banner_url !== undefined) {
            updates.push("banner_url = ?");
            values.push(communityData.banner_url);
        }
        
        if (communityData.theme_color !== undefined) {
            updates.push("theme_color = ?");
            values.push(communityData.theme_color);
        }
        
        if (updates.length === 0) {
            // No fields to update
            return await getCommunity(communityId);
        }
        
        // Add the ID to the values array
        values.push(communityId);
        
        await conn.query(
            `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return await getCommunity(communityId);
    } catch (error) {
        console.error("Error updating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunity(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction to ensure all related data is deleted
        await conn.beginTransaction();
        
        // Delete community settings
        await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
        
        // Delete community rules
        await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
        
        // Delete community members
        await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
        
        // Delete join requests
        await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
        
        // Log activity before deleting the community
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Delete the community itself
        const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community');
    } finally {
        if (conn) conn.end();
    }
}

// Community Rules operations
export async function getCommunityRules(communityId: string): Promise<CommunityRule[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const rules = await conn.query(
            "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
            [communityId]
        );
        return rules;
    } catch (error) {
        console.error("Error fetching community rules:", error);
        throw new Error('Failed to fetch community rules');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityRule(communityId: string, ruleData: CommunityRuleInput, userId: string): Promise<CommunityRule> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the highest position to determine the next position
        const [positionResult] = await conn.query(
            "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
            [communityId]
        );
        const nextPosition = (positionResult.maxPosition || 0) + 1;
        
        await conn.query(
            "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
            [id, communityId, ruleData.title, ruleData.description, ruleData.position || nextPosition]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, id]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [id]
        );
        return newRule;
    } catch (error) {
        console.error("Error adding community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityRule(ruleId: string, ruleData: Partial<CommunityRuleInput>, userId: string): Promise<CommunityRule | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (ruleData.title !== undefined) {
            updates.push("title = ?");
            values.push(ruleData.title);
        }
        
        if (ruleData.description !== undefined) {
            updates.push("description = ?");
            values.push(ruleData.description);
        }
        
        if (ruleData.position !== undefined) {
            updates.push("position = ?");
            values.push(ruleData.position);
        }
        
        if (updates.length === 0) {
            // No fields to update
            const [rule] = await conn.query(
                "SELECT * FROM community_rule WHERE id = ?",
                [ruleId]
            );
            return rule || null;
        }
        
        // Add the ID to the values array
        values.push(ruleId);
        
        await conn.query(
            `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [updatedRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [ruleId]
        );
        return updatedRule || null;
    } catch (error) {
        console.error("Error updating community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunityRule(ruleId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the rule to log its community_id
        const [rule] = await conn.query(
            "SELECT community_id FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        if (!rule) {
            return false;
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community_rule', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                ruleId, 
                JSON.stringify({ community_id: rule.community_id })
            ]
        );
        
        // Delete the rule
        const result = await conn.query(
            "DELETE FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community rule');
    } finally {
        if (conn) conn.end();
    }
}

// Community Settings operations
export async function getCommunitySettings(communityId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get settings from the community_setting table
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        // If settings don't exist, create default settings
        if (!settings) {
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, allow_post_videos,
                    allow_polls, require_post_flair, show_in_discovery,
                    join_method, content_filter_level
                ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
                [communityId]
            );
            
            const [newSettings] = await conn.query(
                "SELECT * FROM community_setting WHERE community_id = ?",
                [communityId]
            );
            return newSettings;
        }
        
        return settings;
    } catch (error) {
        console.error("Error fetching community settings:", error);
        throw new Error('Failed to fetch community settings');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunitySettings(communityId: string, settingsData: CommunitySettingsInput, userId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create settings if they don't exist
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, allow_post_videos,
                    allow_polls, require_post_flair, show_in_discovery,
                    join_method, content_filter_level
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    settingsData.allow_post_images !== undefined ? settingsData.allow_post_images : true,
                    settingsData.allow_post_links !== undefined ? settingsData.allow_post_links : true,
                    settingsData.allow_post_videos !== undefined ? settingsData.allow_post_videos : true,
                    settingsData.allow_polls !== undefined ? settingsData.allow_polls : true,
                    settingsData.require_post_flair !== undefined ? settingsData.require_post_flair : false,
                    settingsData.show_in_discovery !== undefined ? settingsData.show_in_discovery : true,
                    settingsData.join_method !== undefined ? settingsData.join_method : 'auto_approve',
                    settingsData.content_filter_level !== undefined ? settingsData.content_filter_level : 'none'
                ]
            );
        } else {
            // Build the update query dynamically based on provided fields
            const updates: string[] = [];
            const values: any[] = [];
            
            if (settingsData.allow_post_images !== undefined) {
                updates.push("allow_post_images = ?");
                values.push(settingsData.allow_post_images);
            }
            
            if (settingsData.allow_post_links !== undefined) {
                updates.push("allow_post_links = ?");
                values.push(settingsData.allow_post_links);
            }
            
            if (settingsData.allow_post_videos !== undefined) {
                updates.push("allow_post_videos = ?");
                values.push(settingsData.allow_post_videos);
            }
            
            if (settingsData.allow_polls !== undefined) {
                updates.push("allow_polls = ?");
                values.push(settingsData.allow_polls);
            }
            
            if (settingsData.require_post_flair !== undefined) {
                updates.push("require_post_flair = ?");
                values.push(settingsData.require_post_flair);
            }
            
            if (settingsData.show_in_discovery !== undefined) {
                updates.push("show_in_discovery = ?");
                values.push(settingsData.show_in_discovery);
            }
            
            if (settingsData.join_method !== undefined) {
                updates.push("join_method = ?");
                values.push(settingsData.join_method);
            }
            
            if (settingsData.content_filter_level !== undefined) {
                updates.push("content_filter_level = ?");
                values.push(settingsData.content_filter_level);
            }
            
            if (updates.length > 0) {
                // Add the community ID to the values array
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_setting', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated settings
        const [updatedSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        return updatedSettings;
    } catch (error) {
        console.error("Error updating community settings:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community settings');
    } finally {
        if (conn) conn.end();
    }
}

// Community Members operations
export async function getCommunityMembers(communityId: string): Promise<CommunityMember[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const members = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ?",
            [communityId]
        );
        return members;
    } catch (error) {
        console.error("Error fetching community members:", error);
        throw new Error('Failed to fetch community members');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityMember(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin' = 'member'): Promise<CommunityMember> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if the member already exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // If the member already exists, update their role if different
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // Commit the transaction
            await conn.commit();
            
            return existingMember;
        }
        
        // Add the new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
            [communityId, userId, role]
        );
        
        // Update user statistics
        await conn.query(
            `UPDATE user_statistic 
             SET communities_joined = communities_joined + 1
             WHERE user_id = ?`,
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        return newMember;
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityMemberRole(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin', updatedBy: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Update the member's role
        await conn.query(
            "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
            [role, communityId, userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_member', ?, NOW()
            )`,
            [
                activityId, 
                updatedBy, 
                userId, 
                JSON.stringify({ 
                    community_id: communityId,
                    user_id: userId,
                    new_role: role
                })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated member
        const [updatedMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        return updatedMember || null;
    } catch (error) {
        console.error("Error updating community member role:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community member role');
    } finally {
        if (conn) conn.end();
    }
}

export async function removeCommunityMember(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Log activity before removing the member
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'LEAVE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Remove the member
        const result = await conn.query(
            "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Update user statistics
        if (result.affectedRows > 0) {
            await conn.query(
                `UPDATE user_statistic 
                 SET communities_joined = GREATEST(communities_joined - 1, 0)
                 WHERE user_id = ?`,
                [userId]
            );
        }
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error removing community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to remove community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityMember(communityId: string, userId: string): Promise<CommunityMember | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
}

// Community Join Request operations
export async function getJoinRequests(communityId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params: any[] = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
}

export async function getJoinRequest(requestId: string): Promise<JoinRequest | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function createJoinRequest(communityId: string, userId: string): Promise<JoinRequest> {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function updateJoinRequestStatus(
  requestId: string, 
  status: 'approved' | 'rejected', 
  updatedBy: string
): Promise<JoinRequest | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request || request.status !== 'pending') {
      // Only pending requests can be updated
      await conn.rollback();
      return null;
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
      [status, requestId]
    );
    
    // If approved, add the user as a community member
    if (status === 'approved') {
      await conn.query(
        "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, 'member') " +
        "ON DUPLICATE KEY UPDATE role = 'member'",
        [request.community_id, request.user_id]
      );
      
      // Update user statistics
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = communities_joined + 1
         WHERE user_id = ?`,
        [request.user_id]
      );
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id,
          status: status
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest || null;
  } catch (error) {
    console.error("Error updating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function deleteJoinRequest(requestId: string, userId: string): Promise<boolean> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the request to log its details
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Delete the request
    const result = await conn.query(
      "DELETE FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function getUserJoinRequests(userId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE user_id = ?";
    const params: any[] = [userId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching user join requests:", error);
    throw new Error('Failed to fetch user join requests');
  } finally {
    if (conn) conn.end();
  }
}

================
File: api/community_fix.js
================
// This script temporarily patche the implementation of getCommunityAbout
// to ensure the API returns proper data format.

const fs = require('fs');
const path = require('path');

// File to patch
const filePath = path.join(__dirname, 'communities.js');

// Read the file
fs.readFile(filePath, 'utf8', (err, data) => {
  if (err) {
    console.error(`Error reading the file: ${err}`);
    return;
  }

  // Define the patch for the getCommunityAbout function
  const patchedFunction = `// Enhanced community information
const getCommunityAbout = async (communityId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Get the community
    const [community] = await conn.query(
      "SELECT * FROM communities WHERE id = ?", 
      [communityId]
    );
    
    if (!community) {
      return null;
    }
    
    // Get member count - fixed to properly extract count from result set
    let memberCount = 0;
    try {
      const memberCountResults = await conn.query(
        "SELECT COUNT(*) as count FROM community_members WHERE community_id = ?",
        [communityId]
      );
      
      // MariaDB returns count in first row, first column named 'count'
      if (memberCountResults && memberCountResults[0] && 
          memberCountResults[0].count !== undefined) {
        memberCount = memberCountResults[0].count;
      }
    } catch (error) {
      console.log("Error getting member count:", error.message);
    }
    
    // Get post count - with proper error handling
    let postCount = 0;
    try {
      const postCountResults = await conn.query(
        "SELECT COUNT(*) as count FROM posts WHERE community_id = ?",
        [communityId]
      );
      
      // MariaDB returns count in first row, first column named 'count'
      if (postCountResults && postCountResults[0] && 
          postCountResults[0].count !== undefined) {
        postCount = postCountResults[0].count;
      }
    } catch (error) {
      console.log("Note: posts table may not exist yet or error occurred:", error.message);
    }
    
    // Get moderators
    let moderatorIds = [];
    try {
      const moderators = await conn.query(
        "SELECT user_id FROM community_members WHERE community_id = ? AND (role = 'moderator' OR role = 'admin')",
        [communityId]
      );
      
      if (moderators && Array.isArray(moderators)) {
        moderatorIds = moderators.map(m => m.user_id);
      }
    } catch (error) {
      console.log("Error getting moderators:", error.message);
    }
    
    // Format the response to match frontend expectations
    return {
      id: community.id,
      name: community.name,
      description: community.description,
      privacy: community.privacy || 'public',
      created_at: community.created_at,
      updated_at: community.updated_at,
      memberCount: memberCount,
      postCount: postCount,
      moderators: moderatorIds
    };
  } catch (error) {
    console.error("Error fetching community about:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};`;

  // Find the getCommunityAbout implementation and replace it
  const regex = /\/\/ Enhanced community information[\s\S]*?const getCommunityAbout[\s\S]*?};/g;
  
  // Check if the function exists in the file
  if (!regex.test(data)) {
    console.error('Could not find getCommunityAbout function in the file');
    return;
  }
  
  // Replace the function with our patched version
  const updatedContent = data.replace(regex, patchedFunction);
  
  // Write the updated content back to the file
  fs.writeFile(filePath, updatedContent, 'utf8', (err) => {
    if (err) {
      console.error(`Error writing to the file: ${err}`);
      return;
    }
    console.log('Successfully patched communities.js');
  });
});

console.log('Attempting to patch communities.js file...');

================
File: api/community/community-core.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community CRUD operations
const getCommunities = async () => {
  let conn;
  try {
    conn = await pool.getConnection();
    const communities = await conn.query("SELECT * FROM community");
    return communities;
  } catch (error) {
    console.error("Error fetching communities:", error);
    throw new Error('Failed to fetch communities');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunity = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    return community || null;
  } catch (error) {
    console.error("Error fetching community:", error);
    throw new Error('Failed to fetch community');
  } finally {
    if (conn) conn.end();
  }
};

const createCommunity = async (communityData) => {
  const { name, description, privacy, icon_url, banner_url, theme_color, creator_id } = communityData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Include all fields in the insert
    await conn.query(
      `INSERT INTO community (
        id, name, description, privacy, icon_url, banner_url, theme_color
      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        id, 
        name, 
        description, 
        privacy || 'public',
        icon_url || null,
        banner_url || null,
        theme_color || null
      ]
    );
    
    // Create default settings for the community
    await conn.query(
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, allow_post_videos,
        allow_polls, require_post_flair, show_in_discovery,
        join_method, content_filter_level
      ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
      [id]
    );
    
    // Log activity if creator_id is provided
    if (creator_id) {
      const activityId = uuidv4();
      await conn.query(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'community', NOW()
        )`,
        [activityId, creator_id, id]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
    return newCommunity;
  } catch (error) {
    console.error("Error creating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create community');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunity = async (communityId, communityData, userId) => {
  const { name, description, privacy, icon_url, banner_url, theme_color } = communityData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (name !== undefined) {
      updates.push("name = ?");
      values.push(name);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (privacy !== undefined) {
      updates.push("privacy = ?");
      values.push(privacy);
    }
    
    if (icon_url !== undefined) {
      updates.push("icon_url = ?");
      values.push(icon_url);
    }
    
    if (banner_url !== undefined) {
      updates.push("banner_url = ?");
      values.push(banner_url);
    }
    
    if (theme_color !== undefined) {
      updates.push("theme_color = ?");
      values.push(theme_color);
    }
    
    if (updates.length === 0) {
      // No fields to update
      return await getCommunity(communityId);
    }
    
    // Add the ID to the values array
    values.push(communityId);
    
    await conn.query(
      `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return await getCommunity(communityId);
  } catch (error) {
    console.error("Error updating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunity = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction to ensure all related data is deleted
    await conn.beginTransaction();
    
    // Delete community settings
    await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
    
    // Delete community rules
    await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
    
    // Delete community members
    await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
    
    // Delete join requests
    await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
    
    // Log activity before deleting the community
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Delete the community itself
    const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunities,
  getCommunity,
  createCommunity,
  updateCommunity,
  deleteCommunity
};

================
File: api/community/community-members.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Members operations
const getCommunityMembers = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const members = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ?",
      [communityId]
    );
    return members;
  } catch (error) {
    console.error("Error fetching community members:", error);
    throw new Error('Failed to fetch community members');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityMember = async (communityId, userId, role = 'member') => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if the member already exists
    const [existingMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    if (existingMember) {
      // If the member already exists, update their role if different
      if (existingMember.role !== role) {
        await conn.query(
          "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
          [role, communityId, userId]
        );
      }
      
      // Commit the transaction
      await conn.commit();
      
      return existingMember;
    }
    
    // Add the new member
    await conn.query(
      "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
      [communityId, userId, role]
    );
    
    // Update user statistics
    await conn.query(
      `UPDATE user_statistic 
       SET communities_joined = communities_joined + 1
       WHERE user_id = ?`,
      [userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return newMember;
  } catch (error) {
    console.error("Error adding community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community member');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityMemberRole = async (communityId, userId, role, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Update the member's role
    await conn.query(
      "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
      [role, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_member', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        userId, 
        JSON.stringify({ 
          community_id: communityId,
          user_id: userId,
          new_role: role
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated member
    const [updatedMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return updatedMember || null;
  } catch (error) {
    console.error("Error updating community member role:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community member role');
  } finally {
    if (conn) conn.end();
  }
};

const removeCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Log activity before removing the member
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Remove the member
    const result = await conn.query(
      "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    // Update user statistics
    if (result.affectedRows > 0) {
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = GREATEST(communities_joined - 1, 0)
         WHERE user_id = ?`,
        [userId]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error removing community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to remove community member');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunityMembers,
  getCommunityMember,
  addCommunityMember,
  updateCommunityMemberRole,
  removeCommunityMember
};

================
File: api/community/community-requests.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Import the addCommunityMember function from community-members.js
const { addCommunityMember } = require('./community-members');

// Community Join Request operations
const getJoinRequests = async (communityId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
};

const getJoinRequest = async (requestId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
};

const createJoinRequest = async (communityId, userId) => {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
};

const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      throw new Error('Join request not found');
    }
    
    if (request.status !== 'pending') {
      throw new Error('Join request has already been processed');
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW(), updated_by = ? WHERE id = ?",
      [status, updatedBy, requestId]
    );
    
    // If the request is approved, add the user to the community
    if (status === 'approved') {
      await addCommunityMember(request.community_id, request.user_id, 'member');
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          status,
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest;
  } catch (error) {
    console.error("Error updating join request status:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request status: ' + error.message);
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getJoinRequests,
  getJoinRequest,
  createJoinRequest,
  updateJoinRequestStatus
};

================
File: api/community/community-rules.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Rules operations
const getCommunityRules = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const rules = await conn.query(
      "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
      [communityId]
    );
    return rules;
  } catch (error) {
    console.error("Error fetching community rules:", error);
    throw new Error('Failed to fetch community rules');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityRule = async (communityId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the highest position to determine the next position
    const [positionResult] = await conn.query(
      "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
      [communityId]
    );
    const nextPosition = (positionResult.maxPosition || 0) + 1;
    
    await conn.query(
      "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
      [id, communityId, title, description, position || nextPosition]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [id]
    );
    return newRule;
  } catch (error) {
    console.error("Error adding community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community rule');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityRule = async (ruleId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (title !== undefined) {
      updates.push("title = ?");
      values.push(title);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (position !== undefined) {
      updates.push("position = ?");
      values.push(position);
    }
    
    if (updates.length === 0) {
      // No fields to update
      const [rule] = await conn.query(
        "SELECT * FROM community_rule WHERE id = ?",
        [ruleId]
      );
      return rule || null;
    }
    
    // Add the ID to the values array
    values.push(ruleId);
    
    await conn.query(
      `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [updatedRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [ruleId]
    );
    return updatedRule || null;
  } catch (error) {
    console.error("Error updating community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community rule');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunityRule = async (ruleId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the rule to log its community_id
    const [rule] = await conn.query(
      "SELECT community_id FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    if (!rule) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_rule', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        ruleId, 
        JSON.stringify({ community_id: rule.community_id })
      ]
    );
    
    // Delete the rule
    const result = await conn.query(
      "DELETE FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community rule');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunityRules,
  addCommunityRule,
  updateCommunityRule,
  deleteCommunityRule
};

================
File: api/community/community-search.js
================
const mariadb = require('mariadb');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Search operations
const searchCommunities = async (searchTerm, limit = 20, offset = 0) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Search for communities by name or description
    const communities = await conn.query(
      `SELECT c.*, 
        (SELECT COUNT(*) FROM community_member WHERE community_id = c.id) as member_count
       FROM community c
       WHERE c.name LIKE ? OR c.description LIKE ?
       ORDER BY member_count DESC, c.created_at DESC
       LIMIT ? OFFSET ?`,
      [`%${searchTerm}%`, `%${searchTerm}%`, limit, offset]
    );
    
    return communities;
  } catch (error) {
    console.error("Error searching communities:", error);
    throw new Error('Failed to search communities');
  } finally {
    if (conn) conn.end();
  }
};

const getDiscoverableCommunities = async (limit = 20, offset = 0) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get communities that are set to be discoverable
    const communities = await conn.query(
      `SELECT c.*, 
        (SELECT COUNT(*) FROM community_member WHERE community_id = c.id) as member_count
       FROM community c
       JOIN community_setting cs ON c.id = cs.community_id
       WHERE cs.show_in_discovery = TRUE
       ORDER BY member_count DESC, c.created_at DESC
       LIMIT ? OFFSET ?`,
      [limit, offset]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching discoverable communities:", error);
    throw new Error('Failed to fetch discoverable communities');
  } finally {
    if (conn) conn.end();
  }
};

const getTrendingCommunities = async (limit = 10) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get trending communities based on recent activity
    const communities = await conn.query(
      `SELECT c.*, 
        COUNT(DISTINCT cm.user_id) as member_count,
        COUNT(DISTINCT a.id) as recent_activity_count
       FROM community c
       LEFT JOIN community_member cm ON c.id = cm.community_id
       LEFT JOIN activity a ON a.entity_id = c.id 
         AND a.entity_type = 'community'
         AND a.created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)
       JOIN community_setting cs ON c.id = cs.community_id
       WHERE cs.show_in_discovery = TRUE
       GROUP BY c.id
       ORDER BY recent_activity_count DESC, member_count DESC
       LIMIT ?`,
      [limit]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching trending communities:", error);
    throw new Error('Failed to fetch trending communities');
  } finally {
    if (conn) conn.end();
  }
};

const getRecommendedCommunities = async (userId, limit = 10) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get recommended communities based on user's interests and activity
    // This is a simplified recommendation algorithm
    const communities = await conn.query(
      `SELECT c.*, 
        COUNT(DISTINCT cm.user_id) as member_count
       FROM community c
       JOIN community_member cm ON c.id = cm.community_id
       JOIN community_setting cs ON c.id = cs.community_id
       WHERE cs.show_in_discovery = TRUE
       AND c.id NOT IN (
         SELECT community_id FROM community_member WHERE user_id = ?
       )
       AND cm.user_id IN (
         -- Users who are in the same communities as this user
         SELECT DISTINCT cm2.user_id 
         FROM community_member cm1
         JOIN community_member cm2 ON cm1.community_id = cm2.community_id
         WHERE cm1.user_id = ? AND cm2.user_id != ?
       )
       GROUP BY c.id
       ORDER BY member_count DESC
       LIMIT ?`,
      [userId, userId, userId, limit]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching recommended communities:", error);
    throw new Error('Failed to fetch recommended communities');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  searchCommunities,
  getDiscoverableCommunities,
  getTrendingCommunities,
  getRecommendedCommunities
};

================
File: api/community/community-settings.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Settings operations
const getCommunitySettings = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get settings from the community_setting table
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    // If settings don't exist, create default settings
    if (!settings) {
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
        [communityId]
      );
      
      const [newSettings] = await conn.query(
        "SELECT * FROM community_setting WHERE community_id = ?",
        [communityId]
      );
      return newSettings;
    }
    
    return settings;
  } catch (error) {
    console.error("Error fetching community settings:", error);
    throw new Error('Failed to fetch community settings');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunitySettings = async (communityId, settingsData, userId) => {
  const { 
    allow_post_images, 
    allow_post_links, 
    allow_post_videos,
    allow_polls,
    require_post_flair,
    show_in_discovery,
    join_method,
    content_filter_level
  } = settingsData;
  
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if settings exist
    const [existingSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (!existingSettings) {
      // Create settings if they don't exist
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          communityId,
          allow_post_images !== undefined ? allow_post_images : true,
          allow_post_links !== undefined ? allow_post_links : true,
          allow_post_videos !== undefined ? allow_post_videos : true,
          allow_polls !== undefined ? allow_polls : true,
          require_post_flair !== undefined ? require_post_flair : false,
          show_in_discovery !== undefined ? show_in_discovery : true,
          join_method !== undefined ? join_method : 'auto_approve',
          content_filter_level !== undefined ? content_filter_level : 'none'
        ]
      );
    } else {
      // Build the update query dynamically based on provided fields
      const updates = [];
      const values = [];
      
      if (allow_post_images !== undefined) {
        updates.push("allow_post_images = ?");
        values.push(allow_post_images);
      }
      
      if (allow_post_links !== undefined) {
        updates.push("allow_post_links = ?");
        values.push(allow_post_links);
      }
      
      if (allow_post_videos !== undefined) {
        updates.push("allow_post_videos = ?");
        values.push(allow_post_videos);
      }
      
      if (allow_polls !== undefined) {
        updates.push("allow_polls = ?");
        values.push(allow_polls);
      }
      
      if (require_post_flair !== undefined) {
        updates.push("require_post_flair = ?");
        values.push(require_post_flair);
      }
      
      if (show_in_discovery !== undefined) {
        updates.push("show_in_discovery = ?");
        values.push(show_in_discovery);
      }
      
      if (join_method !== undefined) {
        updates.push("join_method = ?");
        values.push(join_method);
      }
      
      if (content_filter_level !== undefined) {
        updates.push("content_filter_level = ?");
        values.push(content_filter_level);
      }
      
      if (updates.length > 0) {
        // Add the community ID to the values array
        values.push(communityId);
        
        await conn.query(
          `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
          values
        );
      }
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_setting', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated settings
    const [updatedSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    return updatedSettings;
  } catch (error) {
    console.error("Error updating community settings:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community settings');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunitySettings,
  updateCommunitySettings
};

================
File: api/community/index.js
================
/**
 * Community API Module
 * 
 * This module exports all community-related functions from the individual modules.
 * It serves as the main entry point for the community API.
 */

// Import all community modules
const communityCore = require('./community-core');
const communityRules = require('./community-rules');
const communitySettings = require('./community-settings');
const communityMembers = require('./community-members');
const communityRequests = require('./community-requests');
const communitySearch = require('./community-search');

// Re-export all functions
module.exports = {
  // Core operations
  getCommunities: communityCore.getCommunities,
  getCommunity: communityCore.getCommunity,
  createCommunity: communityCore.createCommunity,
  updateCommunity: communityCore.updateCommunity,
  deleteCommunity: communityCore.deleteCommunity,
  
  // Rules operations
  getCommunityRules: communityRules.getCommunityRules,
  addCommunityRule: communityRules.addCommunityRule,
  updateCommunityRule: communityRules.updateCommunityRule,
  deleteCommunityRule: communityRules.deleteCommunityRule,
  
  // Settings operations
  getCommunitySettings: communitySettings.getCommunitySettings,
  updateCommunitySettings: communitySettings.updateCommunitySettings,
  
  // Members operations
  getCommunityMembers: communityMembers.getCommunityMembers,
  getCommunityMember: communityMembers.getCommunityMember,
  addCommunityMember: communityMembers.addCommunityMember,
  updateCommunityMemberRole: communityMembers.updateCommunityMemberRole,
  removeCommunityMember: communityMembers.removeCommunityMember,
  
  // Join request operations
  getJoinRequests: communityRequests.getJoinRequests,
  getJoinRequest: communityRequests.getJoinRequest,
  createJoinRequest: communityRequests.createJoinRequest,
  updateJoinRequestStatus: communityRequests.updateJoinRequestStatus,
  
  // Search operations
  searchCommunities: communitySearch.searchCommunities,
  getDiscoverableCommunities: communitySearch.getDiscoverableCommunities,
  getTrendingCommunities: communitySearch.getTrendingCommunities,
  getRecommendedCommunities: communitySearch.getRecommendedCommunities
};

================
File: api/community/README.md
================
# Community API Module

This directory contains the refactored Community API module, which has been split into smaller, more maintainable files.

## Module Structure

- `index.js` - Main entry point that re-exports all functions
- `community-core.js` - Basic CRUD operations for communities
- `community-rules.js` - Community rule management
- `community-settings.js` - Community settings operations
- `community-members.js` - Community member management
- `community-requests.js` - Join request handling
- `community-search.js` - Search and discovery functions

## Usage

### Importing the entire module

```javascript
const communityApi = require('./community');

// Use any function from the module
const communities = await communityApi.getCommunities();
const community = await communityApi.getCommunity(communityId);
```

### Importing specific functions

```javascript
const { getCommunity, createCommunity } = require('./community');

// Use the imported functions
const community = await getCommunity(communityId);
const newCommunity = await createCommunity(communityData);
```

### Importing from specific submodules

```javascript
// Import only the search functions
const communitySearch = require('./community/community-search');

// Use the search functions
const results = await communitySearch.searchCommunities('gaming');
const trending = await communitySearch.getTrendingCommunities();
```

## Database Schema

This module interacts with the following tables:

- `community` - Core community data
- `community_setting` - Community settings
- `community_rule` - Community rules
- `community_member` - Community membership
- `community_join_request` - Join requests
- `activity` - Activity logging
- `activity_type` - Activity type definitions
- `action` - Action type definitions

## Activity Logging

All operations that modify data include activity logging. The activity logs include:

- User who performed the action
- Type of activity (COMMUNITY, COMMUNITY_RULE, etc.)
- Action performed (CREATE, UPDATE, DELETE, etc.)
- Entity affected
- Timestamp
- Additional metadata where relevant

## Error Handling

All functions include proper error handling and will throw descriptive error messages if operations fail. Transactions are used to ensure data consistency, with automatic rollback on failure.

================
File: api/moderation.ts
================
// backend/api/moderation.ts
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection';
import { RowDataPacket, ResultSetHeader } from 'mysql2/promise';

// Types
export interface ModeratorPermission {
    community_id: string;
    user_id: string;
    can_manage_settings: boolean;
    can_manage_members: boolean;
    can_manage_posts: boolean;
    can_manage_comments: boolean;
    created_at: Date;
    updated_at: Date;
}

export interface ModeratorPermissionInput {
    can_manage_settings?: boolean;
    can_manage_members?: boolean;
    can_manage_posts?: boolean;
    can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface PostModeration {
    post_id: string;
    status: 'pending' | 'approved' | 'rejected';
    moderator_id: string | null;
    reason: string | null;
    moderated_at: Date | null;
    created_at: Date;
}

export interface ModerationLog {
    id: string;
    community_id: string;
    moderator_id: string;
    action_type: string;
    entity_type: string;
    entity_id: string;
    reason: string | null;
    metadata: any | null;
    created_at: Date;
}

export interface BannedUser {
    community_id: string;
    user_id: string;
    reason: string | null;
    banned_by: string;
    expires_at: Date | null;
    created_at: Date;
}

// Define interfaces for query results
interface ModeratorPermissionRow extends RowDataPacket, ModeratorPermission {}
interface CommunitySettingsRow extends RowDataPacket, ExtendedCommunitySettings {}
interface PostModerationRow extends RowDataPacket, PostModeration {}
interface ModerationLogRow extends RowDataPacket, ModerationLog {}
interface BannedUserRow extends RowDataPacket, BannedUser {}
interface UserRow extends RowDataPacket {
    id: string;
    username: string;
    role: string;
}

/**
 * Check if a user is a moderator for a community
 */
export async function isModerator(userId: string, communityId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a community moderator or admin
        const [rows] = await conn.query<UserRow[]>(
            `SELECT role FROM community_member 
             WHERE community_id = ? AND user_id = ? 
             AND (role = 'moderator' OR role = 'admin')`,
            [communityId, userId]
        );
        
        if (!rows || rows.length === 0) {
            return false;
        }
        
        const member = rows[0];
        return Boolean(member && (member.role === 'moderator' || member.role === 'admin'));
    } catch (error) {
        console.error('Error checking if user is moderator:', error);
        return false;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Check if a moderator has a specific permission
 */
export async function hasModeratorPermission(
    userId: string, 
    communityId: string, 
    permission: 'can_manage_settings' | 'can_manage_members' | 'can_manage_posts' | 'can_manage_comments'
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // First, check if user is community admin (can do everything)
        const [memberRows] = await conn.query<UserRow[]>(
            `SELECT role FROM community_member 
             WHERE community_id = ? AND user_id = ? AND role = 'admin'`,
            [communityId, userId]
        );
        
        const member = memberRows && memberRows.length > 0 ? memberRows[0] : null;
        if (member && member.role === 'admin') {
            return true;
        }
        
        // Check specific permission
        const [permissionRows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        const permissions = permissionRows && permissionRows.length > 0 ? permissionRows[0] : null;
        return permissions ? Boolean(permissions[permission]) : false;
    } catch (error) {
        console.error('Error checking moderator permission:', error);
        return false;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get moderator permissions for a user in a community
 */
export async function getModeratorPermissions(
    userId: string, 
    communityId: string
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        return rows && rows.length > 0 ? rows[0] : null;
    } catch (error) {
        console.error('Error getting moderator permissions:', error);
        return null;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Update moderator permissions
 */
export async function updateModeratorPermissions(
    userId: string, 
    communityId: string, 
    permissions: ModeratorPermissionInput
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a moderator
        const [memberRows] = await conn.query<UserRow[]>(
            `SELECT role FROM community_member 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        const member = memberRows && memberRows.length > 0 ? memberRows[0] : null;
        if (!member || (member.role !== 'moderator' && member.role !== 'admin')) {
            throw new Error('User is not a moderator of this community');
        }
        
        // Get existing permissions
        const [existingRows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        const now = new Date();
        
        if (existingRows && existingRows.length > 0) {
            // Update existing permissions
            await conn.query(
                `UPDATE moderator_permission SET
                 can_manage_settings = ?,
                 can_manage_members = ?,
                 can_manage_posts = ?,
                 can_manage_comments = ?,
                 updated_at = ?
                 WHERE community_id = ? AND user_id = ?`,
                [
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : existingRows[0].can_manage_settings,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : existingRows[0].can_manage_members,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : existingRows[0].can_manage_posts,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : existingRows[0].can_manage_comments,
                    now,
                    communityId,
                    userId
                ]
            );
        } else {
            // Create new permissions
            await conn.query(
                `INSERT INTO moderator_permission (
                 community_id, user_id, can_manage_settings, can_manage_members,
                 can_manage_posts, can_manage_comments, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : true,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : true,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : true,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : true,
                    now,
                    now
                ]
            );
        }
        
        // Get updated permissions
        const [updatedRows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        return updatedRows && updatedRows.length > 0 ? updatedRows[0] : null;
    } catch (error) {
        console.error('Error updating moderator permissions:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get community settings
 */
export async function getCommunitySettings(communityId: string): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<CommunitySettingsRow[]>(
            `SELECT * FROM community_setting 
             WHERE community_id = ?`,
            [communityId]
        );
        
        return rows && rows.length > 0 ? rows[0] : null;
    } catch (error) {
        console.error('Error getting community settings:', error);
        return null;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Update community settings
 */
export async function updateCommunitySettings(
    communityId: string, 
    settings: ExtendedCommunitySettingsInput,
    moderatorId: string
): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if settings already exist
        const [existingRows] = await conn.query<CommunitySettingsRow[]>(
            `SELECT * FROM community_setting 
             WHERE community_id = ?`,
            [communityId]
        );
        
        const now = new Date();
        
        await conn.beginTransaction();
        
        try {
            if (existingRows && existingRows.length > 0) {
                // Update existing settings
                await conn.query(
                    `UPDATE community_setting SET
                     allow_post_images = ?,
                     allow_post_links = ?,
                     require_post_approval = ?,
                     restricted_words = ?,
                     custom_theme_color = ?,
                     custom_banner_url = ?,
                     minimum_account_age_days = ?,
                     minimum_karma_required = ?,
                     updated_at = ?
                     WHERE community_id = ?`,
                    [
                        settings.allow_post_images !== undefined ? settings.allow_post_images : existingRows[0].allow_post_images,
                        settings.allow_post_links !== undefined ? settings.allow_post_links : existingRows[0].allow_post_links,
                        settings.require_post_approval !== undefined ? settings.require_post_approval : existingRows[0].require_post_approval,
                        settings.restricted_words !== undefined ? settings.restricted_words : existingRows[0].restricted_words,
                        settings.custom_theme_color !== undefined ? settings.custom_theme_color : existingRows[0].custom_theme_color,
                        settings.custom_banner_url !== undefined ? settings.custom_banner_url : existingRows[0].custom_banner_url,
                        settings.minimum_account_age_days !== undefined ? settings.minimum_account_age_days : existingRows[0].minimum_account_age_days,
                        settings.minimum_karma_required !== undefined ? settings.minimum_karma_required : existingRows[0].minimum_karma_required,
                        now,
                        communityId
                    ]
                );
            } else {
                // Create new settings
                await conn.query(
                    `INSERT INTO community_setting (
                     community_id, allow_post_images, allow_post_links, require_post_approval,
                     restricted_words, custom_theme_color, custom_banner_url,
                     minimum_account_age_days, minimum_karma_required, updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    [
                        communityId,
                        settings.allow_post_images !== undefined ? settings.allow_post_images : true,
                        settings.allow_post_links !== undefined ? settings.allow_post_links : true,
                        settings.require_post_approval !== undefined ? settings.require_post_approval : false,
                        settings.restricted_words || null,
                        settings.custom_theme_color || null,
                        settings.custom_banner_url || null,
                        settings.minimum_account_age_days !== undefined ? settings.minimum_account_age_days : 0,
                        settings.minimum_karma_required !== undefined ? settings.minimum_karma_required : 0,
                        now
                    ]
                );
            }
            
            // Log the settings update
            await logModerationAction(
                communityId,
                moderatorId,
                'UPDATE',
                'SETTINGS',
                communityId,
                null,
                { settings }
            );
            
            await conn.commit();
            
            // Get updated settings
            const [newSettingsRows] = await conn.query<CommunitySettingsRow[]>(
                `SELECT * FROM community_setting 
                 WHERE community_id = ?`,
                [communityId]
            );
            
            return newSettingsRows && newSettingsRows.length > 0 ? newSettingsRows[0] : null;
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error updating community settings:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get post moderation status
 */
export async function getPostModerationStatus(postId: string): Promise<PostModeration | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<PostModerationRow[]>(
            `SELECT * FROM post_moderation 
             WHERE post_id = ?`,
            [postId]
        );
        
        return rows && rows.length > 0 ? rows[0] : null;
    } catch (error) {
        console.error('Error getting post moderation status:', error);
        return null;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Update post moderation status
 */
export async function updatePostModerationStatus(
    postId: string,
    status: 'pending' | 'approved' | 'rejected',
    moderatorId: string,
    reason?: string
): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        await conn.beginTransaction();
        
        try {
            // Check if post moderation entry exists
            const [existingRows] = await conn.query<PostModerationRow[]>(
                `SELECT * FROM post_moderation 
                 WHERE post_id = ?`,
                [postId]
            );
            
            const now = new Date();
            
            if (existingRows && existingRows.length > 0) {
                // Update existing moderation status
                await conn.query(
                    `UPDATE post_moderation SET
                     status = ?,
                     moderator_id = ?,
                     reason = ?,
                     moderated_at = ?
                     WHERE post_id = ?`,
                    [
                        status,
                        moderatorId,
                        reason || null,
                        now,
                        postId
                    ]
                );
                
                // Get the post's community ID for logging
                const [postRows] = await conn.query<RowDataPacket[]>(
                    `SELECT community_id FROM post 
                     WHERE id = ?`,
                    [postId]
                );
                
                // Log the moderation action
                if (postRows && postRows.length > 0) {
                    await logModerationAction(
                        postRows[0].community_id,
                        moderatorId,
                        status === 'approved' ? 'APPROVE' : 'REJECT',
                        'POST',
                        postId,
                        reason || null,
                        { previousStatus: existingRows[0].status }
                    );
                }
                
                await conn.commit();
                
                // Get updated moderation status
                const [updatedRows] = await conn.query<PostModerationRow[]>(
                    `SELECT * FROM post_moderation 
                     WHERE post_id = ?`,
                    [postId]
                );
                
                if (!updatedRows || updatedRows.length === 0) {
                    throw new Error("Failed to retrieve updated post moderation status");
                }
                
                return updatedRows[0];
            } else {
                // Create new moderation status
                await conn.query(
                    `INSERT INTO post_moderation (
                     post_id, status, moderator_id, reason, moderated_at, created_at
                    ) VALUES (?, ?, ?, ?, ?, ?)`,
                    [
                        postId,
                        status,
                        moderatorId,
                        reason || null,
                        status === 'pending' ? null : now,
                        now
                    ]
                );
                
                // Get the post's community ID for logging
                const [postRows] = await conn.query<RowDataPacket[]>(
                    `SELECT community_id FROM post 
                     WHERE id = ?`,
                    [postId]
                );
                
                // Log the moderation action (only for approvals/rejections)
                if (status !== 'pending' && postRows && postRows.length > 0) {
                    await logModerationAction(
                        postRows[0].community_id,
                        moderatorId,
                        status === 'approved' ? 'APPROVE' : 'REJECT',
                        'POST',
                        postId,
                        reason || null,
                        null
                    );
                }
                
                await conn.commit();
                
                // Get new moderation status
                const [newRows] = await conn.query<PostModerationRow[]>(
                    `SELECT * FROM post_moderation 
                     WHERE post_id = ?`,
                    [postId]
                );
                
                if (!newRows || newRows.length === 0) {
                    throw new Error("Failed to retrieve created post moderation status");
                }
                
                return newRows[0];
            }
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error updating post moderation status:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Log a moderation action
 */
export async function logModerationAction(
    communityId: string,
    moderatorId: string,
    actionType: string,
    entityType: string,
    entityId: string,
    reason: string | null,
    metadata: any | null
): Promise<ModerationLog> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const id = uuidv4();
        const now = new Date();
        
        await conn.query(
            `INSERT INTO moderation_log (
             id, community_id, moderator_id, action_type, entity_type,
             entity_id, reason, metadata, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                id,
                communityId,
                moderatorId,
                actionType,
                entityType,
                entityId,
                reason,
                metadata ? JSON.stringify(metadata) : null,
                now
            ]
        );
        
        // Get the created log entry
        const [rows] = await conn.query<ModerationLogRow[]>(
            `SELECT * FROM moderation_log 
             WHERE id = ?`,
            [id]
        );
        
        if (!rows || rows.length === 0) {
            throw new Error("Failed to retrieve created moderation log");
        }
        
        return rows[0];
    } catch (error) {
        console.error('Error logging moderation action:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get moderation logs for a community
 */
export async function getModerationLogs(
    communityId: string,
    limit: number = 20,
    offset: number = 0
): Promise<ModerationLog[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<ModerationLogRow[]>(
            `SELECT ml.*, u.username as moderator_username
             FROM moderation_log ml
             JOIN user u ON ml.moderator_id = u.id
             WHERE ml.community_id = ?
             ORDER BY ml.created_at DESC
             LIMIT ? OFFSET ?`,
            [communityId, limit, offset]
        );
        
        return rows || [];
    } catch (error) {
        console.error('Error getting moderation logs:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Ban a user from a community
 */
export async function banUserFromCommunity(
    communityId: string,
    userId: string,
    moderatorId: string,
    reason: string | null,
    expiresAt: Date | null
): Promise<BannedUser> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        await conn.beginTransaction();
        
        try {
            // Delete existing community membership
            await conn.query(
                `DELETE FROM community_member 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            // Create ban record
            const now = new Date();
            
            await conn.query(
                `INSERT INTO banned_user (
                 community_id, user_id, reason, banned_by, expires_at, created_at
                ) VALUES (?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    reason,
                    moderatorId,
                    expiresAt,
                    now
                ]
            );
            
            // Log the moderation action
            await logModerationAction(
                communityId,
                moderatorId,
                'BAN',
                'USER',
                userId,
                reason,
                { expiresAt }
            );
            
            await conn.commit();
            
            // Get the ban record
            const [rows] = await conn.query<BannedUserRow[]>(
                `SELECT * FROM banned_user 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            if (!rows || rows.length === 0) {
                throw new Error("Failed to retrieve ban record");
            }
            
            return rows[0];
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error banning user from community:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Check if a user is banned from a community
 */
export async function isUserBanned(userId: string, communityId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check for an active ban
        const [rows] = await conn.query<BannedUserRow[]>(
            `SELECT * FROM banned_user 
             WHERE community_id = ? AND user_id = ? 
             AND (expires_at IS NULL OR expires_at > NOW())`,
            [communityId, userId]
        );
        
        return Boolean(rows && rows.length > 0);
    } catch (error) {
        console.error('Error checking if user is banned:', error);
        return false;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Unban a user from a community
 */
export async function unbanUserFromCommunity(
    communityId: string,
    userId: string,
    moderatorId: string
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        await conn.beginTransaction();
        
        try {
            // First, check if the user is banned
            const [banRows] = await conn.query<BannedUserRow[]>(
                `SELECT * FROM banned_user 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            if (!banRows || banRows.length === 0) {
                throw new Error('User is not banned from this community');
            }
            
            // Remove the ban
            await conn.query(
                `DELETE FROM banned_user 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            // Log the moderation action
            await logModerationAction(
                communityId,
                moderatorId,
                'UNBAN',
                'USER',
                userId,
                null,
                { previousBan: banRows[0] }
            );
            
            await conn.commit();
            
            return true;
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error unbanning user from community:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

================
File: api/moderation.ts.new
================
// backend/api/moderation.ts
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection.js';

// Types
export interface ModeratorPermission {
    community_id: string;
    user_id: string;
    can_manage_settings: boolean;
    can_manage_members: boolean;
    can_manage_posts: boolean;
    can_manage_comments: boolean;
    created_at: Date;
    updated_at: Date;
}

export interface ModeratorPermissionInput {
    can_manage_settings?: boolean;
    can_manage_members?: boolean;
    can_manage_posts?: boolean;
    can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface PostModeration {
    post_id: string;
    status: 'pending' | 'approved' | 'rejected';
    moderator_id: string | null;
    reason: string | null;
    moderated_at: Date | null;
    created_at: Date;
}

export interface ModerationLog {
    id: string;
    community_id: string;
    moderator_id: string;
    action_type: string;
    target_id: string | null;
    target_type: string | null;
    reason: string | null;
    created_at: Date;
}

export interface BannedUser {
    community_id: string;
    user_id: string;
    reason: string | null;
    banned_by: string;
    ban_expires_at: Date | null;
    created_at: Date;
}

// Helper function to check if a user has moderator permissions
export async function isUserModerator(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [member] = await conn.query(
            "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return member && (member.role === 'moderator' || member.role === 'admin');
    } catch (error) {
        console.error("Error checking moderator status:", error);
        throw new Error('Failed to check moderator status');
    } finally {
        if (conn) conn.release();
    }
}

// Helper function to check specific moderator permissions
export async function hasModeratorPermission(
    communityId: string, 
    userId: string, 
    permission: 'can_manage_settings' | 'can_manage_members' | 'can_manage_posts' | 'can_manage_comments'
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // First check if user is a moderator or admin
        const isModerator = await isUserModerator(communityId, userId);
        if (!isModerator) {
            return false;
        }
        
        // Check for specific permission
        const [permissions] = await conn.query(
            `SELECT ${permission} FROM moderator_permission WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        // If no specific permissions set, check if admin (admins have all permissions)
        if (!permissions) {
            const [member] = await conn.query(
                "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
            
            return member && member.role === 'admin';
        }
        
        return !!permissions[permission];
    } catch (error) {
        console.error(`Error checking moderator permission (${permission}):`, error);
        throw new Error(`Failed to check moderator permission: ${permission}`);
    } finally {
        if (conn) conn.release();
    }
}

// Moderator Permissions CRUD
export async function getModeratorPermissions(communityId: string, userId: string): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [permissions] = await conn.query(
            "SELECT * FROM moderator_permission WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return permissions || null;
    } catch (error) {
        console.error("Error fetching moderator permissions:", error);
        throw new Error('Failed to fetch moderator permissions');
    } finally {
        if (conn) conn.release();
    }
}

export async function setModeratorPermissions(
    communityId: string, 
    userId: string, 
    permissions: ModeratorPermissionInput
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a moderator or admin
        const [member] = await conn.query(
            "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!member || (member.role !== 'moderator' && member.role !== 'admin')) {
            throw new Error('User is not a moderator or admin of this community');
        }
        
        // Check if permissions already exist
        const [existingPermissions] = await conn.query(
            "SELECT * FROM moderator_permission WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingPermissions) {
            // Update existing permissions
            const updates: string[] = [];
            const values: any[] = [];
            
            if (permissions.can_manage_settings !== undefined) {
                updates.push("can_manage_settings = ?");
                values.push(permissions.can_manage_settings);
            }
            
            if (permissions.can_manage_members !== undefined) {
                updates.push("can_manage_members = ?");
                values.push(permissions.can_manage_members);
            }
            
            if (permissions.can_manage_posts !== undefined) {
                updates.push("can_manage_posts = ?");
                values.push(permissions.can_manage_posts);
            }
            
            if (permissions.can_manage_comments !== undefined) {
                updates.push("can_manage_comments = ?");
                values.push(permissions.can_manage_comments);
            }
            
            if (updates.length > 0) {
                values.push(communityId);
                values.push(userId);
                
                await conn.query(
                    `UPDATE moderator_permission SET ${updates.join(", ")} WHERE community_id = ? AND user_id = ?`,
                    values
                );
            }
        } else {
            // Create new permissions
            await conn.query(
                `INSERT INTO moderator_permission (
                    community_id, 
                    user_id, 
                    can_manage_settings, 
                    can_manage_members, 
                    can_manage_posts, 
                    can_manage_comments
                ) VALUES (?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : false,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : false,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : false,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : false
                ]
            );
        }
        
        // Return the updated permissions
        return await getModeratorPermissions(communityId, userId);
    } catch (error) {
        console.error("Error setting moderator permissions:", error);
        throw new Error('Failed to set moderator permissions');
    } finally {
        if (conn) conn.release();
    }
}

// Enhanced Community Settings CRUD
export async function getEnhancedCommunitySettings(communityId: string): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!settings) {
            // Create default settings if they don't exist
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, 
                    allow_post_images, 
                    allow_post_links,
                    require_post_approval,
                    minimum_account_age_days,
                    minimum_karma_required
                ) VALUES (?, TRUE, TRUE, FALSE, 0, 0)`,
                [communityId]
            );
            
            const [newSettings] = await conn.query(
                "SELECT * FROM community_setting WHERE community_id = ?",
                [communityId]
            );
            
            return newSettings;
        }
        
        return settings;
    } catch (error) {
        console.error("Error fetching enhanced community settings:", error);
        throw new Error('Failed to fetch enhanced community settings');
    } finally {
        if (conn) conn.release();
    }
}

export async function updateEnhancedCommunitySettings(
    communityId: string, 
    settings: ExtendedCommunitySettingsInput
): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create settings with provided values if they don't exist
            const insertColumns: string[] = ["community_id"];
            const placeholders: string[] = ["?"];
            const values: any[] = [communityId];
            
            // Build dynamic insert query based on provided settings
            Object.entries(settings).forEach(([key, value]) => {
                if (value !== undefined) {
                    insertColumns.push(key);
                    placeholders.push("?");
                    values.push(value);
                }
            });
            
            await conn.query(
                `INSERT INTO community_setting (${insertColumns.join(", ")}) VALUES (${placeholders.join(", ")})`,
                values
            );
        } else {
            // Update existing settings
            const updates: string[] = [];
            const values: any[] = [];
            
            Object.entries(settings).forEach(([key, value]) => {
                if (value !== undefined) {
                    updates.push(`${key} = ?`);
                    values.push(value);
                }
            });
            
            if (updates.length > 0) {
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Return the updated settings
        return await getEnhancedCommunitySettings(communityId);
    } catch (error) {
        console.error("Error updating enhanced community settings:", error);
        throw new Error('Failed to update enhanced community settings');
    } finally {
        if (conn) conn.release();
    }
}

// Post Moderation functions
export async function getPostModerationStatus(postId: string): Promise<PostModeration | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [status] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return status || null;
    } catch (error) {
        console.error("Error fetching post moderation status:", error);
        throw new Error('Failed to fetch post moderation status');
    } finally {
        if (conn) conn.release();
    }
}

export async function addPostToModQueue(postId: string): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if post already in moderation queue
        const [existingModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        if (existingModeration) {
            return existingModeration;
        }
        
        // Add post to moderation queue
        await conn.query(
            "INSERT INTO post_moderation (post_id, status) VALUES (?, 'pending')",
            [postId]
        );
        
        const [newModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return newModeration;
    } catch (error) {
        console.error("Error adding post to moderation queue:", error);
        throw new Error('Failed to add post to moderation queue');
    } finally {
        if (conn) conn.release();
    }
}

export async function moderatePost(
    postId: string, 
    moderatorId: string, 
    action: 'approve' | 'reject', 
    reason?: string
): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get post information to log the action
        const [post] = await conn.query(
            "SELECT community_id FROM post WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            throw new Error('Post not found');
        }
        
        // Update post moderation status
        await conn.query(
            "UPDATE post_moderation SET status = ?, moderator_id = ?, reason = ?, moderated_at = NOW() WHERE post_id = ?",
            [action === 'approve' ? 'approved' : 'rejected', moderatorId, reason || null, postId]
        );
        
        // Log the moderation action
        await createModerationLog(
            post.community_id,
            moderatorId,
            action === 'approve' ? 'approve_post' : 'reject_post',
            postId,
            'post',
            reason
        );
        
        // Retrieve and return updated moderation status
        const [updatedModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return updatedModeration;
    } catch (error) {
        console.error("Error moderating post:", error);
        throw new Error('Failed to moderate post');
    } finally {
        if (conn) conn.release();
    }
}

export async function getPendingModQueue(communityId: string): Promise<any[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get all pending posts for the community
        const pendingPosts = await conn.query(
            `SELECT p.*, pm.status, pm.created_at as queued_at, u.username as author_username
             FROM post p
             JOIN post_moderation pm ON p.id = pm.post_id
             JOIN user u ON p.user_id = u.id
             WHERE p.community_id = ? AND pm.status = 'pending'
             ORDER BY pm.created_at ASC`,
            [communityId]
        );
        
        return pendingPosts;
    } catch (error) {
        console.error("Error fetching pending moderation queue:", error);
        throw new Error('Failed to fetch pending moderation queue');
    } finally {
        if (conn) conn.release();
    }
}

// Moderation Log functions
export async function createModerationLog(
    communityId: string,
    moderatorId: string,
    actionType: string,
    targetId?: string,
    targetType?: string,
    reason?: string
): Promise<ModerationLog> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const id = uuidv4();
        
        await conn.query(
            `INSERT INTO moderation_log (
                id, 
                community_id, 
                moderator_id, 
                action_type, 
                target_id, 
                target_type, 
                reason
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [id, communityId, moderatorId, actionType, targetId || null, targetType || null, reason || null]
        );
        
        const [log] = await conn.query(
            "SELECT * FROM moderation_log WHERE id = ?",
            [id]
        );
        
        return log;
    } catch (error) {
        console.error("Error creating moderation log:", error);
        throw new Error('Failed to create moderation log');
    } finally {
        if (conn) conn.release();
    }
}

export async function getModerationLogs(communityId: string, limit = 50, offset = 0): Promise<ModerationLog[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const logs = await conn.query(
            `SELECT ml.*, u.username as moderator_username 
             FROM moderation_log ml
             JOIN user u ON ml.moderator_id = u.id
             WHERE ml.community_id = ?
             ORDER BY ml.created_at DESC
             LIMIT ? OFFSET ?`,
            [communityId, limit, offset]
        );
        
        return logs;
    } catch (error) {
        console.error("Error fetching moderation logs:", error);
        throw new Error('Failed to fetch moderation logs');
    } finally {
        if (conn) conn.release();
    }
}

// User banning functions
export async function banUserFromCommunity(
    communityId: string,
    userId: string,
    bannedBy: string,
    reason?: string,
    banDuration?: number // Duration in days, null for permanent
): Promise<BannedUser> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Calculate expiration date if duration provided
        let banExpiresAt = null;
        if (banDuration) {
            const expirationDate = new Date();
            expirationDate.setDate(expirationDate.getDate() + banDuration);
            banExpiresAt = expirationDate;
        }
        
        // Check if user is already banned
        const [existingBan] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingBan) {
            // Update existing ban
            await conn.query(
                "UPDATE banned_user SET reason = ?, banned_by = ?, ban_expires_at = ? WHERE community_id = ? AND user_id = ?",
                [reason || null, bannedBy, banExpiresAt, communityId, userId]
            );
        } else {
            // Create new ban
            await conn.query(
                "INSERT INTO banned_user (community_id, user_id, reason, banned_by, ban_expires_at) VALUES (?, ?, ?, ?, ?)",
                [communityId, userId, reason || null, bannedBy, banExpiresAt]
            );
            
            // Remove user from community members if they're a member
            await conn.query(
                "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
        }
        
        // Log the ban action
        await createModerationLog(
            communityId,
            bannedBy,
            'ban_user',
            userId,
            'user',
            reason
        );
        
        const [ban] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return ban;
    } catch (error) {
        console.error("Error banning user from community:", error);
        throw new Error('Failed to ban user from community');
    } finally {
        if (conn) conn.release();
    }
}

export async function unbanUserFromCommunity(
    communityId: string,
    userId: string,
    unbannedBy: string,
    reason?: string
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is banned
        const [existingBan] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingBan) {
            return false; // User wasn't banned
        }
        
        // Remove ban
        await conn.query(
            "DELETE FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Log the unban action
        await createModerationLog(
            communityId,
            unbannedBy,
            'unban_user',
            userId,
            'user',
            reason
        );
        
        return true;
    } catch (error) {
        console.error("Error unbanning user from community:", error);
        throw new Error('Failed to unban user from community');
    } finally {
        if (conn) conn.release();
    }
}

export async function getBannedUsers(communityId: string): Promise<any[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const bannedUsers = await conn.query(
            `SELECT bu.*, 
                    u.username as banned_username, 
                    m.username as moderator_username
             FROM banned_user bu
             JOIN user u ON bu.user_id = u.id
             JOIN user m ON bu.banned_by = m.id
             WHERE bu.community_id = ?
             ORDER BY bu.created_at DESC`,
            [communityId]
        );
        
        return bannedUsers;
    } catch (error) {
        console.error("Error fetching banned users:", error);
        throw new Error('Failed to fetch banned users');
    } finally {
        if (conn) conn.release();
    }
}

export async function isUserBanned(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check for active bans
        const [ban] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
            [communityId, userId]
        );
        
        return !!ban;
    } catch (error) {
        console.error("Error checking if user is banned:", error);
        throw new Error('Failed to check if user is banned');
    } finally {
        if (conn) conn.release();
    }
}

================
File: api/posts_enhanced.js
================
// backend/api/posts_enhanced.js
const { v4: uuidv4 } = require('uuid');
const mariadb = require('mariadb');
const dotenv = require('dotenv');

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

// Function to get community ID from post ID (needed for permission checks)
const getCommunityIdFromPost = async (postId) => {
    let conn;
    try {
        conn = await pool.getConnection();
        const [post] = await conn.query(
            "SELECT community_id FROM posts WHERE id = ?",
            [postId]
        );
        return post ? post.community_id : null;
    } catch (error) {
        console.error("Error fetching community ID from post:", error);
        throw new Error('Failed to fetch community ID from post');
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced post creation with moderation support
const createPostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const { title, content, communityId } = req.body;
        const userId = req.user.id;
        
        // Validate required fields
        if (!title || !content || !communityId) {
            return res.status(400).json({ message: 'Title, content, and communityId are required' });
        }
        
        // Check if community exists
        const [community] = await conn.query(
            "SELECT * FROM communities WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ message: 'Community not found' });
        }
        
        // Start a transaction
        await conn.beginTransaction();
        
        try {
            // Check if user is banned from the community
            const { isUserBanned } = require('./moderation');
            const banned = await isUserBanned(communityId, userId);
            
            if (banned) {
                return res.status(403).json({ message: 'You are banned from this community and cannot create posts' });
            }
            
            // Get community settings
            const { getEnhancedCommunitySettings } = require('./moderation');
            const settings = await getEnhancedCommunitySettings(communityId);
            
            // Create the post
            const id = uuidv4();
            const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            await conn.query(
                "INSERT INTO posts (id, title, content, user_id, community_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                [id, title, content, userId, communityId, now, now]
            );
            
            // If post approval is required, add to moderation queue
            let requiresApproval = false;
            if (settings && settings.require_post_approval) {
                const { addPostToModQueue } = require('./moderation');
                await addPostToModQueue(id);
                requiresApproval = true;
            }
            
            // Commit the transaction
            await conn.commit();
            
            // Get the created post with user information
            const [newPost] = await conn.query(`
                SELECT p.*, u.username
                FROM posts p
                LEFT JOIN users u ON p.user_id = u.id
                WHERE p.id = ?
            `, [id]);
            
            // Format the post for the frontend
            const formattedPost = {
                id: newPost.id,
                title: newPost.title,
                content: newPost.content,
                username: newPost.username || 'Anonymous',
                userId: newPost.user_id,
                communityId: newPost.community_id,
                timestamp: newPost.created_at,
                comments: 0,
                votes: 0,
                pending_approval: requiresApproval
            };
            
            res.status(201).json(formattedPost);
        } catch (error) {
            // Rollback the transaction if anything goes wrong
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error("Error creating post:", error);
        res.status(500).json({ message: 'Error creating post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced get posts with moderation support
const getPostsEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get community filter if provided
        const communityId = req.query.communityId;
        const userId = req.user ? req.user.id : null;
        
        // Get community settings if community filter is provided
        let requiresApproval = false;
        let isModerator = false;
        
        if (communityId && userId) {
            const { getEnhancedCommunitySettings, isUserModerator } = require('./moderation');
            const settings = await getEnhancedCommunitySettings(communityId);
            requiresApproval = settings && settings.require_post_approval;
            isModerator = await isUserModerator(communityId, userId);
        }
        
        // Build the query based on whether a community filter is provided
        let query = `
            SELECT p.*, u.username, 
                   (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                   COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
            FROM posts p
            LEFT JOIN users u ON p.user_id = u.id
        `;
        
        if (communityId) {
            query += " WHERE p.community_id = ?";
            
            // If community requires post approval and user is not a moderator, only show approved posts
            if (requiresApproval && !isModerator) {
                query = `
                    SELECT p.*, u.username, 
                           (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                           COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
                    FROM posts p
                    LEFT JOIN users u ON p.user_id = u.id
                    LEFT JOIN post_moderation pm ON p.id = pm.post_id
                    WHERE p.community_id = ? AND (pm.status = 'approved' OR pm.status IS NULL OR p.user_id = ?)
                `;
            }
        }
        
        query += " ORDER BY p.created_at DESC";
        
        // Execute the query with appropriate parameters
        let posts;
        if (communityId) {
            if (requiresApproval && !isModerator && userId) {
                posts = await conn.query(query, [communityId, userId]);
            } else {
                posts = await conn.query(query, [communityId]);
            }
        } else {
            posts = await conn.query(query);
        }
        
        // Get moderation status for posts if needed
        let formattedPosts = await Promise.all(posts.map(async (post) => {
            let pending_approval = false;
            
            if (requiresApproval) {
                const { getPostModerationStatus } = require('./moderation');
                const modStatus = await getPostModerationStatus(post.id);
                pending_approval = modStatus && modStatus.status === 'pending';
            }
            
            return {
                id: post.id,
                title: post.title,
                content: post.content,
                username: post.username || 'Anonymous',
                userId: post.user_id,
                communityId: post.community_id,
                timestamp: post.created_at,
                comments: post.comments || 0,
                votes: post.votes || 0,
                pending_approval: pending_approval
            };
        }));
        
        res.status(200).json(formattedPosts);
    } catch (error) {
        console.error("Error fetching posts:", error);
        res.status(500).json({ message: 'Error fetching posts' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced get single post with moderation support
const getPostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const postId = req.params.id;
        const userId = req.user ? req.user.id : null;
        
        // Get the post with additional info
        const [post] = await conn.query(`
            SELECT p.*, u.username, 
                   (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                   COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
            FROM posts p
            LEFT JOIN users u ON p.user_id = u.id
            WHERE p.id = ?
        `, [postId]);
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check moderation status
        let pending_approval = false;
        let rejected = false;
        let rejection_reason = null;
        
        if (userId) {
            const { getEnhancedCommunitySettings, getPostModerationStatus, isUserModerator } = require('./moderation');
            const settings = await getEnhancedCommunitySettings(post.community_id);
            
            if (settings && settings.require_post_approval) {
                const modStatus = await getPostModerationStatus(postId);
                
                // If post is pending approval
                if (modStatus && modStatus.status === 'pending') {
                    const isModerator = await isUserModerator(post.community_id, userId);
                    
                    // If user is not the author or a moderator, hide the post
                    if (post.user_id !== userId && !isModerator) {
                        return res.status(403).json({ message: 'Post is pending moderator approval' });
                    }
                    
                    pending_approval = true;
                }
                
                // If post was rejected
                if (modStatus && modStatus.status === 'rejected') {
                    const isModerator = await isUserModerator(post.community_id, userId);
                    
                    // If user is not the author or a moderator, hide the post
                    if (post.user_id !== userId && !isModerator) {
                        return res.status(403).json({ message: 'Post has been removed by moderators' });
                    }
                    
                    rejected = true;
                    rejection_reason = modStatus.reason;
                }
            }
        }
        
        // Format the post for the frontend
        const formattedPost = {
            id: post.id,
            title: post.title,
            content: post.content,
            username: post.username || 'Anonymous',
            userId: post.user_id,
            communityId: post.community_id,
            timestamp: post.created_at,
            comments: post.comments || 0,
            votes: post.votes || 0,
            pending_approval,
            rejected,
            rejection_reason
        };
        
        res.status(200).json(formattedPost);
    } catch (error) {
        console.error("Error fetching post:", error);
        res.status(500).json({ message: 'Error fetching post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced update post with moderation support
const updatePostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const { title, content } = req.body;
        const postId = req.params.id;
        const userId = req.user.id;
        
        // Check if post exists
        const [post] = await conn.query(
            "SELECT * FROM posts WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check if user is the author or a moderator
        let isModeratorAction = false;
        
        if (post.user_id !== userId) {
            // Check moderator permissions
            const { isUserModerator, hasModeratorPermission } = require('./moderation');
            const isModerator = await isUserModerator(post.community_id, userId);
            const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
            
            if (!isModerator || !canManagePosts) {
                return res.status(403).json({ message: 'You do not have permission to update this post' });
            }
            
            isModeratorAction = true;
        }
        
        // Update the post
        const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
        
        await conn.query(
            "UPDATE posts SET title = ?, content = ?, updated_at = ? WHERE id = ?",
            [title, content, now, postId]
        );
        
        // If it's a moderator action, log it
        if (isModeratorAction) {
            const { createModerationLog } = require('./moderation');
            await createModerationLog(
                post.community_id,
                userId,
                'edit_post',
                postId,
                'post',
                'Post edited by moderator'
            );
        }
        
        // Get the updated post with user information
        const [updatedPost] = await conn.query(`
            SELECT p.*, u.username, 
                   (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                   COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
            FROM posts p
            LEFT JOIN users u ON p.user_id = u.id
            WHERE p.id = ?
        `, [postId]);
        
        // Check moderation status
        const { getPostModerationStatus } = require('./moderation');
        const modStatus = await getPostModerationStatus(postId);
        
        // Format the post for the frontend
        const formattedPost = {
            id: updatedPost.id,
            title: updatedPost.title,
            content: updatedPost.content,
            username: updatedPost.username || 'Anonymous',
            userId: updatedPost.user_id,
            communityId: updatedPost.community_id,
            timestamp: updatedPost.created_at,
            comments: updatedPost.comments || 0,
            votes: updatedPost.votes || 0,
            pending_approval: modStatus && modStatus.status === 'pending',
            rejected: modStatus && modStatus.status === 'rejected',
            rejection_reason: modStatus && modStatus.status === 'rejected' ? modStatus.reason : null
        };
        
        res.status(200).json(formattedPost);
    } catch (error) {
        console.error("Error updating post:", error);
        res.status(500).json({ message: 'Error updating post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced delete post with moderation support
const deletePostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const postId = req.params.id;
        const userId = req.user.id;
        
        // Check if post exists
        const [post] = await conn.query(
            "SELECT * FROM posts WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check if user is the author or a moderator
        let isModeratorAction = false;
        
        if (post.user_id !== userId) {
            // Check moderator permissions
            const { isUserModerator, hasModeratorPermission } = require('./moderation');
            const isModerator = await isUserModerator(post.community_id, userId);
            const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
            
            if (!isModerator || !canManagePosts) {
                return res.status(403).json({ message: 'You do not have permission to delete this post' });
            }
            
            isModeratorAction = true;
        }
        
        // Start a transaction
        await conn.beginTransaction();
        
        try {
            // Delete comments associated with the post
            await conn.query(
                "DELETE FROM comments WHERE post_id = ?",
                [postId]
            );
            
            // Delete votes associated with the post
            await conn.query(
                "DELETE FROM votes WHERE post_id = ?",
                [postId]
            );
            
            // Delete from moderation queue if present
            await conn.query(
                "DELETE FROM post_moderation WHERE post_id = ?",
                [postId]
            );
            
            // Delete the post
            await conn.query(
                "DELETE FROM posts WHERE id = ?",
                [postId]
            );
            
            // If it's a moderator action, log it
            if (isModeratorAction) {
                const { createModerationLog } = require('./moderation');
                await createModerationLog(
                    post.community_id,
                    userId,
                    'remove_post',
                    postId,
                    'post',
                    'Post removed by moderator'
                );
            }
            
            // Commit the transaction
            await conn.commit();
            
            res.status(204).send();
        } catch (error) {
            // Rollback the transaction if anything goes wrong
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error("Error deleting post:", error);
        res.status(500).json({ message: 'Error deleting post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced moderator specific functions
const getPendingPosts = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        const communityId = req.params.communityId;
        const userId = req.user.id;
        
        // Check if user is a moderator with post management permissions
        const { isUserModerator, hasModeratorPermission } = require('./moderation');
        const isModerator = await isUserModerator(communityId, userId);
        const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
        
        if (!isModerator || !canManagePosts) {
            return res.status(403).json({ message: 'You do not have permission to view pending posts' });
        }
        
        // Get pending posts for the community
        const pendingPosts = await conn.query(`
            SELECT p.*, u.username, pm.created_at as queued_at
            FROM posts p
            JOIN post_moderation pm ON p.id = pm.post_id
            JOIN users u ON p.user_id = u.id
            WHERE p.community_id = ? AND pm.status = 'pending'
            ORDER BY pm.created_at ASC
        `, [communityId]);
        
        // Format the posts for the frontend
        const formattedPosts = pendingPosts.map(post => ({
            id: post.id,
            title: post.title,
            content: post.content,
            username: post.username || 'Anonymous',
            userId: post.user_id,
            communityId: post.community_id,
            timestamp: post.created_at,
            queuedAt: post.queued_at
        }));
        
        res.status(200).json(formattedPosts);
    } catch (error) {
        console.error("Error fetching pending posts:", error);
        res.status(500).json({ message: 'Error fetching pending posts' });
    } finally {
        if (conn) conn.release();
    }
};

const moderatePostAction = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const postId = req.params.postId;
        const { action, reason } = req.body;
        const userId = req.user.id;
        
        if (action !== 'approve' && action !== 'reject') {
            return res.status(400).json({ message: 'Invalid action. Must be "approve" or "reject"' });
        }
        
        // Get the post to check permissions
        const [post] = await conn.query(
            "SELECT * FROM posts WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check if user is a moderator with post management permissions
        const { isUserModerator, hasModeratorPermission, moderatePost } = require('./moderation');
        const isModerator = await isUserModerator(post.community_id, userId);
        const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
        
        if (!isModerator || !canManagePosts) {
            return res.status(403).json({ message: 'You do not have permission to moderate posts' });
        }
        
        // Perform the moderation action
        await moderatePost(postId, userId, action, reason);
        
        res.status(200).json({ 
            message: `Post ${action === 'approve' ? 'approved' : 'rejected'} successfully`,
            postId
        });
    } catch (error) {
        console.error("Error moderating post:", error);
        res.status(500).json({ message: 'Error moderating post' });
    } finally {
        if (conn) conn.release();
    }
};

module.exports = {
    getCommunityIdFromPost,
    createPostEnhanced,
    getPostsEnhanced,
    getPostEnhanced,
    updatePostEnhanced,
    deletePostEnhanced,
    getPendingPosts,
    moderatePostAction
};

================
File: api/posts.js
================
// JavaScript version of posts.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all posts with user information
const getPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get community filter if provided
    const communityId = req.query.communityId;
    
    // Build the query based on whether a community filter is provided
    let query = `
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
    `;
    
    const queryParams = [];
    
    if (communityId) {
      query += " WHERE p.community_id = ?";
      queryParams.push(communityId);
    }
    
    query += " ORDER BY p.created_at DESC";
    
    const posts = await conn.query(query, queryParams);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching posts:", error);
    res.status(500).json({ message: 'Error fetching posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get a single post with user information
const getPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [post] = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.id = ?
    `, [req.params.id]);
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    // Format the post for the frontend
    const formattedPost = {
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    };
    
    res.status(200).json(formattedPost);
  } catch (error) {
    console.error("Error fetching post:", error);
    res.status(500).json({ message: 'Error fetching post' });
  } finally {
    if (conn) conn.release();
  }
};

// Create a new post
const createPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content, communityId } = req.body;
    const userId = req.user.id;
    
    // Validate required fields
    if (!title || !content || !communityId) {
      return res.status(400).json({ message: 'Title, content, and communityId are required' });
    }
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Create the post
      const id = uuidv4();
      
      await conn.query(
        "INSERT INTO post (id, title, content, user_id, community_id) VALUES (?, ?, ?, ?, ?)",
        [id, title, content, userId, communityId]
      );
      
      // Get the created post with user information
      const [newPost] = await conn.query(`
        SELECT p.*, u.username
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: newPost.id,
        title: newPost.title,
        content: newPost.content,
        username: newPost.username || 'Anonymous',
        userId: newPost.user_id,
        communityId: newPost.community_id,
        timestamp: newPost.created_at,
        comments: 0,
        votes: 0
      };
      
      res.status(201).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating post:", error);
    res.status(500).json({ message: 'Error creating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Update a post
const updatePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content } = req.body;
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      return res.status(403).json({ message: 'You can only update your own posts' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Update the post
      await conn.query(
        "UPDATE post SET title = ?, content = ? WHERE id = ?",
        [title, content, postId]
      );
      
      // Get the updated post with user information
      const [updatedPost] = await conn.query(`
        SELECT p.*, u.username, 
               (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
               COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [postId]);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: title,
            community_id: post.community_id
          })
        ]
      );
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: updatedPost.id,
        title: updatedPost.title,
        content: updatedPost.content,
        username: updatedPost.username || 'Anonymous',
        userId: updatedPost.user_id,
        communityId: updatedPost.community_id,
        timestamp: updatedPost.created_at,
        comments: updatedPost.comments || 0,
        votes: updatedPost.votes || 0
      };
      
      res.status(200).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating post:", error);
    res.status(500).json({ message: 'Error updating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Delete a post
const deletePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      // Check if user is a moderator of the community
      const [moderator] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
        [post.community_id, userId]
      );
      
      if (!moderator) {
        return res.status(403).json({ message: 'You can only delete your own posts or posts in communities you moderate' });
      }
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Log activity before deleting the post
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: post.title,
            community_id: post.community_id
          })
        ]
      );
      
      // Delete votes associated with the post
      await conn.query(
        "DELETE FROM vote WHERE post_id = ?",
        [postId]
      );
      
      // Delete comments associated with the post
      await conn.query(
        "DELETE FROM comment WHERE post_id = ?",
        [postId]
      );
      
      // Delete the post
      await conn.query(
        "DELETE FROM post WHERE id = ?",
        [postId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      res.status(204).send();
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting post:", error);
    res.status(500).json({ message: 'Error deleting post' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific community
const getCommunityPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const communityId = req.params.communityId;
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Get posts for the community
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.community_id = ?
      ORDER BY p.created_at DESC
    `, [communityId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching community posts:", error);
    res.status(500).json({ message: 'Error fetching community posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific user
const getUserPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const userId = req.params.userId;
    
    // Check if user exists
    const [user] = await conn.query(
      "SELECT * FROM user WHERE id = ?",
      [userId]
    );
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Get posts for the user
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `, [userId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching user posts:", error);
    res.status(500).json({ message: 'Error fetching user posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Check if user can post in a community
const canPostInCommunity = async (req, res, next) => {
  const communityId = req.body.communityId;
  const userId = req.user.id;
  
  if (!communityId) {
    return next(); // No community specified, allow the post
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // If community is public, check if user is banned
    const [banned] = await conn.query(
      "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
      [communityId, userId]
    );
    
    if (banned) {
      return res.status(403).json({ message: 'You are banned from this community' });
    }
    
    // Check community settings for post approval
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (settings && settings.require_post_approval) {
      // Set a flag to indicate that this post needs approval
      req.needsApproval = true;
    }
    
    // If community is private, check if user is a member
    if (community.privacy === 'private') {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership) {
        return res.status(403).json({ message: 'You must be a member to post in this community' });
      }
    }
    
    next();
  } catch (error) {
    console.error("Error checking post permission:", error);
    return res.status(500).json({ message: 'Error checking post permission' });
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPosts,
  getPost,
  createPost,
  updatePost,
  deletePost,
  getCommunityPosts,
  getUserPosts,
  canPostInCommunity
};

================
File: api/posts.js.new
================
// JavaScript version of posts.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all posts with user information
const getPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get community filter if provided
    const communityId = req.query.communityId;
    
    // Build the query based on whether a community filter is provided
    let query = `
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
    `;
    
    const queryParams = [];
    
    if (communityId) {
      query += " WHERE p.community_id = ?";
      queryParams.push(communityId);
    }
    
    query += " ORDER BY p.created_at DESC";
    
    const posts = await conn.query(query, queryParams);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching posts:", error);
    res.status(500).json({ message: 'Error fetching posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get a single post with user information
const getPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [post] = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.id = ?
    `, [req.params.id]);
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    // Format the post for the frontend
    const formattedPost = {
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    };
    
    res.status(200).json(formattedPost);
  } catch (error) {
    console.error("Error fetching post:", error);
    res.status(500).json({ message: 'Error fetching post' });
  } finally {
    if (conn) conn.release();
  }
};

// Create a new post
const createPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content, communityId } = req.body;
    const userId = req.user.id;
    
    // Validate required fields
    if (!title || !content || !communityId) {
      return res.status(400).json({ message: 'Title, content, and communityId are required' });
    }
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Create the post
      const id = uuidv4();
      
      await conn.query(
        "INSERT INTO post (id, title, content, user_id, community_id) VALUES (?, ?, ?, ?, ?)",
        [id, title, content, userId, communityId]
      );
      
      // Get the created post with user information
      const [newPost] = await conn.query(`
        SELECT p.*, u.username
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: newPost.id,
        title: newPost.title,
        content: newPost.content,
        username: newPost.username || 'Anonymous',
        userId: newPost.user_id,
        communityId: newPost.community_id,
        timestamp: newPost.created_at,
        comments: 0,
        votes: 0
      };
      
      res.status(201).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating post:", error);
    res.status(500).json({ message: 'Error creating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Update a post
const updatePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content } = req.body;
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      return res.status(403).json({ message: 'You can only update your own posts' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Update the post
      await conn.query(
        "UPDATE post SET title = ?, content = ? WHERE id = ?",
        [title, content, postId]
      );
      
      // Get the updated post with user information
      const [updatedPost] = await conn.query(`
        SELECT p.*, u.username, 
               (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
               COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [postId]);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: title,
            community_id: post.community_id
          })
        ]
      );
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: updatedPost.id,
        title: updatedPost.title,
        content: updatedPost.content,
        username: updatedPost.username || 'Anonymous',
        userId: updatedPost.user_id,
        communityId: updatedPost.community_id,
        timestamp: updatedPost.created_at,
        comments: updatedPost.comments || 0,
        votes: updatedPost.votes || 0
      };
      
      res.status(200).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating post:", error);
    res.status(500).json({ message: 'Error updating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Delete a post
const deletePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      // Check if user is a moderator of the community
      const [moderator] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
        [post.community_id, userId]
      );
      
      if (!moderator) {
        return res.status(403).json({ message: 'You can only delete your own posts or posts in communities you moderate' });
      }
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Log activity before deleting the post
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: post.title,
            community_id: post.community_id
          })
        ]
      );
      
      // Delete votes associated with the post
      await conn.query(
        "DELETE FROM vote WHERE post_id = ?",
        [postId]
      );
      
      // Delete comments associated with the post
      await conn.query(
        "DELETE FROM comment WHERE post_id = ?",
        [postId]
      );
      
      // Delete the post
      await conn.query(
        "DELETE FROM post WHERE id = ?",
        [postId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      res.status(204).send();
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting post:", error);
    res.status(500).json({ message: 'Error deleting post' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific community
const getCommunityPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const communityId = req.params.communityId;
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Get posts for the community
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.community_id = ?
      ORDER BY p.created_at DESC
    `, [communityId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching community posts:", error);
    res.status(500).json({ message: 'Error fetching community posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific user
const getUserPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const userId = req.params.userId;
    
    // Check if user exists
    const [user] = await conn.query(
      "SELECT * FROM user WHERE id = ?",
      [userId]
    );
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Get posts for the user
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `, [userId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching user posts:", error);
    res.status(500).json({ message: 'Error fetching user posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Check if user can post in a community
const canPostInCommunity = async (req, res, next) => {
  const communityId = req.body.communityId;
  const userId = req.user.id;
  
  if (!communityId) {
    return next(); // No community specified, allow the post
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // If community is public, check if user is banned
    const [banned] = await conn.query(
      "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
      [communityId, userId]
    );
    
    if (banned) {
      return res.status(403).json({ message: 'You are banned from this community' });
    }
    
    // Check community settings for post approval
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (settings && settings.require_post_approval) {
      // Set a flag to indicate that this post needs approval
      req.needsApproval = true;
    }
    
    // If community is private, check if user is a member
    if (community.privacy === 'private') {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership) {
        return res.status(403).json({ message: 'You must be a member to post in this community' });
      }
    }
    
    next();
  } catch (error) {
    console.error("Error checking post permission:", error);
    return res.status(500).json({ message: 'Error checking post permission' });
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPosts,
  getPost,
  createPost,
  updatePost,
  deletePost,
  getCommunityPosts,
  getUserPosts,
  canPostInCommunity
};

================
File: api/posts.ts
================
import { Request, Response } from 'express';

let mockPosts = [
  {
    id: '1',
    title: 'First Post',
    content: 'This is the first post',
    authorId: '1',
    communityId: '1',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    id: '2',
    title: 'Second Post',
    content: 'This is the second post',
    authorId: '2',
    communityId: '1',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  }
];

export const getPosts = async (req: Request, res: Response) => {
  try {
    res.status(200).json(mockPosts);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching posts' });
  }
};

export const getPost = async (req: Request, res: Response) => {
  try {
    const post = mockPosts.find(p => p.id === req.params.id);
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    res.status(200).json(post);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching post' });
  }
};

export const createPost = async (req: Request, res: Response) => {
  try {
    const newPost = {
      id: String(mockPosts.length + 1),
      ...req.body,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    mockPosts.push(newPost);
    res.status(201).json(newPost);
  } catch (error) {
    res.status(500).json({ message: 'Error creating post' });
  }
};

export const updatePost = async (req: Request, res: Response) => {
  try {
    const postIndex = mockPosts.findIndex(p => p.id === req.params.id);
    if (postIndex === -1) {
      return res.status(404).json({ message: 'Post not found' });
    }

    const updatedPost = {
      ...mockPosts[postIndex],
      ...req.body,
      updatedAt: new Date().toISOString()
    };

    mockPosts[postIndex] = updatedPost;
    res.status(200).json(updatedPost);
  } catch (error) {
    res.status(500).json({ message: 'Error updating post' });
  }
};

export const deletePost = async (req: Request, res: Response) => {
  try {
    const postIndex = mockPosts.findIndex(p => p.id === req.params.id);
    if (postIndex === -1) {
      return res.status(404).json({ message: 'Post not found' });
    }

    mockPosts.splice(postIndex, 1);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ message: 'Error deleting post' });
  }
};

================
File: api/routes/communities.js
================
// Import the fixed version of addCommunityMember
const communitiesAPI = require('../communities');
const communitiesAPIOriginal = require('../communities.ts');

// Route handler for adding a member to a community
exports.addMember = async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Use our fixed version that handles the table name issue
    const member = await communitiesAPI.addCommunityMember(communityId, userId);
    res.status(200).json(member);
  } catch (error) {
    console.error('Error in addMember:', error);
    res.status(500).json({ error: 'Failed to add community member' });
  }
};

// Export all the other handlers from the original API
// This ensures we're only overriding the specific function that has issues
Object.keys(communitiesAPIOriginal).forEach(key => {
  if (key !== 'addCommunityMember' && !exports[key]) {
    exports[key] = communitiesAPIOriginal[key];
  }
});

================
File: api/routes/community-members.js
================
// API route handler for community members
// This adds an endpoint to check current user membership

const express = require('express');
const router = express.Router();
const { getCommunityMember } = require('../communities.ts');
const { addCommunityMember } = require('../communities.js');
const auth = require('../../middleware/auth');

// Route to check if the current user is a member of a community
router.get('/:communityId/members/current', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Check if the user is a member
    const member = await getCommunityMember(communityId, userId);
    
    if (member) {
      return res.status(200).json({ 
        is_member: true,
        role: member.role,
        member_since: member.joined_at
      });
    } else {
      return res.status(200).json({ is_member: false });
    }
  } catch (error) {
    console.error('Error checking member status:', error);
    res.status(500).json({ error: 'Failed to check membership status' });
  }
});

// Route to add a member to a community
router.post('/:communityId/members', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Use our fixed version that handles the table name issue
    const member = await addCommunityMember(communityId, userId);
    res.status(200).json(member);
  } catch (error) {
    console.error('Error in addMember:', error);
    res.status(500).json({ error: 'Failed to add community member' });
  }
});

module.exports = router;

================
File: api/users.ts
================
// src/api/users.ts

export async function getUserPosts(userId: string) {
  // Get posts for a specific user.
}

================
File: api/votes.js
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Vote on a post
async function voteOnPost(userId, postId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the post exists
      const [post] = await conn.query('SELECT * FROM post WHERE id = ?', [postId]);
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if the user has already voted on this post
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND post_id = ?',
        [userId, postId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND post_id = ?',
            [userId, postId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND post_id = ?',
          [value, userId, postId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, post_id, value) VALUES (?, ?, ?)',
          [userId, postId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Vote on a comment
async function voteOnComment(userId, commentId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the comment exists
      const [comment] = await conn.query('SELECT * FROM comment WHERE id = ?', [commentId]);
      if (!comment) {
        throw new Error('Comment not found');
      }
      
      // Check if the user has already voted on this comment
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND comment_id = ?',
        [userId, commentId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND comment_id = ?',
            [userId, commentId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND comment_id = ?',
          [value, userId, commentId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, comment_id, value) VALUES (?, ?, ?)',
          [userId, commentId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a post
async function getUserPostVote(userId, postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a comment
async function getUserCommentVote(userId, commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a post
async function getPostVoteCounts(postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a comment
async function getCommentVoteCounts(commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get all votes for a user
async function getUserVotes(userId) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get post votes
    const postVotes = await conn.query(
      `SELECT v.*, p.title as post_title, p.community_id
       FROM vote v
       JOIN post p ON v.post_id = p.id
       WHERE v.user_id = ? AND v.post_id IS NOT NULL`,
      [userId]
    );
    
    // Get comment votes
    const commentVotes = await conn.query(
      `SELECT v.*, c.content as comment_content, p.id as post_id, p.title as post_title, p.community_id
       FROM vote v
       JOIN comment c ON v.comment_id = c.id
       JOIN post p ON c.post_id = p.id
       WHERE v.user_id = ? AND v.comment_id IS NOT NULL`,
      [userId]
    );
    
    return {
      postVotes,
      commentVotes
    };
  } catch (error) {
    console.error('Error getting user votes:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Helper function to update SQL queries to include votes
function includePostVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes`;
}

function includeCommentVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.comment_id = c.id), 0) as votes`;
}

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

// Helper function to log vote activity
async function logVoteActivity(conn, userId, activityTypeId, actionId, entityId, entityType, voteValue) {
  await conn.query(
    `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      uuidv4(),
      userId,
      activityTypeId,
      actionId,
      entityId,
      entityType,
      JSON.stringify({ value: voteValue })
    ]
  );
}

module.exports = {
  voteOnPost,
  voteOnComment,
  getUserPostVote,
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes,
  includePostVotesInQuery,
  includeCommentVotesInQuery
};

================
File: api/votes.js.new
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Vote on a post
async function voteOnPost(userId, postId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the post exists
      const [post] = await conn.query('SELECT * FROM post WHERE id = ?', [postId]);
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if the user has already voted on this post
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND post_id = ?',
        [userId, postId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND post_id = ?',
            [userId, postId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND post_id = ?',
          [value, userId, postId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, post_id, value) VALUES (?, ?, ?)',
          [userId, postId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Vote on a comment
async function voteOnComment(userId, commentId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the comment exists
      const [comment] = await conn.query('SELECT * FROM comment WHERE id = ?', [commentId]);
      if (!comment) {
        throw new Error('Comment not found');
      }
      
      // Check if the user has already voted on this comment
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND comment_id = ?',
        [userId, commentId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND comment_id = ?',
            [userId, commentId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND comment_id = ?',
          [value, userId, commentId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, comment_id, value) VALUES (?, ?, ?)',
          [userId, commentId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a post
async function getUserPostVote(userId, postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a comment
async function getUserCommentVote(userId, commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a post
async function getPostVoteCounts(postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a comment
async function getCommentVoteCounts(commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get all votes for a user
async function getUserVotes(userId) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get post votes
    const postVotes = await conn.query(
      `SELECT v.*, p.title as post_title, p.community_id
       FROM vote v
       JOIN post p ON v.post_id = p.id
       WHERE v.user_id = ? AND v.post_id IS NOT NULL`,
      [userId]
    );
    
    // Get comment votes
    const commentVotes = await conn.query(
      `SELECT v.*, c.content as comment_content, p.id as post_id, p.title as post_title, p.community_id
       FROM vote v
       JOIN comment c ON v.comment_id = c.id
       JOIN post p ON c.post_id = p.id
       WHERE v.user_id = ? AND v.comment_id IS NOT NULL`,
      [userId]
    );
    
    return {
      postVotes,
      commentVotes
    };
  } catch (error) {
    console.error('Error getting user votes:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Helper function to update SQL queries to include votes
function includePostVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes`;
}

function includeCommentVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.comment_id = c.id), 0) as votes`;
}

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

// Helper function to log vote activity
async function logVoteActivity(conn, userId, activityTypeId, actionId, entityId, entityType, voteValue) {
  await conn.query(
    `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      uuidv4(),
      userId,
      activityTypeId,
      actionId,
      entityId,
      entityType,
      JSON.stringify({ value: voteValue })
    ]
  );
}

module.exports = {
  voteOnPost,
  voteOnComment,
  getUserPostVote,
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes,
  includePostVotesInQuery,
  includeCommentVotesInQuery
};

================
File: api/votes.ts
================
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Vote on a post
export async function voteOnPost(userId: string, postId: string, value: number): Promise<any> {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if the post exists
    const [post] = await conn.query('SELECT * FROM posts WHERE id = ?', [postId]);
    if (!post) {
      throw new Error('Post not found');
    }
    
    // Check if the user is voting on their own post
    // Uncomment this if you want to prevent users from voting on their own posts
    /*
    if (post.user_id === userId) {
      throw new Error('You cannot vote on your own post');
    }
    */
    
    // Check if the user has already voted on this post
    const [existingVote] = await conn.query(
      'SELECT * FROM votes WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    if (value === 0) {
      // If value is 0, remove the vote if it exists
      if (existingVote) {
        await conn.query(
          'DELETE FROM votes WHERE user_id = ? AND post_id = ?',
          [userId, postId]
        );
        return { message: 'Vote removed' };
      }
      return { message: 'No vote to remove' };
    }
    
    if (existingVote) {
      // Update the existing vote
      await conn.query(
        'UPDATE votes SET value = ? WHERE user_id = ? AND post_id = ?',
        [value, userId, postId]
      );
      return { message: 'Vote updated' };
    } else {
      // Insert a new vote
      await conn.query(
        'INSERT INTO votes (user_id, post_id, value) VALUES (?, ?, ?)',
        [userId, postId, value]
      );
      return { message: 'Vote added' };
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Vote on a comment
export async function voteOnComment(userId: string, commentId: string, value: number): Promise<any> {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if the comment exists
    const [comment] = await conn.query('SELECT * FROM comments WHERE id = ?', [commentId]);
    if (!comment) {
      throw new Error('Comment not found');
    }
    
    // Check if the user is voting on their own comment
    // Uncomment this if you want to prevent users from voting on their own comments
    /*
    if (comment.user_id === userId) {
      throw new Error('You cannot vote on your own comment');
    }
    */
    
    // Check if the user has already voted on this comment
    const [existingVote] = await conn.query(
      'SELECT * FROM votes WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    if (value === 0) {
      // If value is 0, remove the vote if it exists
      if (existingVote) {
        await conn.query(
          'DELETE FROM votes WHERE user_id = ? AND comment_id = ?',
          [userId, commentId]
        );
        return { message: 'Vote removed' };
      }
      return { message: 'No vote to remove' };
    }
    
    if (existingVote) {
      // Update the existing vote
      await conn.query(
        'UPDATE votes SET value = ? WHERE user_id = ? AND comment_id = ?',
        [value, userId, commentId]
      );
      return { message: 'Vote updated' };
    } else {
      // Insert a new vote
      await conn.query(
        'INSERT INTO votes (user_id, comment_id, value) VALUES (?, ?, ?)',
        [userId, commentId, value]
      );
      return { message: 'Vote added' };
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get user's vote on a post
export async function getUserPostVote(userId: string, postId: string): Promise<number> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM votes WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get user's vote on a comment
export async function getUserCommentVote(userId: string, commentId: string): Promise<number> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM votes WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get vote counts for a post
export async function getPostVoteCounts(postId: string): Promise<{upvotes: number, downvotes: number, total: number}> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM votes 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get vote counts for a comment
export async function getCommentVoteCounts(commentId: string): Promise<{upvotes: number, downvotes: number, total: number}> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM votes 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Helper function to update SQL queries to include votes
export function includePostVotesInQuery(baseQuery: string): string {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes`;
}

export function includeCommentVotesInQuery(baseQuery: string): string {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM votes v WHERE v.comment_id = c.id), 0) as votes`;
}

================
File: check-community.js
================
const mysql = require('mysql2/promise');
require('dotenv').config();

async function run() {
  try {
    // Create the connection
    const connection = await mysql.createConnection({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
    });
    
    // Test for a specific community ID
    const communityId = '0b95216a-d272-47a4-ab4d-0af7417e868b'; // This is the ID that's failing
    
    // Check community details
    try {
      const [community] = await connection.query('SELECT * FROM community WHERE id = ?', [communityId]);
      console.log('Community found:', community.length > 0);
      if (community.length > 0) {
        console.log('Community details:', community[0]);
      }
    } catch (err) {
      console.error('Error accessing community:', err.message);
    }
    
    // Check community members
    try {
      const [members] = await connection.query('SELECT * FROM community_member WHERE community_id = ?', [communityId]);
      console.log('\nCommunity members found:', members.length);
      if (members.length > 0) {
        console.log('Sample member:', members[0]);
      }
    } catch (err) {
      console.error('Error accessing community members:', err.message);
    }
    
    // Check community rules
    try {
      const [rules] = await connection.query('SELECT * FROM community_rule WHERE community_id = ?', [communityId]);
      console.log('\nCommunity rules found:', rules.length);
      if (rules.length > 0) {
        console.log('Sample rule:', rules[0]);
      }
    } catch (err) {
      console.error('Error accessing community rules:', err.message);
    }
    
    // Check community settings
    try {
      const [settings] = await connection.query('SELECT * FROM community_setting WHERE community_id = ?', [communityId]);
      console.log('\nCommunity settings found:', settings.length);
      if (settings.length > 0) {
        console.log('Settings:', settings[0]);
      }
    } catch (err) {
      console.error('Error accessing community settings:', err.message);
    }
    
    // Check posts in this community
    try {
      const [posts] = await connection.query('SELECT * FROM post WHERE community_id = ? LIMIT 5', [communityId]);
      console.log('\nPosts found:', posts.length);
      if (posts.length > 0) {
        console.log('Sample post:', { 
          id: posts[0].id,
          title: posts[0].title,
          user_id: posts[0].user_id
        });
      }
    } catch (err) {
      console.error('Error accessing posts:', err.message);
    }

    await connection.end();
  } catch (err) {
    console.error('Database error:', err);
  }
}

run();

================
File: check-tables.js
================
const mysql = require('mysql2/promise');
require('dotenv').config();

async function run() {
  try {
    // Create the connection directly using the .env variables
    const connection = await mysql.createConnection({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
    });
    
    console.log(`Connected to database: ${process.env.DB_NAME} on ${process.env.DB_HOST}`);
    
    // Check tables
    const [tables] = await connection.query('SHOW TABLES');
    console.log('Tables in the database:');
    tables.forEach(row => {
      const tableName = Object.values(row)[0];
      console.log(tableName);
    });
    
    // Check example data from a community table
    try {
      // Try both singular and plural forms
      let communities;
      try {
        [communities] = await connection.query('SELECT id, name FROM community LIMIT 5');
        console.log("\nUsing singular 'community' table name");
      } catch (err) {
        [communities] = await connection.query('SELECT id, name FROM communities LIMIT 5');
        console.log("\nUsing plural 'communities' table name");
      }
      
      console.log('Sample community data:');
      communities.forEach(community => {
        console.log(`ID: ${community.id}, Name: ${community.name}`);
      });
    } catch (err) {
      console.error('Error accessing community data:', err.message);
    }

    await connection.end();
  } catch (err) {
    console.error('Database error:', err);
  }
}

run();

================
File: db/add_admin_user.js
================
// Script to add an admin user to the rumfornew2 database
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');
const bcrypt = require('bcrypt');

// Database connection configuration
const dbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  database: 'rumfornew2',
  multipleStatements: true
};

// Admin user details
const adminUser = {
  username: 'admin',
  email: 'admin@example.com',
  password: 'Oswald1986!',
  role: 'admin',
  display_name: 'Administrator'
};

// Helper function to execute a query and log the result
async function executeQuery(connection, query, params = []) {
  try {
    const [result] = await connection.execute(query, params);
    return result;
  } catch (error) {
    console.error(`Error executing query: ${query}`);
    console.error(error);
    throw error;
  }
}

// Main function to add the admin user
async function addAdminUser() {
  let connection;
  
  try {
    // Connect to the database
    connection = await mysql.createConnection(dbConfig);
    console.log('Connected to database');
    
    // Generate a UUID for the admin user
    const userId = uuidv4();
    
    // Hash the password
    const saltRounds = 10;
    const passwordHash = await bcrypt.hash(adminUser.password, saltRounds);
    
    // Check if admin user already exists
    const existingUsers = await executeQuery(
      connection,
      'SELECT * FROM user WHERE username = ? OR email = ?',
      [adminUser.username, adminUser.email]
    );
    
    if (existingUsers.length > 0) {
      console.log('Admin user already exists. Skipping creation.');
      return;
    }
    
    // Insert the admin user
    await executeQuery(
      connection,
      `INSERT INTO user (
        id, username, email, password_hash, role, display_name,
        is_verified, status, created_at, updated_at, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), NOW())`,
      [
        userId,
        adminUser.username,
        adminUser.email,
        passwordHash,
        adminUser.role,
        adminUser.display_name,
        1, // is_verified
        'active', // status
      ]
    );
    
    // Insert user statistics
    await executeQuery(
      connection,
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count,
        upvotes_received, downvotes_received, upvotes_given, downvotes_given,
        communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        userId,
        1000, // karma
        0, // posts_count
        0, // comments_count
        0, // upvotes_received
        0, // downvotes_received
        0, // upvotes_given
        0, // downvotes_given
        0, // communities_joined
      ]
    );
    
    // Insert user settings
    await executeQuery(
      connection,
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, theme,
        content_filter, allow_followers, display_online_status,
        language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        userId,
        1, // email_notifications
        1, // push_notifications
        'light', // theme
        'standard', // content_filter
        1, // allow_followers
        1, // display_online_status
        'en', // language
        'UTC', // timezone
      ]
    );
    
    console.log(`Admin user created successfully with ID: ${userId}`);
    console.log(`Username: ${adminUser.username}`);
    console.log(`Password: ${adminUser.password}`);
  } catch (error) {
    console.error('Error adding admin user:', error);
  } finally {
    // Close connection
    if (connection) await connection.end();
  }
}

// Run the function
addAdminUser();

================
File: db/apply_auth_schema.js
================
// Script to apply the auth schema changes
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const pool = require('./connection');

async function applyAuthSchema() {
  console.log('Applying auth schema changes...');
  
  try {
    // 1. Create backup of original files
    console.log('Creating backups of original files...');
    
    const filesToBackup = [
      { src: '../api/auth.js', dest: '../api/auth.js.bak' },
      { src: '../api/auth.ts', dest: '../api/auth.ts.bak' },
      { src: '../routes/auth.js', dest: '../routes/auth.js.bak' }
    ];
    
    for (const file of filesToBackup) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Backed up ${file.src} to ${file.dest}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping backup`);
      }
    }
    
    // 2. Apply database schema changes
    console.log('Applying database schema changes...');
    
    const conn = await pool.getConnection();
    
    try {
      // Start transaction
      await conn.beginTransaction();
      
      // Check if the user table already exists
      const [userTableExists] = await conn.query(
        "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'user'"
      );
      
      if (userTableExists.count === 0) {
        console.log('Creating user table...');
        
        // Rename users table to user if it exists
        const [usersTableExists] = await conn.query(
          "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'users'"
        );
        
        if (usersTableExists.count > 0) {
          await conn.query("RENAME TABLE users TO user");
          console.log('Renamed users table to user');
          
          // Add new columns to user table
          const columnsToAdd = [
            "ADD COLUMN IF NOT EXISTS first_name VARCHAR(50) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS last_name VARCHAR(50) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS display_name VARCHAR(50) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS date_of_birth DATE DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS bio TEXT DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(255) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS profile_banner_url VARCHAR(255) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS website VARCHAR(255) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS location VARCHAR(100) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS is_verified BOOLEAN DEFAULT FALSE",
            "ADD COLUMN IF NOT EXISTS status VARCHAR(50) DEFAULT 'active'",
            "ADD COLUMN IF NOT EXISTS cake_day DATETIME DEFAULT CURRENT_TIMESTAMP",
            "ADD COLUMN IF NOT EXISTS last_active DATETIME DEFAULT CURRENT_TIMESTAMP"
          ];
          
          for (const column of columnsToAdd) {
            try {
              await conn.query(`ALTER TABLE user ${column}`);
              console.log(`Added column: ${column}`);
            } catch (error) {
              console.warn(`Warning: Could not add column: ${column}`, error.message);
            }
          }
        } else {
          // Create user table from scratch
          await conn.query(`
            CREATE TABLE user (
              id VARCHAR(36) PRIMARY KEY,
              username VARCHAR(50) NOT NULL UNIQUE,
              email VARCHAR(100) NOT NULL UNIQUE,
              password_hash VARCHAR(255) NOT NULL,
              role VARCHAR(20) NOT NULL DEFAULT 'user',
              first_name VARCHAR(50) DEFAULT NULL,
              last_name VARCHAR(50) DEFAULT NULL,
              display_name VARCHAR(50) DEFAULT NULL,
              date_of_birth DATE DEFAULT NULL,
              bio TEXT DEFAULT NULL,
              avatar_url VARCHAR(255) DEFAULT NULL,
              profile_banner_url VARCHAR(255) DEFAULT NULL,
              website VARCHAR(255) DEFAULT NULL,
              location VARCHAR(100) DEFAULT NULL,
              is_verified BOOLEAN DEFAULT FALSE,
              status VARCHAR(50) DEFAULT 'active',
              cake_day DATETIME DEFAULT CURRENT_TIMESTAMP,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
              last_active DATETIME DEFAULT CURRENT_TIMESTAMP,
              INDEX idx_username (username),
              INDEX idx_email (email),
              INDEX idx_role (role)
            )
          `);
          console.log('Created user table');
        }
      } else {
        console.log('User table already exists, skipping creation');
      }
      
      // Create user_statistic table if it doesn't exist
      const [userStatisticTableExists] = await conn.query(
        "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'user_statistic'"
      );
      
      if (userStatisticTableExists.count === 0) {
        console.log('Creating user_statistic table...');
        
        await conn.query(`
          CREATE TABLE user_statistic (
            user_id VARCHAR(36) PRIMARY KEY,
            karma INT DEFAULT 0,
            posts_count INT DEFAULT 0,
            comments_count INT DEFAULT 0,
            upvotes_received INT DEFAULT 0,
            downvotes_received INT DEFAULT 0,
            upvotes_given INT DEFAULT 0,
            downvotes_given INT DEFAULT 0,
            communities_joined INT DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
          )
        `);
        console.log('Created user_statistic table');
        
        // Populate user_statistic table with existing users
        await conn.query(`
          INSERT INTO user_statistic (user_id, created_at, updated_at)
          SELECT id, created_at, updated_at FROM user
          WHERE id NOT IN (SELECT user_id FROM user_statistic)
        `);
        console.log('Populated user_statistic table with existing users');
      } else {
        console.log('User_statistic table already exists, skipping creation');
      }
      
      // Create user_setting table if it doesn't exist
      const [userSettingTableExists] = await conn.query(
        "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'user_setting'"
      );
      
      if (userSettingTableExists.count === 0) {
        console.log('Creating user_setting table...');
        
        await conn.query(`
          CREATE TABLE user_setting (
            user_id VARCHAR(36) PRIMARY KEY,
            email_notifications BOOLEAN DEFAULT TRUE,
            push_notifications BOOLEAN DEFAULT TRUE,
            theme VARCHAR(20) DEFAULT 'light',
            content_filter VARCHAR(20) DEFAULT 'standard',
            allow_followers BOOLEAN DEFAULT TRUE,
            display_online_status BOOLEAN DEFAULT TRUE,
            language VARCHAR(10) DEFAULT 'en',
            timezone VARCHAR(50) DEFAULT 'UTC',
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
          )
        `);
        console.log('Created user_setting table');
        
        // Populate user_setting table with existing users
        await conn.query(`
          INSERT INTO user_setting (user_id, updated_at)
          SELECT id, updated_at FROM user
          WHERE id NOT IN (SELECT user_id FROM user_setting)
        `);
        console.log('Populated user_setting table with existing users');
      } else {
        console.log('User_setting table already exists, skipping creation');
      }
      
      // Commit transaction
      await conn.commit();
      console.log('Database schema changes applied successfully');
      
    } catch (error) {
      // Rollback transaction on error
      await conn.rollback();
      console.error('Error applying database schema changes:', error);
      throw error;
    } finally {
      conn.release();
    }
    
    // 3. Replace the auth files with the new versions
    console.log('Replacing auth files with new versions...');
    
    const filesToReplace = [
      { src: '../api/auth.js.new', dest: '../api/auth.js' },
      { src: '../api/auth.ts.new', dest: '../api/auth.ts' },
      { src: '../routes/auth.js.new', dest: '../routes/auth.js' }
    ];
    
    for (const file of filesToReplace) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Replaced ${file.dest} with ${file.src}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping replacement`);
      }
    }
    
    console.log('Auth schema changes applied successfully!');
    
  } catch (error) {
    console.error('Error applying auth schema changes:', error);
    process.exit(1);
  }
}

// Run the function
applyAuthSchema().then(() => {
  console.log('Auth schema update completed');
  process.exit(0);
}).catch(error => {
  console.error('Auth schema update failed:', error);
  process.exit(1);
});

================
File: db/apply_comments_schema.js
================
// Apply comments schema updates to the database
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function applyCommentsSchema() {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log('Connected to the database');

    // Read the SQL file
    const sqlFilePath = path.join(__dirname, 'comments_schema_updates.sql');
    const sql = fs.readFileSync(sqlFilePath, 'utf8');

    // Split the SQL file into individual statements
    const statements = sql
      .split(';')
      .filter(statement => statement.trim() !== '');

    // Execute each statement
    for (const statement of statements) {
      try {
        await conn.query(statement);
        console.log('Executed statement:', statement.trim().substring(0, 50) + '...');
      } catch (err) {
        console.error('Error executing statement:', statement.trim());
        console.error('Error details:', err);
      }
    }

    console.log('Comments schema updates applied successfully');
  } catch (err) {
    console.error('Error applying comments schema updates:', err);
  } finally {
    if (conn) {
      conn.end();
    }
    process.exit(0);
  }
}

// Run the function
applyCommentsSchema();

================
File: db/apply_community_updates.js
================
// backend/db/apply_community_updates.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

const pool = mariadb.createPool({
    host: '192.168.0.139',
    port: 3306,
    user: 'root',
    password: 'Oswald1986!',
    database: 'rumfor1',
    connectionLimit: 15
});

async function applySchemaUpdates() {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log('Connected to database!');

        // Read the SQL file
        const sqlFilePath = path.join(__dirname, 'community_schema_updates.sql');
        const sql = fs.readFileSync(sqlFilePath, 'utf8');

        // Split the SQL file into individual statements
        const statements = sql.split(';').filter(statement => statement.trim() !== '');

        // Execute each statement
        for (const statement of statements) {
            await conn.query(statement);
        }

        console.log('Schema updates applied successfully!');
    } catch (err) {
        console.error('Error applying schema updates:', err);
    } finally {
        if (conn) {
            conn.end();
        }
    }
}

applySchemaUpdates();

================
File: db/apply_moderator_schema.js
================
// apply_moderator_schema.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
const dotenv = require('dotenv');

dotenv.config({ path: path.resolve(__dirname, '../.env') });

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 10, // Increased connection limit
    connectTimeout: 30000 // Added connection timeout (30 seconds)
});

async function applySchemaUpdates() {
    let conn;
    console.log(`Attempting to connect to database: ${process.env.DB_NAME}`); // Log the database name
    try {
        conn = await pool.getConnection();
        console.log('Connected to database. Applying moderator schema updates...');

        const schemaFilePath = path.join(__dirname, 'moderator_schema_updates.sql');
        const schemaSQL = fs.readFileSync(schemaFilePath, 'utf8');

        // Split by semicolon to execute each statement separately
        const statements = schemaSQL.split(';').filter(stmt => stmt.trim());

        for (const statement of statements) {
            if (statement.trim()) {
                await conn.query(statement);
                console.log('Executed SQL statement.');
            }
        }

        console.log('Moderator schema updates applied successfully!');
    } catch (error) {
        console.error('Error applying moderator schema updates:', error);
    } finally {
        if (conn) conn.end();
    }
}

applySchemaUpdates();

================
File: db/apply_new_schema.js
================
// Script to apply the new database schema to rumfornew2
const mysql = require('mysql2/promise');
const fs = require('fs');
const path = require('path');

// Database connection configuration
const dbConfig = {
  host: '68.146.102.33',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  multipleStatements: true // Required for executing multiple SQL statements
};

async function createDatabase() {
  // First connect to MySQL without specifying a database
  const rootConnection = await mysql.createConnection({
    host: '68.146.102.33',
    port: 3306,
    user: 'root', // Need root privileges to create database and user
    password: 'Oswald1986!' // Root password
  });

  try {
    console.log('Creating database and user...');
    
    // Drop the database if it exists
    await rootConnection.query(`DROP DATABASE IF EXISTS rumfornew2`);
    
    // Create the database
    await rootConnection.query(`CREATE DATABASE rumfornew2`);
    
    // Check if user exists and create if not
    try {
      await rootConnection.query(`
        CREATE USER 'rumfornew2'@'%' IDENTIFIED BY 'Oswald1986!';
      `);
      
      // Grant privileges
      await rootConnection.query(`GRANT ALL PRIVILEGES ON rumfornew2.* TO 'rumfornew2'@'%'`);
      await rootConnection.query(`FLUSH PRIVILEGES`);
      
      console.log('User created and privileges granted.');
    } catch (error) {
      // User might already exist
      console.log('User already exists or error creating user:', error.message);
      
      // Make sure privileges are granted
      await rootConnection.query(`GRANT ALL PRIVILEGES ON rumfornew2.* TO 'rumfornew2'@'%'`);
      await rootConnection.query(`FLUSH PRIVILEGES`);
      
      console.log('Privileges granted.');
    }
  } finally {
    await rootConnection.end();
  }
}

async function applySchema() {
  // Read the schema file
  const schemaPath = path.join(__dirname, 'simple_schema.sql');
  const schema = fs.readFileSync(schemaPath, 'utf8');
  
  // Connect to the new database
  const connection = await mysql.createConnection({
    ...dbConfig,
    database: 'rumfornew2',
    multipleStatements: true
  });
  
  try {
    console.log('Applying schema...');
    
    // Execute the entire schema as a single statement
    await connection.query(schema);
    
    console.log('Schema applied successfully!');
  } catch (error) {
    console.error('Error applying schema:', error);
    throw error;
  } finally {
    await connection.end();
  }
}

async function main() {
  try {
    await createDatabase();
    await applySchema();
    console.log('Database setup completed successfully!');
  } catch (error) {
    console.error('Error setting up database:', error);
    process.exit(1);
  }
}

main();

================
File: db/apply_user_auth_schema.js
================
// backend/db/apply_user_auth_schema.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

async function applyUserAuthSchema() {
    let conn;
    try {
        console.log('Connecting to MariaDB...');
        console.log('Connection details:', {
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            user: process.env.DB_USER,
            database: process.env.DB_NAME
        });
        
        conn = await pool.getConnection();
        console.log('Connected to MariaDB!');
        
        // Read the SQL file
        const sqlFilePath = path.join(__dirname, 'user_auth_schema.sql');
        console.log('Reading SQL file from:', sqlFilePath);
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        
        // Split the SQL file into individual statements
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
        console.log(`Found ${statements.length} SQL statements to execute`);
        
        // Execute each statement
        for (const statement of statements) {
            console.log(`Executing: ${statement}`);
            try {
                const result = await conn.query(statement);
                console.log('Statement executed successfully');
            } catch (err) {
                console.error('Error executing statement:', err.message);
                // Continue with the next statement
            }
        }
        
        // Create admin user if it doesn't exist
        const adminId = uuidv4();
        const adminUsername = 'admin';
        const adminEmail = 'admin@example.com';
        const adminPassword = 'Admin123!'; // This should be changed after first login
        
        // Check if admin user already exists
        const [existingAdmin] = await conn.query(
            "SELECT * FROM users WHERE username = ? OR email = ?",
            [adminUsername, adminEmail]
        );
        
        if (!existingAdmin) {
            console.log('Creating admin user...');
            // Hash the password
            const saltRounds = 10;
            const hashedPassword = await bcrypt.hash(adminPassword, saltRounds);
            
            // Insert admin user
            await conn.query(
                "INSERT INTO users (id, username, email, password_hash, role) VALUES (?, ?, ?, ?, ?)",
                [adminId, adminUsername, adminEmail, hashedPassword, 'admin']
            );
            
            console.log('Admin user created successfully!');
            console.log('Admin credentials:');
            console.log('Username:', adminUsername);
            console.log('Password:', adminPassword);
            console.log('Please change this password after first login!');
        } else {
            console.log('Admin user already exists, skipping creation.');
        }
        
        console.log('User authentication schema updates applied successfully!');
    } catch (err) {
        console.error('Error applying user authentication schema:', err);
    } finally {
        if (conn) {
            console.log('Closing database connection');
            conn.end();
        }
    }
}

applyUserAuthSchema();

================
File: db/apply_user_statistics_schema.js
================
const fs = require('fs');
const path = require('path');
const mysql = require('mysql2/promise');
require('dotenv').config();

async function applyUserStatisticsSchema() {
  // Read the SQL file
  const sqlFilePath = path.join(__dirname, 'user_statistics_schema.sql');
  const sql = fs.readFileSync(sqlFilePath, 'utf8');

  // Split the SQL file into individual statements
  // This is a simple approach and might not work for all SQL files
  const statements = sql
    .replace(/DELIMITER \/\//g, '') // Remove DELIMITER statements
    .replace(/END \/\//g, 'END;')   // Replace END // with END;
    .replace(/DELIMITER ;/g, '')    // Remove DELIMITER ; statements
    .split(';')
    .filter(statement => statement.trim() !== '');

  // Create a connection to the database
  const connection = await mysql.createConnection({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'rumfor',
    multipleStatements: true
  });

  try {
    console.log('Applying user statistics schema...');

    // Execute each statement
    for (const statement of statements) {
      try {
        await connection.query(statement);
        console.log('Executed statement successfully');
      } catch (err) {
        console.error('Error executing statement:', err);
        console.error('Statement:', statement);
      }
    }

    console.log('User statistics schema applied successfully');
  } catch (err) {
    console.error('Error applying user statistics schema:', err);
  } finally {
    await connection.end();
  }
}

// Run the function
applyUserStatisticsSchema().catch(console.error);

================
File: db/apply_votes_schema.js
================
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

async function applyVotesSchema() {
  require('dotenv').config({ path: path.resolve(__dirname, '../.env') });
  console.log('Connecting to database with:', {
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
  });
  let conn;
  try {
    conn = await mariadb.createConnection({
      host: process.env.DB_HOST,
      port: Number(process.env.DB_PORT),
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      multipleStatements: true
    });

    const sqlPath = path.join(__dirname, 'votes_schema_update.sql');
    const sql = fs.readFileSync(sqlPath, 'utf8');

    console.log('Applying votes schema updates...');
    const result = await conn.query(sql);
    console.log('Votes schema updated successfully!');
    return result;
  } catch (err) {
    console.error('Error updating votes schema:', err);
    throw err;
  } finally {
    if (conn) {
      conn.end();
    }
  }
}

// Run the function directly if this script is executed directly
if (require.main === module) {
  applyVotesSchema()
    .then(() => {
      console.log('Schema update completed.');
      process.exit(0);
    })
    .catch(err => {
      console.error('Failed to update schema:', err);
      process.exit(1);
    });
}

module.exports = { applyVotesSchema };

================
File: db/comments_schema_updates.sql
================
-- Add parent_comment_id column to comments table for threaded replies
ALTER TABLE comments ADD COLUMN IF NOT EXISTS parent_comment_id VARCHAR(36) DEFAULT NULL;

-- Add foreign key constraint for parent_comment_id
ALTER TABLE comments ADD CONSTRAINT IF NOT EXISTS fk_parent_comment
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id)
    ON DELETE SET NULL;

-- Add profile_post column to posts table to distinguish between community posts and profile posts
ALTER TABLE posts ADD COLUMN IF NOT EXISTS profile_post BOOLEAN DEFAULT FALSE;

-- Add user_profile_id column to posts table for posts on user profiles
ALTER TABLE posts ADD COLUMN IF NOT EXISTS user_profile_id VARCHAR(36) DEFAULT NULL;

-- Add foreign key constraint for user_profile_id
ALTER TABLE posts ADD CONSTRAINT IF NOT EXISTS fk_user_profile
    FOREIGN KEY (user_profile_id) REFERENCES users(id)
    ON DELETE CASCADE;

-- Create index for faster comment retrieval by post_id
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id);

-- Create index for faster comment retrieval by parent_comment_id
CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments(parent_comment_id);

-- Create index for faster post retrieval by user_profile_id
CREATE INDEX IF NOT EXISTS idx_posts_user_profile ON posts(user_profile_id);

================
File: db/community_schema_updates.sql
================
-- Add privacy column to communities table
ALTER TABLE communities ADD COLUMN IF NOT EXISTS privacy VARCHAR(10) DEFAULT 'public';

-- Create community_members table for tracking membership
CREATE TABLE IF NOT EXISTS community_members (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create community_rules table
CREATE TABLE IF NOT EXISTS community_rules (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

-- Create community_settings table
CREATE TABLE IF NOT EXISTS community_settings (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

-- Create join requests table for tracking pending membership requests
CREATE TABLE IF NOT EXISTS community_join_requests (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

================
File: db/connection.d.ts
================
import { Pool } from 'mysql2/promise';

/**
 * MySQL connection pool for database operations
 */
declare const pool: Pool;

export = pool;

================
File: db/connection.js
================
const mysql = require('mysql2/promise');
require('dotenv').config();

/**
 * Creates a database connection pool with error handling and retry capabilities
 * @returns {Object} MySQL connection pool
 */
function createConnectionPool() {
  // Default database configuration
  const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306', 10),
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'rumfornew2',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
  };

  // Create the pool
  const pool = mysql.createPool(dbConfig);

  // Test the connection
  pool.getConnection()
    .then(conn => {
      console.log(`Connected to MySQL database: ${dbConfig.database} on ${dbConfig.host}:${dbConfig.port}`);
      conn.release();
    })
    .catch(err => {
      console.error('Error connecting to database:', err.message);
      console.error('Please check your database connection settings in the .env file.');
      
      // Provide more detailed error messages for common issues
      if (err.code === 'ECONNREFUSED') {
        console.error('Connection refused. Make sure the database server is running and accessible.');
      } else if (err.code === 'ER_ACCESS_DENIED_ERROR') {
        console.error('Access denied. Check your database username and password.');
      } else if (err.code === 'ER_BAD_DB_ERROR') {
        console.error(`Database '${dbConfig.database}' does not exist. Run the database setup scripts first.`);
      }
    });

  return pool;
}

// Create the connection pool for the new database schema
const pool = createConnectionPool();

// Export the connection pool
module.exports = pool;

================
File: db/connection.ts
================
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';
dotenv.config();

/**
 * Creates a database connection pool with error handling and retry capabilities
 * @returns MySQL connection pool
 */
function createConnectionPool() {
  // Default database configuration
  const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306', 10),
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'rumfornew2',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
  };

  // Create the pool
  const pool = mysql.createPool(dbConfig);

  // Test the connection
  pool.getConnection()
    .then(conn => {
      console.log(`Connected to MySQL database: ${dbConfig.database} on ${dbConfig.host}:${dbConfig.port}`);
      conn.release();
    })
    .catch(err => {
      console.error('Error connecting to database:', err.message);
      console.error('Please check your database connection settings in the .env file.');
      
      // Provide more detailed error messages for common issues
      if (err.code === 'ECONNREFUSED') {
        console.error('Connection refused. Make sure the database server is running and accessible.');
      } else if (err.code === 'ER_ACCESS_DENIED_ERROR') {
        console.error('Access denied. Check your database username and password.');
      } else if (err.code === 'ER_BAD_DB_ERROR') {
        console.error(`Database '${dbConfig.database}' does not exist. Run the database setup scripts first.`);
      }
    });

  return pool;
}

// Create the connection pool
const pool = createConnectionPool();

// Export the connection pool
export default pool;

================
File: db/fetch_usernames.js
================
// Helper script to update community_members with usernames
const mariadb = require('mariadb');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function updateMembersWithUsernames() {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Get all users
    const users = await conn.query("SELECT id, username FROM users");
    
    if (users.length === 0) {
      console.log("No users found in the database");
      return;
    }
    
    console.log(`Found ${users.length} users`);
    
    // Create a map of user IDs to usernames
    const userMap = new Map();
    users.forEach(user => {
      userMap.set(user.id, user.username);
    });
    
    // Get all community members
    const members = await conn.query("SELECT * FROM community_members");
    
    if (members.length === 0) {
      console.log("No community members found in the database");
      return;
    }
    
    console.log(`Found ${members.length} community members`);
    
    // Create a test query that retrieves members with usernames
    try {
      const testQuery = `
        SELECT cm.*, u.username 
        FROM community_members cm 
        LEFT JOIN users u ON cm.user_id = u.id 
        LIMIT 10
      `;
      
      const testResult = await conn.query(testQuery);
      console.log("Test query result:", testResult);
      
      // If we got here, the query worked!
      console.log("LEFT JOIN to users table works correctly");
    } catch (error) {
      console.error("LEFT JOIN test failed:", error.message);
      console.log("User IDs in community_members might not match users table IDs");
    }
    
    // Report on moderation status
    const moderators = members.filter(m => m.role === 'moderator' || m.role === 'admin');
    console.log(`Found ${moderators.length} moderators/admins`);
    
    for (const mod of moderators) {
      const username = userMap.get(mod.user_id) || 'Unknown User';
      console.log(`Community ${mod.community_id}: Moderator ${username} (${mod.user_id}), role: ${mod.role}`);
    }
    
    console.log("Database check complete");
  } catch (error) {
    console.error("Error updating members with usernames:", error);
  } finally {
    if (conn) conn.release();
    process.exit(0);
  }
}

updateMembersWithUsernames();

================
File: db/fix_community_api.js
================
// Fix the community API issues by adding proper tables and data
const mariadb = require('mariadb');
const dotenv = require('dotenv');
const path = require('path');

// Load environment variables
dotenv.config({ path: path.resolve(__dirname, '../.env') });

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function fixCommunityApi() {
  let conn;

  try {
    conn = await pool.getConnection();

    // 1. Add privacy column to communities table if it doesn't exist
    try {
      await conn.query(`
        ALTER TABLE communities 
        ADD COLUMN IF NOT EXISTS privacy ENUM('public', 'private') DEFAULT 'public'
      `);
      console.log('Added privacy column to communities table');
    } catch (error) {
      console.log('Skipping adding privacy column - may already exist or table structure is different');
    }

    // 2. Create community_members table if it doesn't exist
    try {
      await conn.query(`
        CREATE TABLE IF NOT EXISTS community_members (
          community_id VARCHAR(36) NOT NULL,
          user_id VARCHAR(36) NOT NULL,
          role ENUM('member', 'moderator', 'admin') DEFAULT 'member',
          joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          PRIMARY KEY (community_id, user_id),
          FOREIGN KEY (community_id) REFERENCES communities(id) ON DELETE CASCADE,
          FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )
      `);
      console.log('Created or verified community_members table');
    } catch (error) {
      console.error('Error creating community_members table:', error);
    }

    // 3. Create community_rules table if it doesn't exist
    try {
      await conn.query(`
        CREATE TABLE IF NOT EXISTS community_rules (
          id VARCHAR(36) PRIMARY KEY,
          community_id VARCHAR(36) NOT NULL,
          title VARCHAR(255) NOT NULL,
          description TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
          FOREIGN KEY (community_id) REFERENCES communities(id) ON DELETE CASCADE
        )
      `);
      console.log('Created or verified community_rules table');
    } catch (error) {
      console.error('Error creating community_rules table:', error);
    }

    // 4. Create community_settings table if it doesn't exist
    try {
      await conn.query(`
        CREATE TABLE IF NOT EXISTS community_settings (
          community_id VARCHAR(36) PRIMARY KEY,
          allow_post_images BOOLEAN DEFAULT TRUE,
          allow_post_links BOOLEAN DEFAULT TRUE,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
          FOREIGN KEY (community_id) REFERENCES communities(id) ON DELETE CASCADE
        )
      `);
      console.log('Created or verified community_settings table');
    } catch (error) {
      console.error('Error creating community_settings table:', error);
    }

    // 5. Add default settings for communities that don't have them
    try {
      // Get all communities
      const communities = await conn.query('SELECT id FROM communities');
      
      // For each community, check if it has settings and add if not
      for (const community of communities) {
        const [setting] = await conn.query(
          'SELECT community_id FROM community_settings WHERE community_id = ?',
          [community.id]
        );
        
        if (!setting) {
          await conn.query(
            'INSERT INTO community_settings (community_id, allow_post_images, allow_post_links) VALUES (?, ?, ?)',
            [community.id, true, true]
          );
          console.log(`Added default settings for community ${community.id}`);
        }
      }
    } catch (error) {
      console.error('Error setting up default community settings:', error);
    }

    console.log('Database fixes complete');
  } catch (error) {
    console.error('Error fixing community API:', error);
  } finally {
    if (conn) conn.release();
  }
}

fixCommunityApi()
  .then(() => console.log('Fix script completed'))
  .catch(err => console.error('Fix script failed:', err))
  .finally(() => process.exit());

================
File: db/fix_community_join_request.js
================
// Script to fix the community_join_request table issue
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

// Get database connection info from environment or use defaults
const DB_HOST = process.env.DB_HOST || '192.168.0.139';
const DB_PORT = process.env.DB_PORT || 3306;
const DB_USER = process.env.DB_USER || 'rumfornew2';
const DB_PASSWORD = process.env.DB_PASSWORD || 'Oswald1986!';
const DB_DATABASE = process.env.DB_DATABASE || 'rumfornew2';

const pool = mariadb.createPool({
    host: DB_HOST,
    port: DB_PORT,
    user: DB_USER,
    password: DB_PASSWORD,
    database: DB_DATABASE,
    connectionLimit: 5
});

async function applyFix() {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log(`Connected to database ${DB_DATABASE}!`);

        // Check if community_join_request exists
        console.log('Checking for community_join_request table...');
        const singularTableExists = await checkTableExists(conn, 'community_join_request');
        
        // Check if community_join_requests exists
        console.log('Checking for community_join_requests table...');
        const pluralTableExists = await checkTableExists(conn, 'community_join_requests');

        if (singularTableExists && !pluralTableExists) {
            // The singular form exists but not the plural - rename it
            console.log('Renaming community_join_request to community_join_requests...');
            await conn.query('RENAME TABLE community_join_request TO community_join_requests');
            console.log('Table renamed successfully!');
        } else if (!singularTableExists && !pluralTableExists) {
            // Neither exists - create the plural form
            console.log('Creating community_join_requests table...');
            await createJoinRequestsTable(conn);
            console.log('Table created successfully!');
        } else if (pluralTableExists) {
            console.log('community_join_requests table already exists, no changes needed.');
        }

        console.log('Fix applied successfully!');
    } catch (err) {
        console.error('Error applying fix:', err);
    } finally {
        if (conn) {
            conn.end();
        }
    }
}

async function checkTableExists(conn, tableName) {
    try {
        const rows = await conn.query(`
            SELECT COUNT(*) as count
            FROM information_schema.tables
            WHERE table_schema = DATABASE()
            AND table_name = ?
        `, [tableName]);
        
        return rows[0].count > 0;
    } catch (err) {
        console.error(`Error checking if table ${tableName} exists:`, err);
        return false;
    }
}

async function createJoinRequestsTable(conn) {
    const sql = `
    CREATE TABLE community_join_requests (
        id VARCHAR(36) PRIMARY KEY,
        community_id VARCHAR(36) NOT NULL,
        user_id VARCHAR(36) NOT NULL,
        status VARCHAR(20) DEFAULT 'pending',
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        UNIQUE KEY (community_id, user_id),
        FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
    )`;
    
    await conn.query(sql);
}

// Run the fix
applyFix();

================
File: db/fix_community_join_request.sql
================
-- Create community_join_requests table (plural name) to match what the code is expecting
CREATE TABLE IF NOT EXISTS community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Rename the table if it exists but with wrong name
-- This is the key fix - it renames the table to match what the code is expecting
ALTER TABLE community_join_request RENAME TO community_join_requests;

-- Make sure the auto-renaming worked, if not, create the new table directly
CREATE TABLE IF NOT EXISTS community_join_requests (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

================
File: db/fix_community_join_table.bat
================
@echo off
echo ===================================================
echo Fixing Community Join Request Table Issue
echo ===================================================
echo.

cd %~dp0
node fix_community_join_request.js

pause

================
File: db/fix_join_request_name.js
================
// Script to fix the community_join_request table issue
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

// Database connection configuration (adjust as needed)
const pool = mariadb.createPool({
    host: process.env.DB_HOST || '192.168.0.139',
    port: Number(process.env.DB_PORT) || 3306,
    user: process.env.DB_USER || 'rumfornew2',
    password: process.env.DB_PASSWORD || 'Oswald1986!',
    database: process.env.DB_NAME || 'rumfornew2',
    connectionLimit: 5
});

async function fixJoinRequestTable() {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log('Connected to database!');

        // Check if the table exists
        const [tableExists] = await conn.query(`
            SELECT COUNT(*) as count 
            FROM information_schema.tables 
            WHERE table_schema = DATABASE() 
            AND table_name = 'community_join_request'
        `);

        if (tableExists.count === 0) {
            console.log('Table community_join_request does not exist, creating it...');
            
            // Create the table with the correct name
            await conn.query(`
                CREATE TABLE community_join_request (
                    id VARCHAR(36) PRIMARY KEY,
                    community_id VARCHAR(36) NOT NULL,
                    user_id VARCHAR(36) NOT NULL,
                    status VARCHAR(20) DEFAULT 'pending', 
                    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY (community_id, user_id),
                    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
                )
            `);
            
            console.log('Table created successfully!');
        } else {
            console.log('Table community_join_request already exists.');
        }

        console.log('Database fix completed successfully!');
    } catch (error) {
        console.error('Error fixing join request table:', error);
    } finally {
        if (conn) {
            await conn.end();
        }
    }
}

// Run the fix
fixJoinRequestTable();

================
File: db/fix_join_request.bat
================
@echo off
echo ===================================================
echo Fixing Community Join Request Table Issue
echo ===================================================
echo.

cd %~dp0
node fix_join_request_name.js

pause

================
File: db/fixed_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL, -- 'home', 'work', etc.
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User relationships
CREATE TABLE user_relationship (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    related_user_id VARCHAR(36) NOT NULL,
    relationship_type VARCHAR(20) NOT NULL, -- 'friend', 'follow', 'block'
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (related_user_id) REFERENCES user(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, related_user_id, relationship_type)
);

-- User achievements
CREATE TABLE user_achievement (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community join requests
CREATE TABLE community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User flair for communities
CREATE TABLE user_flair (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    text VARCHAR(50) NOT NULL,
    background_color VARCHAR(20) DEFAULT '#e0e0e0',
    text_color VARCHAR(20) DEFAULT '#000000',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, community_id)
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Vote table with support for both post and comment votes
CREATE TABLE vote (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, IFNULL(post_id, ''), IFNULL(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE,
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Saved items
CREATE TABLE saved_item (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    item_id VARCHAR(36) NOT NULL,
    item_type VARCHAR(20) NOT NULL, -- 'post', 'comment'
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    collection_name VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post moderation
CREATE TABLE post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE SET NULL
);

-- Banned users
CREATE TABLE banned_user (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (banned_by) REFERENCES user(id) ON DELETE CASCADE
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, community, etc.)
    entity_type VARCHAR(50), -- Type of the related entity (post, comment, community, etc.)
    metadata JSON, -- Additional data related to the activity
    ip_address VARCHAR(45), -- IPv4 or IPv6 address
    user_agent TEXT, -- Browser/client information
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Moderation logs
CREATE TABLE moderation_log (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Create indexes for faster queries
CREATE INDEX idx_post_user_id ON post(user_id);
CREATE INDEX idx_post_community_id ON post(community_id);
CREATE INDEX idx_comment_post_id ON comment(post_id);
CREATE INDEX idx_comment_user_id ON comment(user_id);
CREATE INDEX idx_comment_parent_id ON comment(parent_comment_id);
CREATE INDEX idx_vote_post_id ON vote(post_id);
CREATE INDEX idx_vote_comment_id ON vote(comment_id);
CREATE INDEX idx_activity_user_id ON activity(user_id);
CREATE INDEX idx_activity_type_id ON activity(activity_type_id);
CREATE INDEX idx_activity_action_id ON activity(action_id);
CREATE INDEX idx_activity_entity ON activity(entity_id, entity_type);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

================
File: db/generate_sample_data.js
================
// Script to generate sample data for the new database
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');

// Database connection configuration
const dbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  database: 'rumfornew2',
  multipleStatements: true
};

// Helper function to execute a query and log the result
async function executeQuery(connection, query, params = []) {
  try {
    const [result] = await connection.execute(query, params);
    return result;
  } catch (error) {
    console.error(`Error executing query: ${query}`);
    console.error(error);
    throw error;
  }
}

// Generate sample users
async function generateUsers(connection, count = 10) {
  console.log(`Generating ${count} sample users...`);
  
  const users = [];
  
  for (let i = 0; i < count; i++) {
    const userId = uuidv4();
    const username = `user${i + 1}`;
    const email = `user${i + 1}@example.com`;
    
    // Insert user
    await executeQuery(
      connection,
      `INSERT INTO user (
        id, username, email, password_hash, role, bio, avatar_url,
        profile_banner_url, website, location, is_verified, status,
        cake_day, created_at, updated_at, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), NOW())`,
      [
        userId,
        username,
        email,
        '$2a$10$XQxBtEwPP1SXkQfdXMYgJeP4tELOWJKVJKxXpWlmJBcMjwFrVyeJC', // hashed 'password123'
        i === 0 ? 'admin' : 'user',
        `Bio for ${username}`,
        `https://example.com/avatars/${username}.jpg`,
        `https://example.com/banners/${username}.jpg`,
        `https://example.com/${username}`,
        `City ${i + 1}`,
        i < 3 ? 1 : 0, // First 3 users are verified
        'active',
        new Date(2020, 0, i + 1) // Different cake days
      ]
    );
    
    // Insert user statistics
    await executeQuery(
      connection,
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count,
        upvotes_received, downvotes_received, upvotes_given, downvotes_given,
        communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        userId,
        Math.floor(Math.random() * 1000), // Random karma
        Math.floor(Math.random() * 20), // Random posts count
        Math.floor(Math.random() * 50), // Random comments count
        Math.floor(Math.random() * 100), // Random upvotes received
        Math.floor(Math.random() * 20), // Random downvotes received
        Math.floor(Math.random() * 200), // Random upvotes given
        Math.floor(Math.random() * 50), // Random downvotes given
        Math.floor(Math.random() * 5) // Random communities joined
      ]
    );
    
    // Insert user settings
    await executeQuery(
      connection,
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, theme,
        content_filter, allow_followers, display_online_status,
        language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        userId,
        Math.random() > 0.3 ? 1 : 0, // 70% chance of email notifications enabled
        Math.random() > 0.5 ? 1 : 0, // 50% chance of push notifications enabled
        Math.random() > 0.7 ? 'dark' : 'light', // 30% chance of dark theme
        'standard',
        1, // Allow followers
        1, // Display online status
        'en',
        'UTC'
      ]
    );
    
    users.push({
      id: userId,
      username,
      email
    });
  }
  
  console.log(`Generated ${users.length} users`);
  return users;
}

// Generate sample communities
async function generateCommunities(connection, users, count = 5) {
  console.log(`Generating ${count} sample communities...`);
  
  const communities = [];
  
  for (let i = 0; i < count; i++) {
    const communityId = uuidv4();
    const name = `community${i + 1}`;
    
    // Insert community
    await executeQuery(
      connection,
      `INSERT INTO community (
        id, name, description, privacy, created_at, updated_at
      ) VALUES (?, ?, ?, ?, NOW(), NOW())`,
      [
        communityId,
        name,
        `Description for ${name}`,
        i === 0 ? 'private' : 'public' // First community is private
      ]
    );
    
    // Insert community settings
    await executeQuery(
      connection,
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, join_method,
        require_post_approval, restricted_words, custom_theme_color,
        custom_banner_url, minimum_account_age_days, minimum_karma_required,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        communityId,
        1, // Allow post images
        1, // Allow post links
        i === 0 ? 'requires_approval' : 'auto_approve', // First community requires approval
        i === 0 ? 1 : 0, // First community requires post approval
        null, // No restricted words
        `#${Math.floor(Math.random() * 16777215).toString(16)}`, // Random color
        `https://example.com/community_banners/${name}.jpg`,
        i === 0 ? 30 : 0, // First community requires 30 days account age
        i === 0 ? 100 : 0 // First community requires 100 karma
      ]
    );
    
    // Add users as members
    for (let j = 0; j < users.length; j++) {
      // Skip some users for some communities to make it more realistic
      if (i > 0 && j > 0 && Math.random() < 0.3) continue;
      
      const role = j === 0 ? 'admin' : (j < 3 ? 'moderator' : 'member');
      
      await executeQuery(
        connection,
        `INSERT INTO community_member (
          community_id, user_id, role, joined_at
        ) VALUES (?, ?, ?, DATE_SUB(NOW(), INTERVAL ? DAY))`,
        [
          communityId,
          users[j].id,
          role,
          Math.floor(Math.random() * 365) // Joined 0-365 days ago
        ]
      );
      
      // Add moderator permissions for admins and moderators
      if (role === 'admin' || role === 'moderator') {
        await executeQuery(
          connection,
          `INSERT INTO moderator_permission (
            community_id, user_id, can_manage_settings, can_manage_members,
            can_manage_posts, can_manage_comments, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())`,
          [
            communityId,
            users[j].id,
            role === 'admin' ? 1 : 0, // Only admins can manage settings
            1, // Both can manage members
            1, // Both can manage posts
            1  // Both can manage comments
          ]
        );
      }
    }
    
    // Add some community rules
    const ruleCount = Math.floor(Math.random() * 5) + 1; // 1-5 rules
    for (let j = 0; j < ruleCount; j++) {
      await executeQuery(
        connection,
        `INSERT INTO community_rule (
          id, community_id, title, description, created_at, updated_at
        ) VALUES (?, ?, ?, ?, NOW(), NOW())`,
        [
          uuidv4(),
          communityId,
          `Rule ${j + 1} for ${name}`,
          `Description for rule ${j + 1} in ${name}`
        ]
      );
    }
    
    communities.push({
      id: communityId,
      name
    });
  }
  
  console.log(`Generated ${communities.length} communities`);
  return communities;
}

// Generate sample posts
async function generatePosts(connection, users, communities, count = 20) {
  console.log(`Generating ${count} sample posts...`);
  
  const posts = [];
  
  for (let i = 0; i < count; i++) {
    const postId = uuidv4();
    const userIndex = Math.floor(Math.random() * users.length);
    const communityIndex = Math.floor(Math.random() * communities.length);
    
    // Insert post
    await executeQuery(
      connection,
      `INSERT INTO post (
        id, title, content, user_id, community_id, profile_post,
        user_profile_id, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? HOUR), DATE_SUB(NOW(), INTERVAL ? HOUR))`,
      [
        postId,
        `Post ${i + 1} Title`,
        `Content for post ${i + 1}. This is a sample post generated for testing purposes.`,
        users[userIndex].id,
        communities[communityIndex].id,
        0, // Not a profile post
        null, // No user profile
        Math.floor(Math.random() * 720), // 0-30 days ago
        Math.floor(Math.random() * 720) // 0-30 days ago
      ]
    );
    
    posts.push({
      id: postId,
      title: `Post ${i + 1} Title`,
      userId: users[userIndex].id,
      communityId: communities[communityIndex].id
    });
  }
  
  console.log(`Generated ${posts.length} posts`);
  return posts;
}

// Generate sample comments
async function generateComments(connection, users, posts, count = 50) {
  console.log(`Generating ${count} sample comments...`);
  
  const comments = [];
  
  for (let i = 0; i < count; i++) {
    const commentId = uuidv4();
    const userIndex = Math.floor(Math.random() * users.length);
    const postIndex = Math.floor(Math.random() * posts.length);
    
    // Determine if this is a reply to another comment
    const isReply = i > 10 && Math.random() < 0.3; // 30% chance of being a reply after the first 10 comments
    const parentCommentId = isReply ? comments[Math.floor(Math.random() * comments.length)].id : null;
    
    // Insert comment
    await executeQuery(
      connection,
      `INSERT INTO comment (
        id, content, user_id, post_id, parent_comment_id, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? MINUTE), DATE_SUB(NOW(), INTERVAL ? MINUTE))`,
      [
        commentId,
        `This is comment ${i + 1}. ${isReply ? 'This is a reply to another comment.' : 'This is a top-level comment.'}`,
        users[userIndex].id,
        posts[postIndex].id,
        parentCommentId,
        Math.floor(Math.random() * 43200), // 0-30 days ago
        Math.floor(Math.random() * 43200) // 0-30 days ago
      ]
    );
    
    comments.push({
      id: commentId,
      userId: users[userIndex].id,
      postId: posts[postIndex].id,
      parentCommentId
    });
  }
  
  console.log(`Generated ${comments.length} comments`);
  return comments;
}

// Generate sample activities
async function generateActivities(connection, users, posts, comments) {
  console.log('Generating sample activities...');
  
  // Get activity types and actions
  const activityTypes = await executeQuery(connection, 'SELECT * FROM activity_type');
  const actions = await executeQuery(connection, 'SELECT * FROM action');
  
  // Map for easier lookup
  const activityTypeMap = {};
  activityTypes.forEach(type => {
    activityTypeMap[type.name] = type.id;
  });
  
  const actionMap = {};
  actions.forEach(action => {
    actionMap[action.name] = action.id;
  });
  
  // Generate post creation activities
  for (const post of posts) {
    await executeQuery(
      connection,
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type,
        metadata, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? HOUR))`,
      [
        uuidv4(),
        post.userId,
        activityTypeMap['POST'],
        actionMap['CREATE'],
        post.id,
        'post',
        JSON.stringify({ title: post.title, community_id: post.communityId }),
        '127.0.0.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        Math.floor(Math.random() * 720) // 0-30 days ago
      ]
    );
  }
  
  // Generate comment creation activities
  for (const comment of comments) {
    await executeQuery(
      connection,
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type,
        metadata, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? MINUTE))`,
      [
        uuidv4(),
        comment.userId,
        activityTypeMap['COMMENT'],
        actionMap['CREATE'],
        comment.id,
        'comment',
        JSON.stringify({ post_id: comment.postId, parent_comment_id: comment.parentCommentId }),
        '127.0.0.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        Math.floor(Math.random() * 43200) // 0-30 days ago
      ]
    );
  }
  
  // Generate some vote activities
  const voteCount = 100; // Number of votes to generate
  for (let i = 0; i < voteCount; i++) {
    const userIndex = Math.floor(Math.random() * users.length);
    const isUpvote = Math.random() > 0.3; // 70% chance of upvote
    const isPostVote = Math.random() > 0.4; // 60% chance of post vote
    
    const entityId = isPostVote 
      ? posts[Math.floor(Math.random() * posts.length)].id
      : comments[Math.floor(Math.random() * comments.length)].id;
    
    const entityType = isPostVote ? 'post' : 'comment';
    
    await executeQuery(
      connection,
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type,
        metadata, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? MINUTE))`,
      [
        uuidv4(),
        users[userIndex].id,
        activityTypeMap['VOTE'],
        isUpvote ? actionMap['UPVOTE'] : actionMap['DOWNVOTE'],
        entityId,
        entityType,
        JSON.stringify({ value: isUpvote ? 1 : -1 }),
        '127.0.0.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        Math.floor(Math.random() * 43200) // 0-30 days ago
      ]
    );
  }
  
  console.log('Generated activities');
}

// Main function to generate all sample data
async function generateSampleData() {
  let connection;
  
  try {
    // Connect to the database
    connection = await mysql.createConnection(dbConfig);
    console.log('Connected to database');
    
    // Disable foreign key checks during data generation
    await executeQuery(connection, 'SET FOREIGN_KEY_CHECKS = 0');
    
    // Generate data in the correct order to maintain relationships
    const users = await generateUsers(connection);
    const communities = await generateCommunities(connection, users);
    const posts = await generatePosts(connection, users, communities);
    const comments = await generateComments(connection, users, posts);
    await generateActivities(connection, users, posts, comments);
    
    // Re-enable foreign key checks
    await executeQuery(connection, 'SET FOREIGN_KEY_CHECKS = 1');
    
    console.log('Sample data generation completed successfully!');
  } catch (error) {
    console.error('Error generating sample data:', error);
  } finally {
    // Close connection
    if (connection) await connection.end();
  }
}

// Run the sample data generation
generateSampleData();

================
File: db/init_schema.js
================
// backend/db/init_schema.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

async function initSchema() {
    let conn;
    try {
        console.log('Connecting to MariaDB...');
        console.log('Connection details:', {
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            user: process.env.DB_USER,
            database: process.env.DB_NAME
        });
        
        conn = await pool.getConnection();
        console.log('Connected to MariaDB!');
        
        // Read the SQL file
        const sqlFilePath = path.join(__dirname, 'schema.sql');
        console.log('Reading SQL file from:', sqlFilePath);
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        
        // Split the SQL file into individual statements
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
        console.log(`Found ${statements.length} SQL statements to execute`);
        
        // Execute each statement
        for (const statement of statements) {
            console.log(`Executing: ${statement}`);
            try {
                const result = await conn.query(statement);
                console.log('Statement executed successfully');
            } catch (err) {
                console.error('Error executing statement:', err.message);
                // Continue with the next statement
            }
        }
        
        console.log('Schema initialization completed!');
    } catch (err) {
        console.error('Error initializing schema:', err);
    } finally {
        if (conn) {
            console.log('Closing database connection');
            conn.end();
        }
    }
}

initSchema();

================
File: db/init.js
================
import mariadb from 'mariadb';
import fs from 'fs';
import path from 'path';

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

async function initializeDatabase() {
    let conn;
    try {
        // Read schema file
        const schemaPath = path.join(__dirname, 'schema.sql');
        const schema = fs.readFileSync(schemaPath, 'utf8');

        // Get connection from pool
        conn = await pool.getConnection();
        
        // Execute schema
        await conn.query(schema);
        console.log('Database schema initialized successfully');
    } catch (error) {
        console.error('Error initializing database:', error);
    } finally {
        if (conn) conn.end();
    }
}

initializeDatabase();

================
File: db/migrate_data.js
================
// Script to migrate data from the old database to the new one
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');

// Old database connection configuration
const oldDbConfig = {
  host: '68.146.102.33',
  port: 3306,
  user: 'root',
  password: 'Oswald1986!',
  database: 'rumfor1', // Correct old database name
  multipleStatements: true
};

// New database connection configuration
const newDbConfig = {
  host: '68.146.102.33',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  database: 'rumfornew2',
  multipleStatements: true
};

// Helper function to execute a query and log the result
async function executeQuery(connection, query, params = []) {
  try {
    const [result] = await connection.execute(query, params);
    return result;
  } catch (error) {
    console.error(`Error executing query: ${query}`);
    console.error(error);
    throw error;
  }
}

// Migrate users
async function migrateUsers(oldConn, newConn) {
  console.log('Migrating users...');
  
  // Get all users from the old database
  const users = await executeQuery(oldConn, 'SELECT * FROM users');
  console.log(`Found ${users.length} users to migrate`);
  
  // Get user settings if the table exists
  let settingsMap = {};
  try {
    const userSettings = await executeQuery(oldConn, 'SELECT * FROM user_settings');
    userSettings.forEach(setting => {
      settingsMap[setting.user_id] = setting;
    });
    console.log(`Found ${userSettings.length} user settings to migrate`);
  } catch (error) {
    console.log('No user_settings table found, skipping');
  }
  
  // Get user statistics if the table exists
  let statsMap = {};
  try {
    const userStats = await executeQuery(oldConn, 'SELECT * FROM user_statistics');
    userStats.forEach(stat => {
      statsMap[stat.user_id] = stat;
    });
    console.log(`Found ${userStats.length} user statistics to migrate`);
  } catch (error) {
    console.log('No user_statistics table found, skipping');
  }
  
  // Migrate each user
  for (const user of users) {
    // Insert into user table
    await executeQuery(
      newConn,
      `INSERT INTO user (
        id, username, email, password_hash, role, bio, avatar_url,
        profile_banner_url, website, location, is_verified, status,
        cake_day, created_at, updated_at, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        user.id,
        user.username,
        user.email,
        user.password_hash,
        user.role || 'user',
        user.bio,
        user.avatar_url,
        user.profile_banner_url,
        user.website,
        user.location,
        user.is_verified ? 1 : 0,
        user.status || 'active',
        user.cake_day,
        user.created_at,
        user.updated_at,
        user.last_active
      ]
    );
    
    // Insert user statistics
    const stats = statsMap[user.id] || {};
    await executeQuery(
      newConn,
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count,
        upvotes_received, downvotes_received, upvotes_given, downvotes_given,
        communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        user.id,
        stats.karma || user.karma || 0,
        stats.posts_count || user.post_count || 0,
        stats.comments_count || user.comment_count || 0,
        user.upvotes_received || 0,
        user.downvotes_received || 0,
        user.upvotes_given || 0,
        user.downvotes_given || 0,
        user.communities_joined || 0
      ]
    );
    
    // Insert user settings
    const settings = settingsMap[user.id] || {};
    await executeQuery(
      newConn,
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, theme,
        content_filter, allow_followers, display_online_status,
        language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        user.id,
        settings.email_notifications ? 1 : 0,
        settings.push_notifications ? 1 : 0,
        settings.theme || 'light',
        settings.content_filter || 'standard',
        settings.allow_followers ? 1 : 0,
        settings.display_online_status ? 1 : 0,
        settings.language || 'en',
        settings.timezone || 'UTC'
      ]
    );
  }
  
  console.log('Users migration completed');
}

// Migrate communities
async function migrateCommunities(oldConn, newConn) {
  console.log('Migrating communities...');
  
  // Get all communities from the old database
  try {
    const communities = await executeQuery(oldConn, 'SELECT * FROM communities');
    console.log(`Found ${communities.length} communities to migrate`);
    
    // Get community settings if the table exists
    let settingsMap = {};
    try {
      const communitySettings = await executeQuery(oldConn, 'SELECT * FROM community_settings');
      communitySettings.forEach(setting => {
        settingsMap[setting.community_id] = setting;
      });
      console.log(`Found ${communitySettings.length} community settings to migrate`);
    } catch (error) {
      console.log('No community_settings table found, skipping');
    }
    
    // Migrate each community
    for (const community of communities) {
      // Insert into community table
      await executeQuery(
        newConn,
        `INSERT INTO community (
          id, name, description, privacy, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?)`,
        [
          community.id,
          community.name,
          community.description,
          community.privacy || 'public',
          community.created_at,
          community.updated_at
        ]
      );
      
      // Insert community settings
      const settings = settingsMap[community.id] || {};
      await executeQuery(
        newConn,
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, join_method,
          require_post_approval, restricted_words, custom_theme_color,
          custom_banner_url, minimum_account_age_days, minimum_karma_required,
          updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
        [
          community.id,
          settings.allow_post_images ? 1 : 0,
          settings.allow_post_links ? 1 : 0,
          settings.join_method || 'auto_approve',
          settings.require_post_approval ? 1 : 0,
          settings.restricted_words,
          settings.custom_theme_color,
          settings.custom_banner_url,
          settings.minimum_account_age_days || 0,
          settings.minimum_karma_required || 0
        ]
      );
    }
    
    console.log('Communities migration completed');
  } catch (error) {
    console.log('No communities table found, skipping');
  }
}

// Migrate community members
async function migrateCommunityMembers(oldConn, newConn) {
  console.log('Migrating community members...');
  
  try {
    // Get all community members from the old database
    const members = await executeQuery(oldConn, 'SELECT * FROM community_members');
    console.log(`Found ${members.length} community members to migrate`);
    
    // Migrate each member
    for (const member of members) {
      await executeQuery(
        newConn,
        `INSERT INTO community_member (
          community_id, user_id, role, joined_at
        ) VALUES (?, ?, ?, ?)`,
        [
          member.community_id,
          member.user_id,
          member.role || 'member',
          member.joined_at
        ]
      );
    }
    
    console.log('Community members migration completed');
  } catch (error) {
    console.log('No community_members table found, skipping');
  }
}

// Migrate community rules
async function migrateCommunityRules(oldConn, newConn) {
  console.log('Migrating community rules...');
  
  try {
    // Get all community rules from the old database
    const rules = await executeQuery(oldConn, 'SELECT * FROM community_rules');
    console.log(`Found ${rules.length} community rules to migrate`);
    
    // Migrate each rule
    for (const rule of rules) {
      await executeQuery(
        newConn,
        `INSERT INTO community_rule (
          id, community_id, title, description, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?)`,
        [
          rule.id,
          rule.community_id,
          rule.title,
          rule.description,
          rule.created_at,
          rule.updated_at
        ]
      );
    }
    
    console.log('Community rules migration completed');
  } catch (error) {
    console.log('No community_rules table found, skipping');
  }
}

// Migrate posts
async function migratePosts(oldConn, newConn) {
  console.log('Migrating posts...');
  
  try {
    // Get all posts from the old database
    const posts = await executeQuery(oldConn, 'SELECT * FROM posts');
    console.log(`Found ${posts.length} posts to migrate`);
    
    // Migrate each post
    for (const post of posts) {
      await executeQuery(
        newConn,
        `INSERT INTO post (
          id, title, content, user_id, community_id, profile_post,
          user_profile_id, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          post.id,
          post.title,
          post.content,
          post.user_id,
          post.community_id,
          post.profile_post ? 1 : 0,
          post.user_profile_id,
          post.created_at,
          post.updated_at
        ]
      );
    }
    
    console.log('Posts migration completed');
  } catch (error) {
    console.log('No posts table found, skipping');
  }
}

// Migrate comments
async function migrateComments(oldConn, newConn) {
  console.log('Migrating comments...');
  
  try {
    // Get all comments from the old database
    const comments = await executeQuery(oldConn, 'SELECT * FROM comments');
    console.log(`Found ${comments.length} comments to migrate`);
    
    // Migrate each comment
    for (const comment of comments) {
      await executeQuery(
        newConn,
        `INSERT INTO comment (
          id, content, user_id, post_id, parent_comment_id, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          comment.id,
          comment.content,
          comment.user_id,
          comment.post_id,
          comment.parent_comment_id,
          comment.created_at,
          comment.updated_at
        ]
      );
    }
    
    console.log('Comments migration completed');
  } catch (error) {
    console.log('No comments table found, skipping');
  }
}

// Migrate votes
async function migrateVotes(oldConn, newConn) {
  console.log('Migrating votes...');
  
  // Get all post votes from the old database
  const postVotes = await executeQuery(oldConn, 'SELECT * FROM votes WHERE post_id IS NOT NULL');
  console.log(`Found ${postVotes.length} post votes to migrate`);
  
  // Migrate each post vote
  for (const vote of postVotes) {
    await executeQuery(
      newConn,
      `INSERT INTO vote (
        user_id, post_id, comment_id, value, created_at, updated_at
      ) VALUES (?, ?, NULL, ?, ?, ?)`,
      [
        vote.user_id,
        vote.post_id,
        vote.value,
        vote.created_at,
        vote.updated_at || vote.created_at
      ]
    );
  }
  
  // Get all comment votes from the old database
  const commentVotes = await executeQuery(oldConn, 'SELECT * FROM votes WHERE comment_id IS NOT NULL');
  console.log(`Found ${commentVotes.length} comment votes to migrate`);
  
  // Migrate each comment vote
  for (const vote of commentVotes) {
    await executeQuery(
      newConn,
      `INSERT INTO vote (
        user_id, post_id, comment_id, value, created_at, updated_at
      ) VALUES (?, NULL, ?, ?, ?, ?)`,
      [
        vote.user_id,
        vote.comment_id,
        vote.value,
        vote.created_at,
        vote.updated_at || vote.created_at
      ]
    );
  }
  
  console.log('Votes migration completed');
}

// Migrate moderator permissions
async function migrateModeratorPermissions(oldConn, newConn) {
  console.log('Migrating moderator permissions...');
  
  // Get all moderator permissions from the old database
  const permissions = await executeQuery(oldConn, 'SELECT * FROM moderator_permissions');
  console.log(`Found ${permissions.length} moderator permissions to migrate`);
  
  // Migrate each permission
  for (const permission of permissions) {
    await executeQuery(
      newConn,
      `INSERT INTO moderator_permission (
        community_id, user_id, can_manage_settings, can_manage_members,
        can_manage_posts, can_manage_comments, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        permission.community_id,
        permission.user_id,
        permission.can_manage_settings ? 1 : 0,
        permission.can_manage_members ? 1 : 0,
        permission.can_manage_posts ? 1 : 0,
        permission.can_manage_comments ? 1 : 0,
        permission.created_at,
        permission.updated_at
      ]
    );
  }
  
  console.log('Moderator permissions migration completed');
}

// Migrate banned users
async function migrateBannedUsers(oldConn, newConn) {
  console.log('Migrating banned users...');
  
  // Get all banned users from the old database
  const bannedUsers = await executeQuery(oldConn, 'SELECT * FROM banned_users');
  console.log(`Found ${bannedUsers.length} banned users to migrate`);
  
  // Migrate each banned user
  for (const banned of bannedUsers) {
    await executeQuery(
      newConn,
      `INSERT INTO banned_user (
        community_id, user_id, reason, banned_by, ban_expires_at, created_at
      ) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        banned.community_id,
        banned.user_id,
        banned.reason,
        banned.banned_by,
        banned.ban_expires_at,
        banned.created_at
      ]
    );
  }
  
  console.log('Banned users migration completed');
}

// Migrate saved items
async function migrateSavedItems(oldConn, newConn) {
  console.log('Migrating saved items...');
  
  // Get all saved items from the old database
  const savedItems = await executeQuery(oldConn, 'SELECT * FROM saved_items');
  console.log(`Found ${savedItems.length} saved items to migrate`);
  
  // Migrate each saved item
  for (const item of savedItems) {
    await executeQuery(
      newConn,
      `INSERT INTO saved_item (
        id, user_id, item_id, item_type, saved_at, collection_name
      ) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        item.id,
        item.user_id,
        item.item_id,
        item.item_type,
        item.saved_at,
        item.collection_name
      ]
    );
  }
  
  console.log('Saved items migration completed');
}

// Migrate user relationships (friends, follows, blocks)
async function migrateUserRelationships(oldConn, newConn) {
  console.log('Migrating user relationships...');
  
  // Migrate friends
  const friends = await executeQuery(oldConn, 'SELECT * FROM user_friends');
  console.log(`Found ${friends.length} friendships to migrate`);
  
  for (const friend of friends) {
    await executeQuery(
      newConn,
      `INSERT INTO user_relationship (
        id, user_id, related_user_id, relationship_type, status, created_at, updated_at
      ) VALUES (?, ?, ?, 'friend', ?, ?, ?)`,
      [
        uuidv4(),
        friend.user_id,
        friend.friend_id,
        friend.status,
        friend.created_at,
        friend.updated_at
      ]
    );
  }
  
  // Migrate followers if they exist
  try {
    const followers = await executeQuery(oldConn, 'SELECT * FROM user_followers');
    console.log(`Found ${followers.length} followers to migrate`);
    
    for (const follower of followers) {
      await executeQuery(
        newConn,
        `INSERT INTO user_relationship (
          id, user_id, related_user_id, relationship_type, status, created_at, updated_at
        ) VALUES (?, ?, ?, 'follow', 'accepted', ?, ?)`,
        [
          uuidv4(),
          follower.follower_id,
          follower.followed_id,
          follower.created_at,
          follower.created_at
        ]
      );
    }
  } catch (error) {
    console.log('No followers table found, skipping');
  }
  
  // Migrate blocks if they exist
  try {
    const blocks = await executeQuery(oldConn, 'SELECT * FROM user_blocked');
    console.log(`Found ${blocks.length} blocks to migrate`);
    
    for (const block of blocks) {
      await executeQuery(
        newConn,
        `INSERT INTO user_relationship (
          id, user_id, related_user_id, relationship_type, status, created_at, updated_at
        ) VALUES (?, ?, ?, 'block', 'accepted', ?, ?)`,
        [
          uuidv4(),
          block.blocker_id,
          block.blocked_id,
          block.created_at,
          block.created_at
        ]
      );
    }
  } catch (error) {
    console.log('No blocks table found, skipping');
  }
  
  console.log('User relationships migration completed');
}

// Migrate user achievements
async function migrateUserAchievements(oldConn, newConn) {
  console.log('Migrating user achievements...');
  
  // Get all user achievements from the old database
  const achievements = await executeQuery(oldConn, 'SELECT * FROM user_achievements');
  console.log(`Found ${achievements.length} user achievements to migrate`);
  
  // Migrate each achievement
  for (const achievement of achievements) {
    await executeQuery(
      newConn,
      `INSERT INTO user_achievement (
        id, user_id, achievement_type, achievement_name, description, earned_at
      ) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        achievement.id,
        achievement.user_id,
        achievement.achievement_type,
        achievement.achievement_name,
        achievement.description,
        achievement.earned_at
      ]
    );
  }
  
  console.log('User achievements migration completed');
}

// Migrate user flairs
async function migrateUserFlairs(oldConn, newConn) {
  console.log('Migrating user flairs...');
  
  // Get all user flairs from the old database
  const flairs = await executeQuery(oldConn, 'SELECT * FROM user_flair');
  console.log(`Found ${flairs.length} user flairs to migrate`);
  
  // Migrate each flair
  for (const flair of flairs) {
    await executeQuery(
      newConn,
      `INSERT INTO user_flair (
        id, user_id, community_id, text, background_color, text_color, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        flair.id,
        flair.user_id,
        flair.community_id,
        flair.text,
        flair.background_color,
        flair.text_color,
        flair.created_at,
        flair.updated_at
      ]
    );
  }
  
  console.log('User flairs migration completed');
}

// Main migration function
async function migrateData() {
  let oldConn, newConn;
  
  try {
    // Connect to both databases
    oldConn = await mysql.createConnection(oldDbConfig);
    newConn = await mysql.createConnection(newDbConfig);
    
    console.log('Connected to both databases');
    
    // Disable foreign key checks during migration
    await executeQuery(newConn, 'SET FOREIGN_KEY_CHECKS = 0');
    
    // Perform migrations in the correct order to maintain relationships
    await migrateUsers(oldConn, newConn);
    await migrateCommunities(oldConn, newConn);
    await migrateCommunityMembers(oldConn, newConn);
    await migrateCommunityRules(oldConn, newConn);
    await migratePosts(oldConn, newConn);
    await migrateComments(oldConn, newConn);
    await migrateVotes(oldConn, newConn);
    await migrateModeratorPermissions(oldConn, newConn);
    await migrateBannedUsers(oldConn, newConn);
    await migrateSavedItems(oldConn, newConn);
    await migrateUserRelationships(oldConn, newConn);
    await migrateUserAchievements(oldConn, newConn);
    await migrateUserFlairs(oldConn, newConn);
    
    // Re-enable foreign key checks
    await executeQuery(newConn, 'SET FOREIGN_KEY_CHECKS = 1');
    
    console.log('Migration completed successfully!');
  } catch (error) {
    console.error('Error during migration:', error);
  } finally {
    // Close connections
    if (oldConn) await oldConn.end();
    if (newConn) await newConn.end();
  }
}

// Run the migration
migrateData();

================
File: db/migrate_database.bat
================
@echo off
echo ===================================================
echo Database Migration Utility for Windows
echo ===================================================
echo.

:menu
echo Choose an option:
echo 1. Create new database and apply schema
echo 2. Migrate data from old database to new database
echo 3. Generate sample data for new database
echo 4. Add admin user to new database
echo 5. Switch application to use new database
echo 6. Switch application to use old database
echo 7. Restore original .env file
echo 8. Run complete migration with existing data (steps 1-2-5)
echo 9. Run complete migration with sample data (steps 1-3-5)
echo 10. Run complete migration with sample data and admin user (steps 1-3-4-5)
echo 11. Exit
echo.

set /p choice="Enter your choice (1-11): "

if "%choice%"=="1" goto create_db
if "%choice%"=="2" goto migrate_data
if "%choice%"=="3" goto generate_data
if "%choice%"=="4" goto add_admin
if "%choice%"=="5" goto use_new_db
if "%choice%"=="6" goto use_old_db
if "%choice%"=="7" goto restore_env
if "%choice%"=="8" goto complete_migration_existing
if "%choice%"=="9" goto complete_migration_sample
if "%choice%"=="10" goto complete_migration_sample_admin
if "%choice%"=="11" goto end
goto invalid_choice

:create_db
echo.
echo Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
pause
goto menu

:migrate_data
echo.
echo Migrating data from old database to new database...
cd %~dp0
node migrate_data.js
echo.
pause
goto menu

:use_new_db
echo.
echo Switching application to use new database...
cd %~dp0
node update_connection.js
echo.
pause
goto menu

:use_old_db
echo.
echo Switching application to use old database...
cd %~dp0
node update_connection.js --old
echo.
pause
goto menu

:restore_env
echo.
echo Restoring original .env file...
cd %~dp0
node update_connection.js --restore
echo.
pause
goto menu

:generate_data
echo.
echo Generating sample data for new database...
cd %~dp0
node generate_sample_data.js
echo.
pause
goto menu

:add_admin
echo.
echo Adding admin user to new database...
cd %~dp0
node add_admin_user.js
echo.
pause
goto menu

:complete_migration_existing
echo.
echo Running complete migration process with existing data...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Migrating data from old database to new database...
node migrate_data.js
echo.
echo Step 3: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:complete_migration_sample
echo.
echo Running complete migration process with sample data...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Generating sample data for new database...
node generate_sample_data.js
echo.
echo Step 3: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:complete_migration_sample_admin
echo.
echo Running complete migration process with sample data and admin user...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Generating sample data for new database...
node generate_sample_data.js
echo.
echo Step 3: Adding admin user to new database...
node add_admin_user.js
echo.
echo Step 4: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:invalid_choice
echo.
echo Invalid choice. Please try again.
echo.
pause
goto menu

:end
echo.
echo Exiting Database Migration Utility.
echo.

================
File: db/moderator_schema_updates.sql
================
-- Enhance community_settings table with additional moderation settings
ALTER TABLE community_settings 
ADD COLUMN IF NOT EXISTS require_post_approval BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS restricted_words TEXT,
ADD COLUMN IF NOT EXISTS custom_theme_color VARCHAR(20),
ADD COLUMN IF NOT EXISTS custom_banner_url TEXT,
ADD COLUMN IF NOT EXISTS minimum_account_age_days INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS minimum_karma_required INT DEFAULT 0;

-- Create moderator_permissions table for granular control
CREATE TABLE IF NOT EXISTS moderator_permissions (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create post_moderation table for post approval workflow
CREATE TABLE IF NOT EXISTS post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (moderator_id) REFERENCES users(id)
);

-- Create moderation_logs table for tracking all moderator actions
CREATE TABLE IF NOT EXISTS moderation_logs (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (moderator_id) REFERENCES users(id)
);

-- Create banned_users table for community-specific bans
CREATE TABLE IF NOT EXISTS banned_users (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (banned_by) REFERENCES users(id)
);

================
File: db/new_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL, -- 'home', 'work', etc.
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User relationships
CREATE TABLE user_relationship (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    related_user_id VARCHAR(36) NOT NULL,
    relationship_type VARCHAR(20) NOT NULL, -- 'friend', 'follow', 'block'
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (related_user_id) REFERENCES user(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, related_user_id, relationship_type)
);

-- User achievements
CREATE TABLE user_achievement (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community join requests
CREATE TABLE community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User flair for communities
CREATE TABLE user_flair (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    text VARCHAR(50) NOT NULL,
    background_color VARCHAR(20) DEFAULT '#e0e0e0',
    text_color VARCHAR(20) DEFAULT '#000000',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, community_id)
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Vote table with support for both post and comment votes
CREATE TABLE vote (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, COALESCE(post_id, ''), COALESCE(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE,
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Saved items
CREATE TABLE saved_item (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    item_id VARCHAR(36) NOT NULL,
    item_type VARCHAR(20) NOT NULL, -- 'post', 'comment'
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    collection_name VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post moderation
CREATE TABLE post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE SET NULL
);

-- Banned users
CREATE TABLE banned_user (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (banned_by) REFERENCES user(id) ON DELETE CASCADE
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, community, etc.)
    entity_type VARCHAR(50), -- Type of the related entity (post, comment, community, etc.)
    metadata JSON, -- Additional data related to the activity
    ip_address VARCHAR(45), -- IPv4 or IPv6 address
    user_agent TEXT, -- Browser/client information
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Moderation logs
CREATE TABLE moderation_log (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Create indexes for faster queries
CREATE INDEX idx_post_user_id ON post(user_id);
CREATE INDEX idx_post_community_id ON post(community_id);
CREATE INDEX idx_comment_post_id ON comment(post_id);
CREATE INDEX idx_comment_user_id ON comment(user_id);
CREATE INDEX idx_comment_parent_id ON comment(parent_comment_id);
CREATE INDEX idx_vote_post_id ON vote(post_id);
CREATE INDEX idx_vote_comment_id ON vote(comment_id);
CREATE INDEX idx_activity_user_id ON activity(user_id);
CREATE INDEX idx_activity_type_id ON activity(activity_type_id);
CREATE INDEX idx_activity_action_id ON activity(action_id);
CREATE INDEX idx_activity_entity ON activity(entity_id, entity_type);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

-- Create triggers to automatically update user statistics

-- Update posts_count when a post is created
DELIMITER //
CREATE TRIGGER after_post_insert
AFTER INSERT ON post
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        posts_count = posts_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'POST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        NEW.id,
        'post',
        JSON_OBJECT(
            'title', NEW.title,
            'community_id', NEW.community_id
        )
    );
END //
DELIMITER ;

-- Update posts_count when a post is deleted
DELIMITER //
CREATE TRIGGER after_post_delete
AFTER DELETE ON post
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        posts_count = GREATEST(0, posts_count - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'POST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        OLD.id,
        'post'
    );
END //
DELIMITER ;

-- Update comments_count when a comment is created
DELIMITER //
CREATE TRIGGER after_comment_insert
AFTER INSERT ON comment
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        comments_count = comments_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMENT'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        NEW.id,
        'comment',
        JSON_OBJECT(
            'post_id', NEW.post_id,
            'parent_comment_id', NEW.parent_comment_id
        )
    );
END //
DELIMITER ;

-- Update comments_count when a comment is deleted
DELIMITER //
CREATE TRIGGER after_comment_delete
AFTER DELETE ON comment
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        comments_count = GREATEST(0, comments_count - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMENT'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        OLD.id,
        'comment'
    );
END //
DELIMITER ;

-- Update upvotes/downvotes when a vote is created or updated
DELIMITER //
CREATE TRIGGER after_vote_insert_update
AFTER INSERT ON vote
FOR EACH ROW
BEGIN
    DECLARE content_author_id VARCHAR(36);
    DECLARE content_type VARCHAR(20);
    
    -- Determine the content type and get the author
    IF NEW.post_id IS NOT NULL THEN
        SELECT user_id INTO content_author_id FROM post WHERE id = NEW.post_id;
        SET content_type = 'post';
    ELSE
        SELECT user_id INTO content_author_id FROM comment WHERE id = NEW.comment_id;
        SET content_type = 'comment';
    END IF;
    
    -- Update the voter's stats
    IF NEW.value = 1 THEN
        UPDATE user_statistic SET 
            upvotes_given = upvotes_given + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.user_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE user_statistic SET 
            downvotes_given = downvotes_given + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.user_id;
    END IF;
    
    -- Update the content author's stats
    IF NEW.value = 1 THEN
        UPDATE user_statistic SET 
            upvotes_received = upvotes_received + 1,
            karma = karma + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = content_author_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE user_statistic SET 
            downvotes_received = downvotes_received + 1,
            karma = GREATEST(0, karma - 1),
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = content_author_id;
    END IF;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'VOTE'),
        (SELECT id FROM action WHERE name = IF(NEW.value = 1, 'UPVOTE', 'DOWNVOTE')),
        IF(NEW.post_id IS NOT NULL, NEW.post_id, NEW.comment_id),
        content_type
    );
END //
DELIMITER ;

-- Update communities_joined when a user joins a community
DELIMITER //
CREATE TRIGGER after_community_member_insert
AFTER INSERT ON community_member
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        communities_joined = communities_joined + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        NEW.community_id,
        'community',
        JSON_OBJECT('role', NEW.role)
    );
END //
DELIMITER ;

-- Update communities_joined when a user leaves a community
DELIMITER //
CREATE TRIGGER after_community_member_delete
AFTER DELETE ON community_member
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        communities_joined = GREATEST(0, communities_joined - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        OLD.community_id,
        'community'
    );
END //
DELIMITER ;

-- Log moderation actions
DELIMITER //
CREATE TRIGGER after_moderation_log_insert
AFTER INSERT ON moderation_log
FOR EACH ROW
BEGIN
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.moderator_id,
        (SELECT id FROM activity_type WHERE name = 'MODERATION'),
        (SELECT id FROM action WHERE name = 'MODERATE'),
        NEW.target_id,
        NEW.target_type,
        JSON_OBJECT(
            'action_type', NEW.action_type,
            'community_id', NEW.community_id,
            'reason', NEW.reason
        )
    );
END //
DELIMITER ;

================
File: db/README_DATABASE_REFACTORING.md
================
# Database Refactoring Guide

This guide explains the database refactoring process and how to use the scripts provided to migrate from the old database structure to the new one.

## Overview

The database refactoring addresses several issues with the current database:

1. **Data Duplication**: Eliminated duplicate data across tables
2. **Missing Activity Tracking**: Added comprehensive activity tracking system
3. **Inconsistent Naming Conventions**: Standardized naming conventions
4. **Missing Personal Information**: Added support for more user information

## New Database Structure

The new database structure includes:

- Improved user tables with support for personal information and addresses
- Consolidated user statistics in a single table
- Comprehensive activity tracking system
- Standardized naming conventions
- Better relationship handling

## Scripts

The following scripts are provided to help with the migration:

### 1. `new_schema.sql`

This file contains the complete SQL schema for the new database. It defines all tables, indexes, triggers, and default data.

### 2. `apply_new_schema.js`

This script creates the new database and applies the schema. It:

- Creates the `rumfornew2` database if it doesn't exist
- Creates the `rumfornew2` user with the password `Oswald1986!`
- Grants necessary privileges
- Applies the schema from `new_schema.sql`

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\apply_new_schema.js
```

For Bash/Linux:
```bash
node backend/db/apply_new_schema.js
```

### 3. `migrate_data.js`

This script migrates data from the old database to the new one. It:

- Connects to both the old and new databases
- Reads data from the old database tables
- Transforms the data to fit the new schema
- Inserts the transformed data into the new database tables

### 3a. `generate_sample_data.js`

This script generates sample data for the new database. It:

- Connects to the new database
- Generates sample users, communities, posts, comments, and activities
- Inserts the sample data into the new database tables

This script is useful when you don't have an existing database to migrate from, or when you want to test the new database with sample data.

### 3b. `add_admin_user.js`

This script adds an admin user to the new database. It:

- Connects to the new database
- Creates an admin user with username 'admin' and password 'Oswald1986!'
- Sets up the necessary user statistics and settings for the admin user

This script is useful for quickly setting up an admin account to access the system.

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\add_admin_user.js
```

For Bash/Linux:
```bash
node backend/db/add_admin_user.js
```

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\migrate_data.js
```

For Bash/Linux:
```bash
node backend/db/migrate_data.js
```

### 4. `update_connection.js`

This script updates the application's database connection to use either the old or new database. It:

- Creates a backup of the original `.env` file
- Updates the database connection parameters in the `.env` file
- Provides options to switch between the old and new databases

Usage:

For Windows PowerShell:
```powershell
# Switch to the new database (default)
node .\backend\db\update_connection.js

# Switch to the old database
node .\backend\db\update_connection.js --old

# Restore the original .env file
node .\backend\db\update_connection.js --restore

# Show help
node .\backend\db\update_connection.js --help
```

For Bash/Linux:
```bash
# Switch to the new database (default)
node backend/db/update_connection.js

# Switch to the old database
node backend/db/update_connection.js --old

# Restore the original .env file
node backend/db/update_connection.js --restore

# Show help
node backend/db/update_connection.js --help
```

## Migration Process

Follow these steps to migrate to the new database:

1. **Backup your data**: Ensure you have a backup of your current database before proceeding.

2. **Create the new database and apply the schema**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\apply_new_schema.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/apply_new_schema.js
   ```

3. **Migrate the data from the old database to the new one**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\migrate_data.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/migrate_data.js
   ```

4. **Update the application to use the new database**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\update_connection.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/update_connection.js
   ```

5. **Test the application with the new database**:
   Start your application and verify that everything works as expected.

6. **If needed, switch back to the old database**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\update_connection.js --old
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/update_connection.js --old
   ```

## Key Improvements

### 1. User Data Structure

- Added support for first name, last name, date of birth, and secondary email
- Added support for user addresses
- Consolidated user statistics in a single table

### 2. Activity Tracking

- Added activity types and actions tables
- Added comprehensive activity tracking
- Automatic activity logging through triggers

### 3. Naming Conventions

- Standardized table names to singular form
- Consistent field naming across related tables
- Consistent use of snake_case for all field names

### 4. Relationships

- Improved handling of user relationships (friends, follows, blocks)
- Better community membership and moderation tracking
- Enhanced post and comment relationships

## Database Diagram

The new database structure follows this general organization:

```
User-related tables:
  - user
  - user_address
  - user_statistic
  - user_setting
  - user_relationship
  - user_achievement
  - user_flair

Community-related tables:
  - community
  - community_member
  - community_rule
  - community_setting
  - community_join_request
  - moderator_permission
  - banned_user

Content-related tables:
  - post
  - comment
  - vote
  - saved_item
  - post_moderation

Activity tracking:
  - activity_type
  - action
  - activity
  - moderation_log
```

## Troubleshooting

If you encounter issues during the migration process:

1. **Database connection errors**: Verify the connection parameters in the scripts match your environment.

2. **Permission issues**: Ensure the database user has the necessary privileges.

3. **Schema errors**: Check the MySQL error logs for details about any schema errors.

4. **Data migration errors**: The migration script will log errors for specific tables. You can modify the script to skip problematic tables or fix the data issues.

5. **Application errors**: If the application doesn't work with the new database, you can switch back to the old one using `update_connection.js --old` while you troubleshoot.

## Windows-Specific Notes

### Batch File for Windows Users

For Windows users, we've provided a batch file that makes it easier to run the migration scripts. You can run the batch file by double-clicking on it or by running it from PowerShell/Command Prompt:

```powershell
# From the project root
.\backend\db\migrate_database.bat

# Or navigate to the backend/db directory first
cd .\backend\db
.\migrate_database.bat
```

This will display a menu with options to:
1. Create new database and apply schema
2. Migrate data from old database to new database
3. Generate sample data for new database
4. Switch application to use new database
5. Switch application to use old database
6. Restore original .env file
7. Run complete migration with existing data (steps 1-2-4)
8. Run complete migration with sample data (steps 1-3-4)
9. Exit

Simply choose the option you want by entering the corresponding number.

### Additional Windows Notes

When running these scripts on Windows:

1. Make sure you're using the correct path separator (`\` instead of `/`) when running commands in PowerShell or Command Prompt.

2. If you encounter permission issues, you might need to run PowerShell as Administrator.

3. If you have issues with MySQL connections, ensure that the MySQL service is running:
   ```powershell
   # Check MySQL service status
   Get-Service MySQL*
   
   # Start MySQL service if it's not running
   Start-Service MySQL*
   ```

4. For database root access, you might need to specify the password in the scripts if your MySQL installation requires it.

================
File: db/schema.sql
================
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS communities (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS posts (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

CREATE TABLE IF NOT EXISTS comments (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id)
);

CREATE TABLE IF NOT EXISTS votes (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, post_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id)
);

================
File: db/seed_communities.js
================
// Seed script to create sample communities and related data
const mariadb = require('mariadb');
const dotenv = require('dotenv');
const { v4: uuidv4 } = require('uuid');
const path = require('path');

// Load environment variables
dotenv.config({ path: path.resolve(__dirname, '../.env') });

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function seedCommunities() {
  let conn;

  try {
    conn = await pool.getConnection();
    
    // Sample communities data
    const communities = [
      {
        id: uuidv4(),
        name: 'technology',
        description: 'Discussion about the latest in technology, gadgets, and software.',
        privacy: 'public'
      },
      {
        id: uuidv4(),
        name: 'programming',
        description: 'Share tips, ask questions, and discuss all aspects of programming.',
        privacy: 'public'
      },
      {
        id: uuidv4(),
        name: 'fitness',
        description: 'A community for fitness enthusiasts to share advice and progress.',
        privacy: 'public'
      }
    ];
    
    // Create the communities
    for (const community of communities) {
      try {
        // Check if the community already exists
        const [existingCommunity] = await conn.query('SELECT * FROM communities WHERE name = ?', [community.name]);
        
        if (!existingCommunity) {
          // Insert the community
          await conn.query(
            'INSERT INTO communities (id, name, description, privacy) VALUES (?, ?, ?, ?)',
            [community.id, community.name, community.description, community.privacy]
          );
          
          // Add default settings
          await conn.query(
            'INSERT INTO community_settings (community_id, allow_post_images, allow_post_links) VALUES (?, ?, ?)',
            [community.id, true, true]
          );
          
          console.log(`Created community: ${community.name}`);
          
          // Create sample rules for each community
          const rules = [
            {
              id: uuidv4(),
              title: 'Be respectful',
              description: 'Treat others with respect. No personal attacks or harassment.'
            },
            {
              id: uuidv4(),
              title: 'No spam',
              description: 'Don\'t spam posts or comments.'
            },
            {
              id: uuidv4(),
              title: 'Stay on topic',
              description: 'Posts should be relevant to the community topic.'
            }
          ];
          
          for (const rule of rules) {
            await conn.query(
              'INSERT INTO community_rules (id, community_id, title, description) VALUES (?, ?, ?, ?)',
              [rule.id, community.id, rule.title, rule.description]
            );
          }
          
          console.log(`Added rules for community: ${community.name}`);
          
          // Get a sample user to be moderator (if users table exists and has data)
          try {
            const users = await conn.query('SELECT id FROM users LIMIT 1');
            
            if (users && users.length > 0) {
              const userId = users[0].id;
              
              // Add the user as a moderator
              await conn.query(
                'INSERT INTO community_members (community_id, user_id, role) VALUES (?, ?, ?)',
                [community.id, userId, 'moderator']
              );
              
              console.log(`Added moderator for community: ${community.name}`);
            }
          } catch (error) {
            console.log(`No users available to add as moderators for ${community.name}`);
          }
        } else {
          console.log(`Community ${community.name} already exists`);
        }
      } catch (error) {
        console.error(`Error creating community ${community.name}:`, error);
      }
    }
    
    console.log('Seeding completed');
  } catch (error) {
    console.error('Error seeding communities:', error);
  } finally {
    if (conn) conn.release();
  }
}

seedCommunities()
  .then(() => console.log('Seed script completed'))
  .catch(err => console.error('Seed script failed:', err))
  .finally(() => process.exit());

================
File: db/simple_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL,
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve',
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE,
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36),
    entity_type VARCHAR(50),
    metadata JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

================
File: db/update_auth_files.js
================
// Script to update the auth-related files without modifying the database schema
const fs = require('fs');
const path = require('path');

async function updateAuthFiles() {
  console.log('Updating auth-related files...');
  
  try {
    // 1. Create backup of original files
    console.log('Creating backups of original files...');
    
    const filesToBackup = [
      { src: '../api/auth.js', dest: '../api/auth.js.bak' },
      { src: '../api/auth.ts', dest: '../api/auth.ts.bak' },
      { src: '../routes/auth.js', dest: '../routes/auth.js.bak' }
    ];
    
    for (const file of filesToBackup) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Backed up ${file.src} to ${file.dest}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping backup`);
      }
    }
    
    // 2. Replace the auth files with the new versions
    console.log('Replacing auth files with new versions...');
    
    const filesToReplace = [
      { src: '../api/auth.js.new', dest: '../api/auth.js' },
      { src: '../api/auth.ts.new', dest: '../api/auth.ts' },
      { src: '../routes/auth.js.new', dest: '../routes/auth.js' }
    ];
    
    for (const file of filesToReplace) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Replaced ${file.dest} with ${file.src}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping replacement`);
      }
    }
    
    console.log('Auth files updated successfully!');
    
  } catch (error) {
    console.error('Error updating auth files:', error);
    process.exit(1);
  }
}

// Run the function
updateAuthFiles().then(() => {
  console.log('Auth files update completed');
  process.exit(0);
}).catch(error => {
  console.error('Auth files update failed:', error);
  process.exit(1);
});

================
File: db/update_connection.js
================
// Script to update the database connection to use the new database
const fs = require('fs');
const path = require('path');

// Function to update the .env file
function updateEnvFile(useNewDb = true) {
  const envPath = path.join(__dirname, '..', '.env');
  
  // Read the current .env file
  let envContent = '';
  try {
    envContent = fs.readFileSync(envPath, 'utf8');
  } catch (error) {
    console.error('Error reading .env file:', error);
    return false;
  }
  
  // Define the old and new database configurations
  const oldDbConfig = {
    DB_HOST: '68.146.102.33',
    DB_PORT: '3306',
    DB_USER: 'root', // Replace with your actual user
    DB_PASSWORD: '', // Replace with your actual password
    DB_NAME: 'rumfor' // Replace with your actual database name
  };
  
  const newDbConfig = {
    DB_HOST: '68.146.102.33',
    DB_PORT: '3306',
    DB_USER: 'rumfornew2',
    DB_PASSWORD: 'Oswald1986!',
    DB_NAME: 'rumfornew2'
  };
  
  // Choose which configuration to use
  const dbConfig = useNewDb ? newDbConfig : oldDbConfig;
  
  // Update the .env content
  let updatedContent = envContent;
  
  // Update or add each database configuration variable
  for (const [key, value] of Object.entries(dbConfig)) {
    const regex = new RegExp(`^${key}=.*$`, 'm');
    
    if (updatedContent.match(regex)) {
      // Update existing variable
      updatedContent = updatedContent.replace(regex, `${key}=${value}`);
    } else {
      // Add new variable
      updatedContent += `\n${key}=${value}`;
    }
  }
  
  // Write the updated content back to the .env file
  try {
    fs.writeFileSync(envPath, updatedContent);
    console.log(`Successfully updated .env file to use ${useNewDb ? 'new' : 'old'} database`);
    return true;
  } catch (error) {
    console.error('Error writing .env file:', error);
    return false;
  }
}

// Create a backup of the original .env file
function backupEnvFile() {
  const envPath = path.join(__dirname, '..', '.env');
  const backupPath = path.join(__dirname, '..', '.env.backup');
  
  try {
    // Check if a backup already exists
    if (!fs.existsSync(backupPath)) {
      // Create a backup
      fs.copyFileSync(envPath, backupPath);
      console.log('Created backup of .env file at .env.backup');
    } else {
      console.log('Backup of .env file already exists at .env.backup');
    }
    return true;
  } catch (error) {
    console.error('Error creating backup of .env file:', error);
    return false;
  }
}

// Restore the original .env file from backup
function restoreEnvFile() {
  const envPath = path.join(__dirname, '..', '.env');
  const backupPath = path.join(__dirname, '..', '.env.backup');
  
  try {
    // Check if a backup exists
    if (fs.existsSync(backupPath)) {
      // Restore from backup
      fs.copyFileSync(backupPath, envPath);
      console.log('Restored .env file from backup');
      return true;
    } else {
      console.error('No backup of .env file found at .env.backup');
      return false;
    }
  } catch (error) {
    console.error('Error restoring .env file from backup:', error);
    return false;
  }
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    // Default to using the new database
    return { useNewDb: true, backup: true };
  }
  
  const options = {
    useNewDb: true,
    backup: true
  };
  
  for (const arg of args) {
    if (arg === '--old') {
      options.useNewDb = false;
    } else if (arg === '--new') {
      options.useNewDb = true;
    } else if (arg === '--no-backup') {
      options.backup = false;
    } else if (arg === '--restore') {
      options.restore = true;
    } else if (arg === '--help') {
      console.log(`
Usage: node update_connection.js [options]

Options:
  --new          Use the new database (default)
  --old          Use the old database
  --no-backup    Don't create a backup of the .env file
  --restore      Restore the .env file from backup
  --help         Show this help message
      `);
      process.exit(0);
    }
  }
  
  return options;
}

// Main function
function main() {
  const options = parseArgs();
  
  if (options.restore) {
    // Restore the .env file from backup
    if (restoreEnvFile()) {
      console.log('Successfully restored .env file from backup');
    } else {
      console.error('Failed to restore .env file from backup');
      process.exit(1);
    }
    return;
  }
  
  if (options.backup) {
    // Create a backup of the .env file
    if (!backupEnvFile()) {
      console.error('Failed to create backup of .env file');
      process.exit(1);
    }
  }
  
  // Update the .env file
  if (updateEnvFile(options.useNewDb)) {
    console.log(`Successfully updated .env file to use ${options.useNewDb ? 'new' : 'old'} database`);
  } else {
    console.error(`Failed to update .env file to use ${options.useNewDb ? 'new' : 'old'} database`);
    process.exit(1);
  }
}

// Run the main function
main();

================
File: db/user_auth_schema.sql
================
-- Add role column to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS role VARCHAR(20) DEFAULT 'user';

-- Ensure community_members table has role column
ALTER TABLE community_members ADD COLUMN IF NOT EXISTS role VARCHAR(20) DEFAULT 'member';

-- Create initial admin user (will be executed via a separate script)
-- INSERT INTO users (id, username, email, password_hash, role) 
-- VALUES ('admin-uuid', 'admin', 'admin@example.com', 'hashed-password', 'admin');

================
File: db/user_statistics_schema.sql
================
-- Add user statistics columns to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS bio TEXT DEFAULT NULL;
ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(255) DEFAULT NULL;
ALTER TABLE users ADD COLUMN IF NOT EXISTS post_count INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS comment_count INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS upvotes_received INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS downvotes_received INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS upvotes_given INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS downvotes_given INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS communities_joined INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Create user_friends table for tracking friendships
CREATE TABLE IF NOT EXISTS user_friends (
    user_id VARCHAR(36) NOT NULL,
    friend_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, friend_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (friend_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create user_achievements table for tracking achievements and badges
CREATE TABLE IF NOT EXISTS user_achievements (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create user_activity_log for tracking user activity (optional, for analytics)
CREATE TABLE IF NOT EXISTS user_activity_log (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, etc.)
    entity_type VARCHAR(50), -- Type of the related entity
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create triggers to automatically update user statistics

-- Update post_count when a post is created
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_post_insert
AFTER INSERT ON posts
FOR EACH ROW
BEGIN
    UPDATE users SET post_count = post_count + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update post_count when a post is deleted
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_post_delete
AFTER DELETE ON posts
FOR EACH ROW
BEGIN
    UPDATE users SET post_count = GREATEST(0, post_count - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

-- Update comment_count when a comment is created
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_comment_insert
AFTER INSERT ON comments
FOR EACH ROW
BEGIN
    UPDATE users SET comment_count = comment_count + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update comment_count when a comment is deleted
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_comment_delete
AFTER DELETE ON comments
FOR EACH ROW
BEGIN
    UPDATE users SET comment_count = GREATEST(0, comment_count - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

-- Update upvotes/downvotes when a vote is created or updated
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_vote_insert_update
AFTER INSERT ON votes
FOR EACH ROW
BEGIN
    DECLARE post_author_id VARCHAR(36);
    
    -- Get the post author
    SELECT user_id INTO post_author_id FROM posts WHERE id = NEW.post_id;
    
    -- Update the voter's stats
    IF NEW.value = 1 THEN
        UPDATE users SET upvotes_given = upvotes_given + 1, last_active = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE users SET downvotes_given = downvotes_given + 1, last_active = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    END IF;
    
    -- Update the post author's stats
    IF NEW.value = 1 THEN
        UPDATE users SET upvotes_received = upvotes_received + 1
        WHERE id = post_author_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE users SET downvotes_received = downvotes_received + 1
        WHERE id = post_author_id;
    END IF;
END //
DELIMITER ;

-- Update communities_joined when a user joins a community
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_community_member_insert
AFTER INSERT ON community_members
FOR EACH ROW
BEGIN
    UPDATE users SET communities_joined = communities_joined + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update communities_joined when a user leaves a community
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_community_member_delete
AFTER DELETE ON community_members
FOR EACH ROW
BEGIN
    UPDATE users SET communities_joined = GREATEST(0, communities_joined - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

================
File: db/votes_schema_update.sql
================
-- Rename the old votes table
RENAME TABLE votes TO votes_old;

-- Create the new votes table with support for both post and comment votes
CREATE TABLE votes (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, COALESCE(post_id, ''), COALESCE(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (comment_id) REFERENCES comments(id),
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Migrate data from the old votes table
INSERT INTO votes (user_id, post_id, comment_id, value, created_at)
SELECT user_id, post_id, NULL, value, created_at FROM votes_old;

-- Drop the old votes table
DROP TABLE votes_old;

================
File: fix_moderator_usernames.js
================
// Script to ensure moderators have usernames
const mariadb = require('mariadb');

// Create a connection pool with hardcoded values
const pool = mariadb.createPool({
  host: '192.168.0.139',
  port: 3306,
  user: 'root',
  password: 'Oswald1986!',
  database: 'rumfor1',
  connectionLimit: 15
});

async function fixModeratorUsernames() {
  let conn;

  try {
    conn = await pool.getConnection();

    // First check if the users table exists
    try {
      await conn.query('SELECT 1 FROM users LIMIT 1');
      console.log('✅ Users table exists');
    } catch (error) {
      console.error('❌ Users table does not exist or cannot be accessed');
      return;
    }

    // Now check if the community_members table exists
    try {
      await conn.query('SELECT 1 FROM community_members LIMIT 1');
      console.log('✅ Community_members table exists');
    } catch (error) {
      console.error('❌ Community_members table does not exist or cannot be accessed');
      return;
    }

    // Try to get all members with roles
    try {
      const members = await conn.query(`
        SELECT cm.*, u.username 
        FROM community_members cm 
        LEFT JOIN users u ON cm.user_id = u.id
        WHERE cm.role IN ('moderator', 'admin')
        LIMIT 20
      `);

      console.log(`Found ${members.length} moderators/admins`);

      if (members.length > 0) {
        console.log('\nSample moderator data:');
        members.forEach((mod, i) => {
          console.log(`[${i+1}] User ID: ${mod.user_id}, Username: ${mod.username || 'NULL'}, Role: ${mod.role}`);
        });

        // Check if any moderators are missing usernames
        const missingUsernames = members.filter(m => !m.username);
        if (missingUsernames.length > 0) {
          console.log(`\n⚠️ ${missingUsernames.length} moderators are missing usernames`);
        } else {
          console.log('\n✅ All moderators have usernames');
        }
      }
    } catch (error) {
      console.error('❌ Failed to query moderators:', error.message);
    }

    // Check direct join usage to verify it works
    try {
      const testQuery = `
        SELECT cm.community_id, cm.user_id, cm.role, u.username
        FROM community_members cm
        JOIN users u ON cm.user_id = u.id
        WHERE cm.role IN ('moderator', 'admin')
        LIMIT 5
      `;

      const testResult = await conn.query(testQuery);
      console.log('\nTest JOIN query result:');
      console.log(testResult);

      if (testResult.length > 0) {
        console.log('\n✅ JOIN works correctly and returns usernames');
      } else {
        console.log('\n⚠️ JOIN works but found no results');
      }
    } catch (error) {
      console.error('\n❌ JOIN query failed:', error.message);
    }
  } catch (error) {
    console.error('Error:', error);
  } finally {
    if (conn) conn.release();
  }
}

// Run the script
fixModeratorUsernames()
  .then(() => console.log('\nScript completed'))
  .catch(err => console.error('\nScript failed:', err))
  .finally(() => process.exit());

================
File: fix-table-names.js
================
const fs = require('fs');
const path = require('path');

// Read the index.ts file
const indexPath = path.join(__dirname, 'index.ts');
let content = fs.readFileSync(indexPath, 'utf8');

// Replace plural table names with singular ones
content = content.replace(/FROM communities WHERE/g, 'FROM community WHERE');
content = content.replace(/FROM community_members WHERE/g, 'FROM community_member WHERE');
content = content.replace(/FROM posts WHERE/g, 'FROM post WHERE');
content = content.replace(/FROM comments WHERE/g, 'FROM comment WHERE');
content = content.replace(/FROM users WHERE/g, 'FROM user WHERE');
content = content.replace(/FROM votes WHERE/g, 'FROM vote WHERE');

// Check for more plural table names
content = content.replace(/INSERT INTO communities/g, 'INSERT INTO community');
content = content.replace(/INSERT INTO community_members/g, 'INSERT INTO community_member');
content = content.replace(/INSERT INTO posts/g, 'INSERT INTO post');
content = content.replace(/INSERT INTO comments/g, 'INSERT INTO comment');
content = content.replace(/INSERT INTO users/g, 'INSERT INTO user');
content = content.replace(/INSERT INTO votes/g, 'INSERT INTO vote');

content = content.replace(/UPDATE communities/g, 'UPDATE community');
content = content.replace(/UPDATE community_members/g, 'UPDATE community_member');
content = content.replace(/UPDATE posts/g, 'UPDATE post');
content = content.replace(/UPDATE comments/g, 'UPDATE comment');
content = content.replace(/UPDATE users/g, 'UPDATE user');
content = content.replace(/UPDATE votes/g, 'UPDATE vote');

content = content.replace(/DELETE FROM communities/g, 'DELETE FROM community');
content = content.replace(/DELETE FROM community_members/g, 'DELETE FROM community_member');
content = content.replace(/DELETE FROM posts/g, 'DELETE FROM post');
content = content.replace(/DELETE FROM comments/g, 'DELETE FROM comment');
content = content.replace(/DELETE FROM users/g, 'DELETE FROM user');
content = content.replace(/DELETE FROM votes/g, 'DELETE FROM vote');

// Write the updated content back
fs.writeFileSync(indexPath, content, 'utf8');

console.log('Updated table names from plural to singular in index.ts');

// Now check the routes files
const routesDir = path.join(__dirname, 'routes');
const routeFiles = fs.readdirSync(routesDir);

routeFiles.forEach(file => {
  if (file.endsWith('.js')) {
    const filePath = path.join(routesDir, file);
    let routeContent = fs.readFileSync(filePath, 'utf8');
    
    // Replace plural table names with singular ones
    routeContent = routeContent.replace(/FROM communities/g, 'FROM community');
    routeContent = routeContent.replace(/FROM community_members/g, 'FROM community_member');
    routeContent = routeContent.replace(/FROM posts/g, 'FROM post');
    routeContent = routeContent.replace(/FROM comments/g, 'FROM comment');
    routeContent = routeContent.replace(/FROM users/g, 'FROM user');
    routeContent = routeContent.replace(/FROM votes/g, 'FROM vote');
    
    routeContent = routeContent.replace(/INSERT INTO communities/g, 'INSERT INTO community');
    routeContent = routeContent.replace(/INSERT INTO community_members/g, 'INSERT INTO community_member');
    routeContent = routeContent.replace(/INSERT INTO posts/g, 'INSERT INTO post');
    routeContent = routeContent.replace(/INSERT INTO comments/g, 'INSERT INTO comment');
    routeContent = routeContent.replace(/INSERT INTO users/g, 'INSERT INTO user');
    routeContent = routeContent.replace(/INSERT INTO votes/g, 'INSERT INTO vote');
    
    routeContent = routeContent.replace(/UPDATE communities/g, 'UPDATE community');
    routeContent = routeContent.replace(/UPDATE community_members/g, 'UPDATE community_member');
    routeContent = routeContent.replace(/UPDATE posts/g, 'UPDATE post');
    routeContent = routeContent.replace(/UPDATE comments/g, 'UPDATE comment');
    routeContent = routeContent.replace(/UPDATE users/g, 'UPDATE user');
    routeContent = routeContent.replace(/UPDATE votes/g, 'UPDATE vote');
    
    routeContent = routeContent.replace(/DELETE FROM communities/g, 'DELETE FROM community');
    routeContent = routeContent.replace(/DELETE FROM community_members/g, 'DELETE FROM community_member');
    routeContent = routeContent.replace(/DELETE FROM posts/g, 'DELETE FROM post');
    routeContent = routeContent.replace(/DELETE FROM comments/g, 'DELETE FROM comment');
    routeContent = routeContent.replace(/DELETE FROM users/g, 'DELETE FROM user');
    routeContent = routeContent.replace(/DELETE FROM votes/g, 'DELETE FROM vote');
    
    fs.writeFileSync(filePath, routeContent, 'utf8');
    console.log(`Updated table names in routes/${file}`);
  }
});

console.log('Database table name corrections completed');

================
File: index.js
================
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { v4: uuidv4 } = require('uuid');

// Import route modules
const authRoutes = require('./routes/auth');
const communitiesRoutes = require('./routes/communities');
const postsRoutes = require('./routes/posts');
const commentsRoutes = require('./routes/comments');
const usersRoutes = require('./routes/users');
const votesRoutes = require('./routes/votes');
const activityRoutes = require('./routes/activity');

// Import activity logging middleware
const { 
  logUserLogin, 
  logUserRegistration, 
  logUserLogout 
} = require('./middleware/activity');

dotenv.config();

const app = express();
const port = process.env.PORT || 3001; // Use a different port from the frontend

// Global middleware
app.use(express.json());
app.use(cors()); // Enable CORS for all routes

// Fix for BigInt serialization
BigInt.prototype.toJSON = function() {
    return this.toString();
};

// Get the authenticateToken middleware from auth routes
const { authenticateToken } = authRoutes;
const { canViewCommunity, isCommunityModerator } = communitiesRoutes;
const { canPostInCommunity } = postsRoutes;

// Authentication middleware for protected routes that allows anonymous access
const authenticateOptional = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    // Continue without authentication
    req.user = null;
    next();
    return;
  }
  
  try {
    const user = require('./api/auth').verifyToken(token);
    req.user = user;
    next();
  } catch (error) {
    // Log token error for debugging (but don't expose details to client)
    console.error('Token validation error:', error.message);
    
    // Clear any partial authentication data
    req.user = null;
    
    // Continue without authentication
    next();
  }
};

// Error handling middleware
const errorHandler = (err, req, res, next) => {
  console.error('Unhandled error:', err);
  
  // Don't expose internal server error details in production
  const statusCode = err.statusCode || 500;
  const message = statusCode === 500 ? 'Internal Server Error' : err.message;
  
  res.status(statusCode).json({
    error: {
      message,
      status: statusCode
    }
  });
};

// Mount the routes
// Add activity logging middleware to auth routes
app.use('/api/auth/login', logUserLogin);
app.use('/api/auth/register', logUserRegistration);
app.use('/api/auth/logout', authenticateOptional, logUserLogout);
app.use('/api/auth', authRoutes.router);

// For communities routes, use optional authentication
app.use('/api/communities', authenticateOptional, communitiesRoutes.router);

// For posts routes, use optional authentication
app.use('/api/posts', authenticateOptional, postsRoutes.router);

// For comments routes, use optional authentication
app.use('/api/comments', authenticateOptional, commentsRoutes);

// For users routes, use optional authentication
app.use('/api/users', authenticateOptional, usersRoutes);

// For votes routes, use optional authentication
app.use('/api/votes', authenticateOptional, votesRoutes);

// For activity routes, use authenticated routes only
app.use('/api/activity', authenticateToken, activityRoutes);

// Root route
app.get('/', (req, res) => {
  res.send('Hello from Express backend!');
});

// Add error handling middleware
app.use(errorHandler);

// Handle 404s
app.use((req, res) => {
  res.status(404).json({
    error: {
      message: 'Not Found',
      status: 404
    }
  });
});

// Start the server
app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);
});

================
File: index.ts
================
import express, { Request, Response, NextFunction } from 'express';
import mariadb from 'mariadb';
import cors from 'cors';
// Temporary imports to force tsc to compile api files
import * as posts from './api/posts';
import * as communities from './api/communities';
import * as users from './api/users';
import * as auth from './api/auth';
import * as commentsApi from './api/comments';

const app = express();
const port = 3001; // Use a different port from the frontend

import dotenv from 'dotenv';
dotenv.config();

const pool = mariadb.createPool({
     host: process.env.DB_HOST,
     port: Number(process.env.DB_PORT),
     user: process.env.DB_USER,
     password: process.env.DB_PASSWORD,
     database: process.env.DB_NAME,
     connectionLimit: 5
});

// Import API functions
import {
    getCommunities,
    getCommunity,
    createCommunity,
    updateCommunity,
    deleteCommunity,
    getCommunityRules,
    addCommunityRule,
    updateCommunityRule,
    deleteCommunityRule,
    getCommunitySettings,
    updateCommunitySettings,
    getCommunityMembers,
    addCommunityMember,
    updateCommunityMemberRole,
    removeCommunityMember,
    getCommunityAbout,
    getUserCommunities,
    searchCommunities
} from './api/communities';

import {
    register,
    login,
    getCurrentUser,
    verifyToken
} from './api/auth';

// Route Handlers
app.use(express.json());
app.use(cors()); // Enable CORS for all routes

// Authentication middleware
interface AuthRequest extends Request {
    user?: any;
}

const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction): void => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        res.status(401).json({ error: 'Authentication required' });
        return;
    }
    
    try {
        const user = verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        res.status(403).json({ error: 'Invalid or expired token' });
        return;
    }
};

// Check if user is a community moderator
const isCommunityModerator = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role = 'moderator'",
            [communityId, userId]
        );
        
        if (!membership) {
            res.status(403).json({ error: 'Moderator access required' });
            return;
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        res.status(500).json({ error: 'Failed to check moderator status' });
        return;
    } finally {
        if (conn) conn.end();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            next();
            return;
        }
        
        // Private communities require membership
        if (!userId) {
            res.status(401).json({ error: 'Authentication required' });
            return;
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            res.status(403).json({ error: 'Membership required' });
            return;
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        res.status(500).json({ error: 'Failed to check community access' });
        return;
    } finally {
        if (conn) conn.end();
    }
};

// Check if user can post in a community (must be a member)
const canPostInCommunity = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    const communityId = req.body.communityId;
    const userId = req.user.id;
    
    if (!communityId) {
        next(); // Profile post, no community check needed
        return;
    }
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            res.status(403).json({ error: 'You must be a member of this community to post' });
            return;
        }
        
        next();
    } catch (error) {
        console.error("Error checking community membership:", error);
        res.status(500).json({ error: 'Failed to check community membership' });
        return;
    } finally {
        if (conn) conn.end();
    }
};

// Authentication routes
app.post('/api/auth/register', async (req: Request, res: Response): Promise<void> => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        res.status(400).json({ error: 'Username, email, and password are required' });
        return;
    }
    
    try {
        const user = await register({ username, email, password });
        res.status(201).json(user);
    } catch (error: any) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

app.post('/api/auth/login', async (req: Request, res: Response): Promise<void> => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        res.status(400).json({ error: 'Username and password are required' });
        return;
    }
    
    try {
        const result = await login({ username, password });
        res.json(result);
    } catch (error: any) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

app.get('/api/auth/me', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    try {
        const user = await getCurrentUser(req.user.id);
        res.json(user);
    } catch (error: any) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

// Communities API
app.get('/api/communities', async (req: Request, res: Response): Promise<void> => {
    try {
        const searchTerm = req.query.search as string;
        
        if (searchTerm) {
            const communities = await searchCommunities(searchTerm);
            res.json(communities);
        } else {
            const communities = await getCommunities();
            res.json(communities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

app.get('/api/communities/:id', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const community = await getCommunity(id);
        if (!community) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

app.post('/api/communities', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await addCommunityMember(newCommunity.id, userId, 'moderator');
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

app.put('/api/communities/:id', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    try {
        const updatedCommunity = await updateCommunity(id, { name, description, privacy }, userId);
        if (!updatedCommunity) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

app.delete('/api/communities/:id', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user.id;
    try {
        const success = await deleteCommunity(id, userId);
        if (!success) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
app.get('/api/communities/:id/rules', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const rules = await getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

app.post('/api/communities/:id/rules', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const { title, description } = req.body;
    const userId = req.user.id;
    try {
        const newRule = await addCommunityRule(id, { title, description }, userId);
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

app.put('/api/communities/:id/rules/:ruleId', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    const userId = req.user.id;
    try {
        const updatedRule = await updateCommunityRule(ruleId, { title, description }, userId);
        if (!updatedRule) {
            res.status(404).json({ error: 'Rule not found' });
            return;
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

app.delete('/api/communities/:id/rules/:ruleId', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { ruleId } = req.params;
    const userId = req.user.id;
    try {
        const success = await deleteCommunityRule(ruleId, userId);
        if (!success) {
            res.status(404).json({ error: 'Rule not found' });
            return;
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
app.get('/api/communities/:id/settings', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const settings = await getCommunitySettings(id);
        if (!settings) {
            res.status(404).json({ error: 'Settings not found' });
            return;
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

app.put('/api/communities/:id/settings', authenticateToken, isCommunityModerator, async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const { id } = req.params;
    const { allow_post_images, allow_post_links } = req.body;
    try {
        const userId = (req as any).user.id;
        const updatedSettings = await updateCommunitySettings(id, { allow_post_images, allow_post_links }, userId);
        if (!updatedSettings) {
            res.status(404).json({ error: 'Settings not found' });
            return;
        }
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
app.get('/api/communities/:id/members', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const members = await getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

app.post('/api/communities/:id/members', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    try {
        const newMember = await addCommunityMember(id, userId, 'member');
        res.status(201).json(newMember);
    } catch (error) {
        console.error("Error adding community member:", error);
        res.status(500).json({ error: 'Failed to add community member' });
    }
});

app.put('/api/communities/:id/members/:userId', authenticateToken, isCommunityModerator, async (req: Request, res: Response): Promise<void> => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedBy = (req as any).user.id;
        const updatedMember = await updateCommunityMemberRole(id, userId, role, updatedBy);
        if (!updatedMember) {
            res.status(404).json({ error: 'Member not found' });
            return;
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

app.delete('/api/communities/:id/members/:userId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role = 'moderator'",
                [id, currentUserId]
            );
            
            if (!membership) {
                res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
                return;
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            res.status(500).json({ error: 'Failed to check moderator status' });
            return;
        } finally {
            if (conn) conn.end();
        }
    }
    
    try {
        const success = await removeCommunityMember(id, userId);
        if (!success) {
            res.status(404).json({ error: 'Member not found' });
            return;
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Community About API
app.get('/api/communities/:id/about', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const about = await getCommunityAbout(id);
        if (!about) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.json(about);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
app.get('/api/users/:id/communities', async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const communities = await getUserCommunities(id);
        res.json(communities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Posts API
app.get('/api/posts', async (req: Request, res: Response): Promise<void> => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if we need to filter by community or user profile
        const communityId = req.query.communityId as string;
        const userProfileId = req.query.userProfileId as string;
        
        let query = "SELECT p.*, u.username FROM post p JOIN user u ON p.user_id = u.id";
        const params = [];
        
        if (communityId) {
            query += " WHERE p.community_id = ?";
            params.push(communityId);
        } else if (userProfileId) {
            query += " WHERE p.user_profile_id = ? OR p.user_id = ?";
            params.push(userProfileId, userProfileId);
        }
        
        query += " ORDER BY p.created_at DESC";
        
        const posts = await conn.query(query, params);
        res.json(posts);
    } catch (error) {
        console.error("Error fetching posts:", error);
        res.status(500).json({ error: 'Failed to fetch posts' });
    } finally {
        if (conn) conn.end();
    }
});

app.get('/api/posts/:id', async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    let conn;
    try {
        conn = await pool.getConnection();
        const [post] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        if (!post) {
            res.status(404).json({ error: 'Post not found' });
            return;
        }
        res.json(post);
    } catch (error) {
        console.error("Error fetching post:", error);
        res.status(500).json({ error: 'Failed to fetch post' });
    } finally {
        if (conn) conn.end();
    }
});

app.post('/api/posts', authenticateToken, canPostInCommunity, async (req: AuthRequest, res: Response): Promise<void> => {
    const { title, content, communityId, userProfileId, isProfilePost } = req.body;
    const authorId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Determine if this is a profile post
        const profilePost = isProfilePost || !!userProfileId;
        
        // Build the query based on whether this is a community post or profile post
        let query = "INSERT INTO post (title, content, user_id";
        const params = [title, content, authorId];
        
        if (communityId) {
            query += ", community_id, profile_post) VALUES (?, ?, ?, ?, ?)";
            params.push(communityId, profilePost);
        } else if (userProfileId) {
            query += ", user_profile_id, profile_post) VALUES (?, ?, ?, ?, ?)";
            params.push(userProfileId, profilePost);
        } else {
            query += ", profile_post) VALUES (?, ?, ?, ?)";
            params.push(profilePost);
        }
        
        const result = await conn.query(query, params);
        
        const [newPost] = await conn.query("SELECT * FROM post WHERE id = ?", [result.insertId]);
        res.status(201).json(newPost);
    } catch (error) {
        console.error("Error creating post:", error);
        res.status(500).json({ error: 'Failed to create post' });
    } finally {
        if (conn) conn.end();
    }
});

app.put('/api/posts/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const { title, content } = req.body;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is the author of the post
        const [post] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        
        if (!post) {
            res.status(404).json({ error: 'Post not found' });
            return;
        }
        
        if (post.user_id !== userId) {
            res.status(403).json({ error: 'You can only edit your own posts' });
            return;
        }
        
        await conn.query(
            "UPDATE post SET title = ?, content = ?, updated_at = NOW() WHERE id = ?",
            [title, content, id]
        );
        
        const [updatedPost] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        res.json(updatedPost);
    } catch (error) {
        console.error("Error updating post:", error);
        res.status(500).json({ error: 'Failed to update post' });
    } finally {
        if (conn) conn.end();
    }
});

app.delete('/api/posts/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is the author of the post or a community moderator
        const [post] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        
        if (!post) {
            res.status(404).json({ error: 'Post not found' });
            return;
        }
        
        if (post.user_id !== userId) {
            // Check if user is a moderator of the community
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role = 'moderator'",
                [post.community_id, userId]
            );
            
            if (!membership) {
                res.status(403).json({ error: 'You can only delete your own posts or posts in communities you moderate' });
                return;
            }
        }
        
        await conn.query("DELETE FROM post WHERE id = ?", [id]);
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting post:", error);
        res.status(500).json({ error: 'Failed to delete post' });
    } finally {
        if (conn) conn.end();
    }
});

app.get('/', (req: Request, res: Response): void => {
  res.send('Hello from Express backend!');
});

// Comments API
app.get('/api/posts/:postId/comments', async (req: Request, res: Response): Promise<void> => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const commentsList = await commentsApi.getThreadedComments(postId);
            res.json(commentsList);
        } else {
            const allComments = await commentsApi.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

app.get('/api/comments/:commentId', async (req: Request, res: Response): Promise<void> => {
    const { commentId } = req.params;
    try {
        const comment = await commentsApi.getComment(commentId);
        if (!comment) {
            res.status(404).json({ error: 'Comment not found' });
            return;
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

app.post('/api/posts/:postId/comments', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await commentsApi.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

app.put('/api/comments/:commentId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await commentsApi.updateComment(commentId, userId, content);
        if (!updatedComment) {
            res.status(404).json({ error: 'Comment not found' });
            return;
        }
        res.json(updatedComment);
    } catch (error: any) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            res.status(403).json({ error: error.message });
            return;
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

app.delete('/api/comments/:commentId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await commentsApi.deleteComment(commentId, userId);
        if (!success) {
            res.status(404).json({ error: 'Comment not found' });
            return;
        }
        res.status(204).end();
    } catch (error: any) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments') {
            res.status(403).json({ error: error.message });
            return;
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

app.get('/api/comments/:commentId/replies', async (req: Request, res: Response): Promise<void> => {
    const { commentId } = req.params;
    try {
        const replies = await commentsApi.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);
});

================
File: middleware/activity.js
================
const { logActivity } = require('../api/activity');

/**
 * Middleware to log user activities
 * @param {string} activityType - The type of activity (e.g., 'POST', 'COMMENT', 'VOTE')
 * @param {string} actionType - The type of action (e.g., 'CREATE', 'UPDATE', 'DELETE')
 * @param {Function} getEntityInfo - Function to extract entity info from request (returns { entityId, entityType, metadata })
 * @returns {Function} Express middleware function
 */
function logActivityMiddleware(activityType, actionType, getEntityInfo) {
  return async (req, res, next) => {
    // Store the original end function
    const originalEnd = res.end;
    let activityLogged = false;
    
    // Override the end function
    res.end = async function(chunk, encoding) {
      // Only log activities once to prevent duplicate logging
      if (activityLogged) {
        return originalEnd.call(this, chunk, encoding);
      }
      
      // Mark as logged to prevent double logging if there's an error
      activityLogged = true;
      
      // Only log activities for successful responses (2xx status codes)
      if (res.statusCode >= 200 && res.statusCode < 300) {
        try {
          // Get user ID from authenticated user
          const userId = req.user ? req.user.id : null;
          
          if (userId) {
            // Get entity info from the provided function
            let entityInfo = { entityId: null, entityType: null, metadata: null };
            
            try {
              entityInfo = getEntityInfo(req, res) || entityInfo;
            } catch (entityError) {
              console.error('Error extracting entity info:', entityError);
            }
            
            const { entityId, entityType, metadata } = entityInfo;
            
            // Get IP address and user agent
            const ipAddress = req.ip || req.connection.remoteAddress;
            const userAgent = req.headers['user-agent'];
            
            // Log the activity without waiting for it to complete
            logActivity({
              userId,
              activityType,
              actionType,
              entityId,
              entityType,
              metadata,
              ipAddress,
              userAgent
            }).catch(error => {
              console.error('Error logging activity:', error);
            });
          }
        } catch (error) {
          // Just log the error, don't affect the response
          console.error('Error in activity middleware:', error);
        }
      }
      
      // Call the original end function
      return originalEnd.call(this, chunk, encoding);
    };
    
    next();
  };
}

/**
 * Helper function to log user login activity
 */
function logUserLogin(req, res, next) {
  // Store the original end function
  const originalEnd = res.end;
  let activityLogged = false;
  
  // Override the end function
  res.end = async function(chunk, encoding) {
    // Only log activities once to prevent duplicate logging
    if (activityLogged) {
      return originalEnd.call(this, chunk, encoding);
    }
    
    // Mark as logged to prevent double logging if there's an error
    activityLogged = true;
    
    // Only log activities for successful responses (2xx status codes)
    if (res.statusCode >= 200 && res.statusCode < 300) {
      try {
        // Get user ID from response body
        let userId = null;
        
        if (chunk) {
          try {
            const responseBody = JSON.parse(chunk.toString());
            userId = responseBody && responseBody.user ? responseBody.user.id : null;
          } catch (parseError) {
            console.error('Error parsing response body:', parseError);
          }
        }
        
        if (userId) {
          // Get IP address and user agent
          const ipAddress = req.ip || req.connection.remoteAddress;
          const userAgent = req.headers['user-agent'];
          
          // Log the activity without waiting for it to complete
          logActivity({
            userId,
            activityType: 'USER',
            actionType: 'LOGIN',
            entityId: userId,
            entityType: 'user',
            metadata: null,
            ipAddress,
            userAgent
          }).catch(error => {
            console.error('Error logging login activity:', error);
          });
        }
      } catch (error) {
        // Just log the error, don't affect the response
        console.error('Error in login activity middleware:', error);
      }
    }
    
    // Call the original end function
    return originalEnd.call(this, chunk, encoding);
  };
  
  next();
}

/**
 * Helper function to log user registration activity
 */
function logUserRegistration(req, res, next) {
  // Store the original end function
  const originalEnd = res.end;
  let activityLogged = false;
  
  // Override the end function
  res.end = async function(chunk, encoding) {
    // Only log activities once to prevent duplicate logging
    if (activityLogged) {
      return originalEnd.call(this, chunk, encoding);
    }
    
    // Mark as logged to prevent double logging if there's an error
    activityLogged = true;
    
    // Only log activities for successful responses (2xx status codes)
    if (res.statusCode >= 200 && res.statusCode < 300) {
      try {
        // Get user ID from response body
        let userId = null;
        let username = null;
        
        if (chunk) {
          try {
            const responseBody = JSON.parse(chunk.toString());
            if (responseBody && responseBody.user) {
              userId = responseBody.user.id;
              username = responseBody.user.username;
            }
          } catch (parseError) {
            console.error('Error parsing response body:', parseError);
          }
        }
        
        if (userId) {
          // Get IP address and user agent
          const ipAddress = req.ip || req.connection.remoteAddress;
          const userAgent = req.headers['user-agent'];
          
          // Log the activity without waiting for it to complete
          logActivity({
            userId,
            activityType: 'USER',
            actionType: 'REGISTER',
            entityId: userId,
            entityType: 'user',
            metadata: { username },
            ipAddress,
            userAgent
          }).catch(error => {
            console.error('Error logging registration activity:', error);
          });
        }
      } catch (error) {
        // Just log the error, don't affect the response
        console.error('Error in registration activity middleware:', error);
      }
    }
    
    // Call the original end function
    return originalEnd.call(this, chunk, encoding);
  };
  
  next();
}

/**
 * Helper function to log user logout activity
 */
function logUserLogout(req, res, next) {
  // Get user ID from authenticated user
  const userId = req.user ? req.user.id : null;
  
  if (userId) {
    // Get IP address and user agent
    const ipAddress = req.ip || req.connection.remoteAddress;
    const userAgent = req.headers['user-agent'];
    
    // Log the activity without waiting for the middleware to complete
    logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress,
      userAgent
    }).catch(error => {
      console.error('Error logging logout activity:', error);
    });
  }
  
  next();
}

// Common entity info extractors
const entityInfoExtractors = {
  // Post entity info extractors
  post: {
    create: (req) => ({
      entityId: req.body.id || null, // For new posts, the ID might be in the response
      entityType: 'post',
      metadata: {
        title: req.body.title,
        community_id: req.body.communityId || req.body.community_id
      }
    }),
    update: (req) => ({
      entityId: req.params.id || req.params.postId,
      entityType: 'post',
      metadata: {
        title: req.body.title
      }
    }),
    delete: (req) => ({
      entityId: req.params.id || req.params.postId,
      entityType: 'post',
      metadata: null
    })
  },
  
  // Comment entity info extractors
  comment: {
    create: (req) => ({
      entityId: req.body.id || null, // For new comments, the ID might be in the response
      entityType: 'comment',
      metadata: {
        post_id: req.params.postId || req.body.post_id || req.body.postId,
        parent_comment_id: req.body.parentCommentId || req.body.parent_comment_id
      }
    }),
    update: (req) => ({
      entityId: req.params.id || req.params.commentId,
      entityType: 'comment',
      metadata: null
    }),
    delete: (req) => ({
      entityId: req.params.id || req.params.commentId,
      entityType: 'comment',
      metadata: null
    })
  },
  
  // Vote entity info extractors
  vote: {
    create: (req) => {
      if (req.params.postId || req.body.postId || req.body.post_id) {
        return {
          entityId: req.params.postId || req.body.postId || req.body.post_id,
          entityType: 'post',
          metadata: {
            value: req.body.value
          }
        };
      } else if (req.params.commentId || req.body.commentId || req.body.comment_id) {
        return {
          entityId: req.params.commentId || req.body.commentId || req.body.comment_id,
          entityType: 'comment',
          metadata: {
            value: req.body.value
          }
        };
      }
      return { entityId: null, entityType: null, metadata: null };
    }
  },
  
  // Community entity info extractors
  community: {
    create: (req) => ({
      entityId: req.body.id || null, // For new communities, the ID might be in the response
      entityType: 'community',
      metadata: {
        name: req.body.name
      }
    }),
    update: (req) => ({
      entityId: req.params.id || req.params.communityId,
      entityType: 'community',
      metadata: {
        name: req.body.name
      }
    }),
    join: (req) => ({
      entityId: req.params.id || req.params.communityId,
      entityType: 'community',
      metadata: null
    }),
    leave: (req) => ({
      entityId: req.params.id || req.params.communityId,
      entityType: 'community',
      metadata: null
    })
  }
};

module.exports = {
  logActivityMiddleware,
  logUserLogin,
  logUserRegistration,
  logUserLogout,
  entityInfoExtractors
};

================
File: middleware/auth.js
================
const jwt = require('jsonwebtoken');

// Middleware to authenticate JWT token
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'Access denied. No token provided.' });
  }
  
  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    req.user = user;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid token.' });
  }
};

module.exports = { authenticateToken };

================
File: middleware/moderation.js
================
// backend/middleware/moderation.js
const { isUserModerator, hasModeratorPermission, isUserBanned } = require('../api/moderation.ts.new');

// Middleware to check if a user is a moderator for a community
const isCommunityModerator = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isModerator = await isUserModerator(communityId, userId);
    
    if (!isModerator) {
      return res.status(403).json({ error: 'Only moderators can perform this action' });
    }
    
    next();
  } catch (error) {
    console.error('Error in moderator check middleware:', error);
    return res.status(500).json({ error: 'Server error checking moderator status' });
  }
};

// Middleware to check if a user has a specific moderator permission
const hasPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const { communityId } = req.params;
      const userId = req.user.id;
      
      if (!communityId) {
        return res.status(400).json({ error: 'Community ID is required' });
      }
      
      const hasPermission = await hasModeratorPermission(communityId, userId, permission);
      
      if (!hasPermission) {
        return res.status(403).json({ error: 'You do not have permission to perform this action' });
      }
      
      next();
    } catch (error) {
      console.error(`Error in permission check middleware (${permission}):`, error);
      return res.status(500).json({ error: 'Server error checking permissions' });
    }
  };
};

// Middleware to check if the user is banned from the community
const checkNotBanned = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isBanned = await isUserBanned(communityId, userId);
    
    if (isBanned) {
      return res.status(403).json({ error: 'You are banned from this community' });
    }
    
    next();
  } catch (error) {
    console.error('Error in ban check middleware:', error);
    return res.status(500).json({ error: 'Server error checking ban status' });
  }
};

module.exports = {
  isCommunityModerator,
  hasPermission,
  checkNotBanned
};

================
File: middleware/moderation.js.new
================
// backend/middleware/moderation.js
const { isUserModerator, hasModeratorPermission, isUserBanned } = require('../api/moderation.ts.new');

// Middleware to check if a user is a moderator for a community
const isCommunityModerator = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isModerator = await isUserModerator(communityId, userId);
    
    if (!isModerator) {
      return res.status(403).json({ error: 'Only moderators can perform this action' });
    }
    
    next();
  } catch (error) {
    console.error('Error in moderator check middleware:', error);
    return res.status(500).json({ error: 'Server error checking moderator status' });
  }
};

// Middleware to check if a user has a specific moderator permission
const hasPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const { communityId } = req.params;
      const userId = req.user.id;
      
      if (!communityId) {
        return res.status(400).json({ error: 'Community ID is required' });
      }
      
      const hasPermission = await hasModeratorPermission(communityId, userId, permission);
      
      if (!hasPermission) {
        return res.status(403).json({ error: 'You do not have permission to perform this action' });
      }
      
      next();
    } catch (error) {
      console.error(`Error in permission check middleware (${permission}):`, error);
      return res.status(500).json({ error: 'Server error checking permissions' });
    }
  };
};

// Middleware to check if the user is banned from the community
const checkNotBanned = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isBanned = await isUserBanned(communityId, userId);
    
    if (isBanned) {
      return res.status(403).json({ error: 'You are banned from this community' });
    }
    
    next();
  } catch (error) {
    console.error('Error in ban check middleware:', error);
    return res.status(500).json({ error: 'Server error checking ban status' });
  }
};

module.exports = {
  isCommunityModerator,
  hasPermission,
  checkNotBanned
};

================
File: package.json
================
{
  "name": "bolt-backend",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "node dist/index.js",
    "build": "tsc",
    "dev": "tsc --watch",
    "init-db": "node db/init.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/cors": "^2.8.17",
    "@types/uuid": "^10.0.0",
    "bcrypt": "^5.1.1",
    "bolt-backend": "file:",
    "cors": "^2.8.5",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "mariadb": "^3.2.4",
    "mysql2": "^3.12.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^20.12.8"
  }
}

================
File: routes/activity.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const {
  getUserActivities,
  getCommunityActivities,
  getPostActivities,
  getActivityTypes,
  getActionTypes,
  logActivity
} = require('../api/activity');

// Middleware to ensure routes are protected
router.use(authenticateToken);

/**
 * @route GET /api/activity/types
 * @desc Get all activity types
 * @access Private
 */
router.get('/types', async (req, res) => {
  try {
    const activityTypes = await getActivityTypes();
    res.json(activityTypes);
  } catch (error) {
    console.error('Error fetching activity types:', error);
    res.status(500).json({ error: 'Failed to fetch activity types' });
  }
});

/**
 * @route GET /api/activity/actions
 * @desc Get all action types
 * @access Private
 */
router.get('/actions', async (req, res) => {
  try {
    const actionTypes = await getActionTypes();
    res.json(actionTypes);
  } catch (error) {
    console.error('Error fetching action types:', error);
    res.status(500).json({ error: 'Failed to fetch action types' });
  }
});

/**
 * @route GET /api/activity/user/:userId
 * @desc Get activities for a specific user
 * @access Private (only for the user themselves or admins)
 */
router.get('/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own activities or is an admin
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own activities' });
    }
    
    // Extract query parameters
    const {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    } = req.query;
    
    const options = {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    };
    
    const activities = await getUserActivities(userId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Failed to fetch user activities' });
  }
});

/**
 * @route GET /api/activity/me
 * @desc Get activities for the current user
 * @access Private
 */
router.get('/me', async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Extract query parameters
    const {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    } = req.query;
    
    const options = {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    };
    
    const activities = await getUserActivities(userId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Failed to fetch user activities' });
  }
});

/**
 * @route GET /api/activity/community/:communityId
 * @desc Get activities for a specific community
 * @access Private (only for community members)
 */
router.get('/community/:communityId', async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Check if the user is a member of the community
    const conn = await pool.getConnection();
    try {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership && req.user.role !== 'admin') {
        return res.status(403).json({ error: 'You must be a member of this community to view its activities' });
      }
    } finally {
      conn.release();
    }
    
    // Extract query parameters
    const {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    } = req.query;
    
    const options = {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    };
    
    const activities = await getCommunityActivities(communityId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching community activities:', error);
    res.status(500).json({ error: 'Failed to fetch community activities' });
  }
});

/**
 * @route GET /api/activity/post/:postId
 * @desc Get activities for a specific post
 * @access Private
 */
router.get('/post/:postId', async (req, res) => {
  try {
    const { postId } = req.params;
    
    // Extract query parameters
    const { limit, offset } = req.query;
    
    const options = { limit, offset };
    
    const activities = await getPostActivities(postId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching post activities:', error);
    res.status(500).json({ error: 'Failed to fetch post activities' });
  }
});

/**
 * @route POST /api/activity/log
 * @desc Log a new activity (for manual logging, most activities are logged automatically)
 * @access Private (admin only)
 */
router.post('/log', async (req, res) => {
  try {
    // Only admins can manually log activities
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Only admins can manually log activities' });
    }
    
    const {
      userId,
      activityType,
      actionType,
      entityId,
      entityType,
      metadata
    } = req.body;
    
    // Validate required fields
    if (!userId || !activityType || !actionType) {
      return res.status(400).json({ error: 'userId, activityType, and actionType are required' });
    }
    
    // Get IP address and user agent from request
    const ipAddress = req.ip;
    const userAgent = req.headers['user-agent'];
    
    const activityData = {
      userId,
      activityType,
      actionType,
      entityId,
      entityType,
      metadata,
      ipAddress,
      userAgent
    };
    
    const activity = await logActivity(activityData);
    res.status(201).json(activity);
  } catch (error) {
    console.error('Error logging activity:', error);
    res.status(500).json({ error: 'Failed to log activity' });
  }
});

module.exports = router;

================
File: routes/auth.js
================
// Updated auth.js routes for the new database schema
const express = require('express');
const router = express.Router();
const auth = require('../api/auth.js');
const { logUserLogin, logUserRegistration, logUserLogout } = require('../middleware/activity');

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
        const user = auth.verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid or expired token' });
    }
};

// Authentication routes
router.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        return res.status(400).json({ error: 'Username, email, and password are required' });
    }
    
    try {
        const result = await auth.register({ username, email, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.status(201).json(result);
    } catch (error) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        return res.status(400).json({ error: 'Username and password are required' });
    }
    
    try {
        const result = await auth.login({ username, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.json(result);
    } catch (error) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

router.post('/logout', authenticateToken, async (req, res) => {
    try {
        await auth.logout(req.user.id);
        
        res.json({ success: true, message: 'Logged out successfully' });
    } catch (error) {
        console.error("Error logging out:", error);
        res.status(500).json({ error: error.message });
    }
});

router.get('/me', authenticateToken, async (req, res) => {
    try {
        const user = await auth.getCurrentUser(req.user.id);
        res.json(user);
    } catch (error) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

module.exports = {
    router,
    authenticateToken
};

================
File: routes/auth.js.new
================
// Updated auth.js routes for the new database schema
const express = require('express');
const router = express.Router();
const auth = require('../api/auth.js');
const { logUserLogin, logUserRegistration, logUserLogout } = require('../middleware/activity');

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
        const user = auth.verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid or expired token' });
    }
};

// Authentication routes
router.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        return res.status(400).json({ error: 'Username, email, and password are required' });
    }
    
    try {
        const result = await auth.register({ username, email, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.status(201).json(result);
    } catch (error) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        return res.status(400).json({ error: 'Username and password are required' });
    }
    
    try {
        const result = await auth.login({ username, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.json(result);
    } catch (error) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

router.post('/logout', authenticateToken, async (req, res) => {
    try {
        await auth.logout(req.user.id);
        
        res.json({ success: true, message: 'Logged out successfully' });
    } catch (error) {
        console.error("Error logging out:", error);
        res.status(500).json({ error: error.message });
    }
});

router.get('/me', authenticateToken, async (req, res) => {
    try {
        const user = await auth.getCurrentUser(req.user.id);
        res.json(user);
    } catch (error) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

module.exports = {
    router,
    authenticateToken
};

================
File: routes/comments.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const comments = require('../api/comments.js.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Get comments for a post (with optional threading)
router.get('/posts/:postId', async (req, res) => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const threadedComments = await comments.getThreadedComments(postId);
            res.json(threadedComments);
        } else {
            const allComments = await comments.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

// Get a specific comment
router.get('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    try {
        const comment = await comments.getComment(commentId);
        if (!comment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

// Create a new comment
router.post('/posts/:postId', checkNotBanned, async (req, res) => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await comments.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        if (error.message === 'Post not found' || error.message === 'Parent comment not found') {
            return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

// Update a comment
router.put('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await comments.updateComment(commentId, userId, content);
        if (!updatedComment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(updatedComment);
    } catch (error) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

// Delete a comment
router.delete('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await comments.deleteComment(commentId, userId);
        if (!success) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments or comments in communities you moderate') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

// Get replies to a comment
router.get('/:commentId/replies', async (req, res) => {
    const { commentId } = req.params;
    try {
        const replies = await comments.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

// Get comments for a specific user
router.get('/user/:userId', async (req, res) => {
    const { userId } = req.params;
    try {
        const userComments = await comments.getUserComments(userId);
        res.json(userComments);
    } catch (error) {
        console.error("Error fetching user comments:", error);
        res.status(500).json({ error: 'Failed to fetch user comments' });
    }
});

module.exports = router;

================
File: routes/comments.js.new
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const comments = require('../api/comments.js.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Get comments for a post (with optional threading)
router.get('/posts/:postId', async (req, res) => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const threadedComments = await comments.getThreadedComments(postId);
            res.json(threadedComments);
        } else {
            const allComments = await comments.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

// Get a specific comment
router.get('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    try {
        const comment = await comments.getComment(commentId);
        if (!comment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

// Create a new comment
router.post('/posts/:postId', checkNotBanned, async (req, res) => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await comments.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        if (error.message === 'Post not found' || error.message === 'Parent comment not found') {
            return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

// Update a comment
router.put('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await comments.updateComment(commentId, userId, content);
        if (!updatedComment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(updatedComment);
    } catch (error) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

// Delete a comment
router.delete('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await comments.deleteComment(commentId, userId);
        if (!success) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments or comments in communities you moderate') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

// Get replies to a comment
router.get('/:commentId/replies', async (req, res) => {
    const { commentId } = req.params;
    try {
        const replies = await comments.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

// Get comments for a specific user
router.get('/user/:userId', async (req, res) => {
    const { userId } = req.params;
    try {
        const userComments = await comments.getUserComments(userId);
        res.json(userComments);
    } catch (error) {
        console.error("Error fetching user comments:", error);
        res.status(500).json({ error: 'Failed to fetch user comments' });
    }
});

module.exports = router;

================
File: routes/communities.js
================
import express from 'express';
const router = express.Router();
import dotenv from 'dotenv';
import pool from '../db/connection.js';
import communityApi from '../api/community/index.js';

dotenv.config();

// Check if user is a community moderator
const isCommunityModerator = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Moderator access required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        return res.status(500).json({ error: 'Failed to check moderator status' });
    } finally {
        if (conn) conn.release();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            return next();
        }
        
        // Private communities require membership
        if (!userId) {
            return res.status(401).json({ error: 'Authentication required' });
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Membership required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        return res.status(500).json({ error: 'Failed to check community access' });
    } finally {
        if (conn) conn.release();
    }
};

// Communities API
router.get('/', async (req, res) => {
    try {
        const searchTerm = req.query.search;
        
        if (searchTerm) {
            const communitiesList = await communityApi.searchCommunities(searchTerm);
            res.json(communitiesList);
        } else {
            const allCommunities = await communityApi.getCommunities();
            res.json(allCommunities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

router.get('/:id', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const community = await communityApi.getCommunity(id);
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

router.post('/', async (req, res) => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await communityApi.createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await communityApi.addCommunityMember(newCommunity.id, userId, 'moderator');
        
        // Activity logging is now handled within the community API functions
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

router.put('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    try {
        const updatedCommunity = await communityApi.updateCommunity(id, { name, description, privacy });
        if (!updatedCommunity) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

router.delete('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const success = await communityApi.deleteCommunity(id);
        if (!success) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
router.get('/:id/rules', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const rules = await communityApi.getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

router.post('/:id/rules', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { title, description } = req.body;
    try {
        const newRule = await communityApi.addCommunityRule(id, { title, description });
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

router.put('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    try {
        const updatedRule = await communityApi.updateCommunityRule(ruleId, { title, description });
        if (!updatedRule) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

router.delete('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    try {
        const success = await communityApi.deleteCommunityRule(ruleId);
        if (!success) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
router.get('/:id/settings', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const settings = await communityApi.getCommunitySettings(id);
        if (!settings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

router.put('/:id/settings', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { 
        allow_post_images, 
        allow_post_links, 
        join_method,
        require_post_approval,
        restricted_words,
        custom_theme_color,
        custom_banner_url,
        minimum_account_age_days,
        minimum_karma_required
    } = req.body;
    
    try {
        const updatedSettings = await communityApi.updateCommunitySettings(id, { 
            allow_post_images, 
            allow_post_links,
            join_method,
            require_post_approval,
            restricted_words,
            custom_theme_color,
            custom_banner_url,
            minimum_account_age_days,
            minimum_karma_required
        });
        
        if (!updatedSettings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
router.get('/:id/members', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const members = await communityApi.getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

// Get a specific member
router.get('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    console.log(`GET request for member: community ${id}, user ${userId}`);
    
    try {
        const member = await communityApi.getCommunityMember(id, userId);
        console.log("Member result:", member);
        
        if (!member) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        res.json(member);
    } catch (error) {
        console.error("Error fetching community member:", error);
        res.status(500).json({ error: 'Failed to fetch community member' });
    }
});

router.post('/:id/members', async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    console.log(`POST request for member: community ${id}, user ${userId}`);
    
    try {
        // Get community settings to check join method
        const settings = await communityApi.getCommunitySettings(id);
        
        if (!settings) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        console.log("Community settings:", settings);
        
        // Handle based on join method
        switch (settings.join_method) {
            case 'auto_approve':
                console.log("Auto-approving join request");
                // Directly add as member
                const newMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(newMember);
                
            case 'requires_approval':
                console.log("Creating pending join request");
                // Create a join request
                const joinRequest = await communityApi.createJoinRequest(id, userId);
                return res.status(202).json({
                    message: 'Join request submitted for approval',
                    request: joinRequest
                });
                
            case 'invite_only':
                console.log("Rejecting invite-only join request");
                return res.status(403).json({ error: 'This community is invite-only' });
                
            default:
                console.log("Using fallback auto-approve method");
                // Fallback to auto-approve for any unexpected values
                const fallbackMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(fallbackMember);
        }
    } catch (error) {
        console.error("Error joining community:", error);
        res.status(500).json({ error: 'Failed to join community' });
    }
});

router.put('/:id/members/:userId', isCommunityModerator, async (req, res) => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedMember = await communityApi.updateCommunityMemberRole(id, userId, role);
        if (!updatedMember) {
            return res.status(404).json({ error: 'Member not found' });
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

router.delete('/:id/members', async (req, res) => {
    const { id } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for current user to leave: community ${id}, user ${currentUserId}`);
    
    try {
        console.log(`Removing member ${currentUserId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, currentUserId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${currentUserId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

router.delete('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for specific member: community ${id}, target user ${userId}, current user ${currentUserId}`);
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
                [id, currentUserId]
            );
            
            if (!membership) {
                return res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            return res.status(500).json({ error: 'Failed to check moderator status' });
        } finally {
            if (conn) conn.release();
        }
    }
    
    try {
        console.log(`Removing member ${userId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, userId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${userId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Join Requests API
router.get('/:id/join-requests', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const requests = await communityApi.getJoinRequests(id);
        res.json(requests);
    } catch (error) {
        console.error("Error fetching join requests:", error);
        res.status(500).json({ error: 'Failed to fetch join requests' });
    }
});

router.get('/:id/join-requests/:requestId', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const request = await communityApi.getJoinRequest(requestId);
        if (!request) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.json(request);
    } catch (error) {
        console.error("Error fetching join request:", error);
        res.status(500).json({ error: 'Failed to fetch join request' });
    }
});

router.post('/:id/join-requests/:requestId/approve', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'approved');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request approved' });
    } catch (error) {
        console.error("Error approving join request:", error);
        res.status(500).json({ error: 'Failed to approve join request' });
    }
});

router.post('/:id/join-requests/:requestId/reject', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'rejected');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request rejected' });
    } catch (error) {
        console.error("Error rejecting join request:", error);
        res.status(500).json({ error: 'Failed to reject join request' });
    }
});

// Community About API
router.get('/:id/about', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const about = await communityApi.getCommunity(id);
        if (!about) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Format the response to include only the about information
        const aboutInfo = {
            id: about.id,
            name: about.name,
            description: about.description,
            privacy: about.privacy,
            created_at: about.created_at,
            member_count: await communityApi.getCommunityMemberCount(id)
        };
        
        res.json(aboutInfo);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
router.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const userCommunities = await communityApi.getUserCommunities(id);
        res.json(userCommunities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Discover Communities API
router.get('/discover/trending', async (req, res) => {
    try {
        const trendingCommunities = await communityApi.getTrendingCommunities();
        res.json(trendingCommunities);
    } catch (error) {
        console.error("Error fetching trending communities:", error);
        res.status(500).json({ error: 'Failed to fetch trending communities' });
    }
});

router.get('/discover/recommended', async (req, res) => {
    const userId = req.user?.id;
    try {
        const recommendedCommunities = await communityApi.getRecommendedCommunities(userId);
        res.json(recommendedCommunities);
    } catch (error) {
        console.error("Error fetching recommended communities:", error);
        res.status(500).json({ error: 'Failed to fetch recommended communities' });
    }
});

export {
    router,
    canViewCommunity,
    isCommunityModerator
};

================
File: routes/communities.js.new
================
import express from 'express';
const router = express.Router();
import dotenv from 'dotenv';
import pool from '../db/connection.js';
import communityApi from '../api/community/index.js';

dotenv.config();

// Check if user is a community moderator
const isCommunityModerator = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Moderator access required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        return res.status(500).json({ error: 'Failed to check moderator status' });
    } finally {
        if (conn) conn.release();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            return next();
        }
        
        // Private communities require membership
        if (!userId) {
            return res.status(401).json({ error: 'Authentication required' });
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Membership required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        return res.status(500).json({ error: 'Failed to check community access' });
    } finally {
        if (conn) conn.release();
    }
};

// Communities API
router.get('/', async (req, res) => {
    try {
        const searchTerm = req.query.search;
        
        if (searchTerm) {
            const communitiesList = await communityApi.searchCommunities(searchTerm);
            res.json(communitiesList);
        } else {
            const allCommunities = await communityApi.getCommunities();
            res.json(allCommunities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

router.get('/:id', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const community = await communityApi.getCommunity(id);
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

router.post('/', async (req, res) => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await communityApi.createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await communityApi.addCommunityMember(newCommunity.id, userId, 'moderator');
        
        // Activity logging is now handled within the community API functions
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

router.put('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    try {
        const updatedCommunity = await communityApi.updateCommunity(id, { name, description, privacy });
        if (!updatedCommunity) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

router.delete('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const success = await communityApi.deleteCommunity(id);
        if (!success) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
router.get('/:id/rules', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const rules = await communityApi.getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

router.post('/:id/rules', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { title, description } = req.body;
    try {
        const newRule = await communityApi.addCommunityRule(id, { title, description });
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

router.put('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    try {
        const updatedRule = await communityApi.updateCommunityRule(ruleId, { title, description });
        if (!updatedRule) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

router.delete('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    try {
        const success = await communityApi.deleteCommunityRule(ruleId);
        if (!success) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
router.get('/:id/settings', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const settings = await communityApi.getCommunitySettings(id);
        if (!settings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

router.put('/:id/settings', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { 
        allow_post_images, 
        allow_post_links, 
        join_method,
        require_post_approval,
        restricted_words,
        custom_theme_color,
        custom_banner_url,
        minimum_account_age_days,
        minimum_karma_required
    } = req.body;
    
    try {
        const updatedSettings = await communityApi.updateCommunitySettings(id, { 
            allow_post_images, 
            allow_post_links,
            join_method,
            require_post_approval,
            restricted_words,
            custom_theme_color,
            custom_banner_url,
            minimum_account_age_days,
            minimum_karma_required
        });
        
        if (!updatedSettings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
router.get('/:id/members', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const members = await communityApi.getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

// Get a specific member
router.get('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    console.log(`GET request for member: community ${id}, user ${userId}`);
    
    try {
        const member = await communityApi.getCommunityMember(id, userId);
        console.log("Member result:", member);
        
        if (!member) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        res.json(member);
    } catch (error) {
        console.error("Error fetching community member:", error);
        res.status(500).json({ error: 'Failed to fetch community member' });
    }
});

router.post('/:id/members', async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    console.log(`POST request for member: community ${id}, user ${userId}`);
    
    try {
        // Get community settings to check join method
        const settings = await communityApi.getCommunitySettings(id);
        
        if (!settings) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        console.log("Community settings:", settings);
        
        // Handle based on join method
        switch (settings.join_method) {
            case 'auto_approve':
                console.log("Auto-approving join request");
                // Directly add as member
                const newMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(newMember);
                
            case 'requires_approval':
                console.log("Creating pending join request");
                // Create a join request
                const joinRequest = await communityApi.createJoinRequest(id, userId);
                return res.status(202).json({
                    message: 'Join request submitted for approval',
                    request: joinRequest
                });
                
            case 'invite_only':
                console.log("Rejecting invite-only join request");
                return res.status(403).json({ error: 'This community is invite-only' });
                
            default:
                console.log("Using fallback auto-approve method");
                // Fallback to auto-approve for any unexpected values
                const fallbackMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(fallbackMember);
        }
    } catch (error) {
        console.error("Error joining community:", error);
        res.status(500).json({ error: 'Failed to join community' });
    }
});

router.put('/:id/members/:userId', isCommunityModerator, async (req, res) => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedMember = await communityApi.updateCommunityMemberRole(id, userId, role);
        if (!updatedMember) {
            return res.status(404).json({ error: 'Member not found' });
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

router.delete('/:id/members', async (req, res) => {
    const { id } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for current user to leave: community ${id}, user ${currentUserId}`);
    
    try {
        console.log(`Removing member ${currentUserId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, currentUserId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${currentUserId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

router.delete('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for specific member: community ${id}, target user ${userId}, current user ${currentUserId}`);
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
                [id, currentUserId]
            );
            
            if (!membership) {
                return res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            return res.status(500).json({ error: 'Failed to check moderator status' });
        } finally {
            if (conn) conn.release();
        }
    }
    
    try {
        console.log(`Removing member ${userId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, userId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${userId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Join Requests API
router.get('/:id/join-requests', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const requests = await communityApi.getJoinRequests(id);
        res.json(requests);
    } catch (error) {
        console.error("Error fetching join requests:", error);
        res.status(500).json({ error: 'Failed to fetch join requests' });
    }
});

router.get('/:id/join-requests/:requestId', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const request = await communityApi.getJoinRequest(requestId);
        if (!request) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.json(request);
    } catch (error) {
        console.error("Error fetching join request:", error);
        res.status(500).json({ error: 'Failed to fetch join request' });
    }
});

router.post('/:id/join-requests/:requestId/approve', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'approved');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request approved' });
    } catch (error) {
        console.error("Error approving join request:", error);
        res.status(500).json({ error: 'Failed to approve join request' });
    }
});

router.post('/:id/join-requests/:requestId/reject', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'rejected');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request rejected' });
    } catch (error) {
        console.error("Error rejecting join request:", error);
        res.status(500).json({ error: 'Failed to reject join request' });
    }
});

// Community About API
router.get('/:id/about', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const about = await communityApi.getCommunity(id);
        if (!about) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Format the response to include only the about information
        const aboutInfo = {
            id: about.id,
            name: about.name,
            description: about.description,
            privacy: about.privacy,
            created_at: about.created_at,
            member_count: await communityApi.getCommunityMemberCount(id)
        };
        
        res.json(aboutInfo);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
router.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const userCommunities = await communityApi.getUserCommunities(id);
        res.json(userCommunities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Discover Communities API
router.get('/discover/trending', async (req, res) => {
    try {
        const trendingCommunities = await communityApi.getTrendingCommunities();
        res.json(trendingCommunities);
    } catch (error) {
        console.error("Error fetching trending communities:", error);
        res.status(500).json({ error: 'Failed to fetch trending communities' });
    }
});

router.get('/discover/recommended', async (req, res) => {
    const userId = req.user?.id;
    try {
        const recommendedCommunities = await communityApi.getRecommendedCommunities(userId);
        res.json(recommendedCommunities);
    } catch (error) {
        console.error("Error fetching recommended communities:", error);
        res.status(500).json({ error: 'Failed to fetch recommended communities' });
    }
});

export {
    router,
    canViewCommunity,
    isCommunityModerator
};

================
File: routes/community-members.js
================
// API route handler for community members
// This adds endpoints to check current user membership and handle joining communities

const express = require('express');
const router = express.Router();
const { getCommunityMember } = require('../api/communities.ts');
const { addCommunityMember } = require('../api/communities.js');
const auth = require('../middleware/auth');

// Route to check if the current user is a member of a community
router.get('/:communityId/current', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Check if the user is a member
    const member = await getCommunityMember(communityId, userId);
    
    if (member) {
      return res.status(200).json({ 
        is_member: true,
        role: member.role,
        member_since: member.joined_at
      });
    } else {
      return res.status(200).json({ is_member: false });
    }
  } catch (error) {
    console.error('Error checking member status:', error);
    res.status(500).json({ error: 'Failed to check membership status' });
  }
});

// Route to add a member to a community
router.post('/:communityId', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Use our fixed version that handles table name issues
    const member = await addCommunityMember(communityId, userId);
    res.status(200).json(member);
  } catch (error) {
    console.error('Error in addMember:', error);
    res.status(500).json({ error: 'Failed to add community member' });
  }
});

module.exports = router;

================
File: routes/moderation.js
================
// backend/routes/moderation.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { isCommunityModerator, hasPermission } = require('../middleware/moderation');
const {
  // Moderator permissions
  getModeratorPermissions,
  setModeratorPermissions,
  
  // Community settings
  getEnhancedCommunitySettings,
  updateEnhancedCommunitySettings,
  
  // Post moderation
  getPostModerationStatus,
  addPostToModQueue,
  moderatePost,
  getPendingModQueue,
  
  // Moderation logs
  getModerationLogs,
  
  // Banning
  banUserFromCommunity,
  unbanUserFromCommunity,
  getBannedUsers
} = require('../api/moderation.ts.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Moderator permissions routes
router.get('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = await getModeratorPermissions(communityId, userId);
      res.json(permissions || { message: 'No specific permissions found' });
    } catch (error) {
      console.error('Error fetching moderator permissions:', error);
      res.status(500).json({ error: 'Failed to fetch moderator permissions' });
    }
  }
);

router.post('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = req.body;
      
      const updatedPermissions = await setModeratorPermissions(communityId, userId, permissions);
      res.json(updatedPermissions);
    } catch (error) {
      console.error('Error setting moderator permissions:', error);
      res.status(500).json({ error: 'Failed to set moderator permissions' });
    }
  }
);

// Community settings routes
router.get('/communities/:communityId/settings', 
  authenticateToken,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = await getEnhancedCommunitySettings(communityId);
      res.json(settings);
    } catch (error) {
      console.error('Error fetching community settings:', error);
      res.status(500).json({ error: 'Failed to fetch community settings' });
    }
  }
);

router.put('/communities/:communityId/settings', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_settings'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = req.body;
      
      const updatedSettings = await updateEnhancedCommunitySettings(communityId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating community settings:', error);
      res.status(500).json({ error: 'Failed to update community settings' });
    }
  }
);

// Post moderation routes
router.get('/communities/:communityId/mod-queue', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_posts'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const pendingPosts = await getPendingModQueue(communityId);
      res.json(pendingPosts);
    } catch (error) {
      console.error('Error fetching moderation queue:', error);
      res.status(500).json({ error: 'Failed to fetch moderation queue' });
    }
  }
);

router.post('/posts/:postId/moderate', 
  authenticateToken,
  async (req, res) => {
    try {
      const { postId } = req.params;
      const { action, reason } = req.body;
      const userId = req.user.id;
      
      // Get community ID from the post to check permissions
      const { getCommunityIdFromPost } = require('../api/community/community-core');
      const communityId = await getCommunityIdFromPost(postId);
      
      if (!communityId) {
        return res.status(404).json({ error: 'Post not found' });
      }
      
      // Check if user is a moderator with post management permissions
      const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
      
      if (!canManagePosts) {
        return res.status(403).json({ error: 'You do not have permission to moderate posts' });
      }
      
      if (action !== 'approve' && action !== 'reject') {
        return res.status(400).json({ error: 'Invalid action. Must be "approve" or "reject"' });
      }
      
      const result = await moderatePost(postId, userId, action, reason);
      res.json(result);
    } catch (error) {
      console.error('Error moderating post:', error);
      res.status(500).json({ error: 'Failed to moderate post' });
    }
  }
);

// Moderation logs routes
router.get('/communities/:communityId/logs', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const { limit = 50, offset = 0 } = req.query;
      
      const logs = await getModerationLogs(communityId, parseInt(limit), parseInt(offset));
      res.json(logs);
    } catch (error) {
      console.error('Error fetching moderation logs:', error);
      res.status(500).json({ error: 'Failed to fetch moderation logs' });
    }
  }
);

// User ban routes
router.get('/communities/:communityId/banned-users', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const bannedUsers = await getBannedUsers(communityId);
      res.json(bannedUsers);
    } catch (error) {
      console.error('Error fetching banned users:', error);
      res.status(500).json({ error: 'Failed to fetch banned users' });
    }
  }
);

router.post('/communities/:communityId/ban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason, duration } = req.body; // duration in days
      const bannedBy = req.user.id;
      
      const ban = await banUserFromCommunity(communityId, userId, bannedBy, reason, duration);
      res.json(ban);
    } catch (error) {
      console.error('Error banning user:', error);
      res.status(500).json({ error: 'Failed to ban user' });
    }
  }
);

router.post('/communities/:communityId/unban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason } = req.body;
      const unbannedBy = req.user.id;
      
      const result = await unbanUserFromCommunity(communityId, userId, unbannedBy, reason);
      
      if (result) {
        res.json({ message: 'User has been unbanned' });
      } else {
        res.status(404).json({ message: 'User was not banned' });
      }
    } catch (error) {
      console.error('Error unbanning user:', error);
      res.status(500).json({ error: 'Failed to unban user' });
    }
  }
);

// Add community member route with role assignment
router.post('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { addCommunityMember } = require('../api/community/community-members');
      const member = await addCommunityMember(communityId, userId, role);
      
      // If setting as moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error adding community member:', error);
      res.status(500).json({ error: 'Failed to add community member' });
    }
  }
);

// Update community member role
router.put('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { updateCommunityMemberRole } = require('../api/community/community-members');
      const member = await updateCommunityMemberRole(communityId, userId, role);
      
      // If promoting to moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error updating community member role:', error);
      res.status(500).json({ error: 'Failed to update community member role' });
    }
  }
);

module.exports = router;

================
File: routes/moderation.js.new
================
// backend/routes/moderation.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { isCommunityModerator, hasPermission } = require('../middleware/moderation');
const {
  // Moderator permissions
  getModeratorPermissions,
  setModeratorPermissions,
  
  // Community settings
  getEnhancedCommunitySettings,
  updateEnhancedCommunitySettings,
  
  // Post moderation
  getPostModerationStatus,
  addPostToModQueue,
  moderatePost,
  getPendingModQueue,
  
  // Moderation logs
  getModerationLogs,
  
  // Banning
  banUserFromCommunity,
  unbanUserFromCommunity,
  getBannedUsers
} = require('../api/moderation.ts.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Moderator permissions routes
router.get('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = await getModeratorPermissions(communityId, userId);
      res.json(permissions || { message: 'No specific permissions found' });
    } catch (error) {
      console.error('Error fetching moderator permissions:', error);
      res.status(500).json({ error: 'Failed to fetch moderator permissions' });
    }
  }
);

router.post('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = req.body;
      
      const updatedPermissions = await setModeratorPermissions(communityId, userId, permissions);
      res.json(updatedPermissions);
    } catch (error) {
      console.error('Error setting moderator permissions:', error);
      res.status(500).json({ error: 'Failed to set moderator permissions' });
    }
  }
);

// Community settings routes
router.get('/communities/:communityId/settings', 
  authenticateToken,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = await getEnhancedCommunitySettings(communityId);
      res.json(settings);
    } catch (error) {
      console.error('Error fetching community settings:', error);
      res.status(500).json({ error: 'Failed to fetch community settings' });
    }
  }
);

router.put('/communities/:communityId/settings', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_settings'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = req.body;
      
      const updatedSettings = await updateEnhancedCommunitySettings(communityId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating community settings:', error);
      res.status(500).json({ error: 'Failed to update community settings' });
    }
  }
);

// Post moderation routes
router.get('/communities/:communityId/mod-queue', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_posts'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const pendingPosts = await getPendingModQueue(communityId);
      res.json(pendingPosts);
    } catch (error) {
      console.error('Error fetching moderation queue:', error);
      res.status(500).json({ error: 'Failed to fetch moderation queue' });
    }
  }
);

router.post('/posts/:postId/moderate', 
  authenticateToken,
  async (req, res) => {
    try {
      const { postId } = req.params;
      const { action, reason } = req.body;
      const userId = req.user.id;
      
      // Get community ID from the post to check permissions
      const { getCommunityIdFromPost } = require('../api/community/community-core');
      const communityId = await getCommunityIdFromPost(postId);
      
      if (!communityId) {
        return res.status(404).json({ error: 'Post not found' });
      }
      
      // Check if user is a moderator with post management permissions
      const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
      
      if (!canManagePosts) {
        return res.status(403).json({ error: 'You do not have permission to moderate posts' });
      }
      
      if (action !== 'approve' && action !== 'reject') {
        return res.status(400).json({ error: 'Invalid action. Must be "approve" or "reject"' });
      }
      
      const result = await moderatePost(postId, userId, action, reason);
      res.json(result);
    } catch (error) {
      console.error('Error moderating post:', error);
      res.status(500).json({ error: 'Failed to moderate post' });
    }
  }
);

// Moderation logs routes
router.get('/communities/:communityId/logs', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const { limit = 50, offset = 0 } = req.query;
      
      const logs = await getModerationLogs(communityId, parseInt(limit), parseInt(offset));
      res.json(logs);
    } catch (error) {
      console.error('Error fetching moderation logs:', error);
      res.status(500).json({ error: 'Failed to fetch moderation logs' });
    }
  }
);

// User ban routes
router.get('/communities/:communityId/banned-users', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const bannedUsers = await getBannedUsers(communityId);
      res.json(bannedUsers);
    } catch (error) {
      console.error('Error fetching banned users:', error);
      res.status(500).json({ error: 'Failed to fetch banned users' });
    }
  }
);

router.post('/communities/:communityId/ban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason, duration } = req.body; // duration in days
      const bannedBy = req.user.id;
      
      const ban = await banUserFromCommunity(communityId, userId, bannedBy, reason, duration);
      res.json(ban);
    } catch (error) {
      console.error('Error banning user:', error);
      res.status(500).json({ error: 'Failed to ban user' });
    }
  }
);

router.post('/communities/:communityId/unban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason } = req.body;
      const unbannedBy = req.user.id;
      
      const result = await unbanUserFromCommunity(communityId, userId, unbannedBy, reason);
      
      if (result) {
        res.json({ message: 'User has been unbanned' });
      } else {
        res.status(404).json({ message: 'User was not banned' });
      }
    } catch (error) {
      console.error('Error unbanning user:', error);
      res.status(500).json({ error: 'Failed to unban user' });
    }
  }
);

// Add community member route with role assignment
router.post('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { addCommunityMember } = require('../api/community/community-members');
      const member = await addCommunityMember(communityId, userId, role);
      
      // If setting as moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error adding community member:', error);
      res.status(500).json({ error: 'Failed to add community member' });
    }
  }
);

// Update community member role
router.put('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { updateCommunityMemberRole } = require('../api/community/community-members');
      const member = await updateCommunityMemberRole(communityId, userId, role);
      
      // If promoting to moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error updating community member role:', error);
      res.status(500).json({ error: 'Failed to update community member role' });
    }
  }
);

module.exports = router;

================
File: routes/posts.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const posts = require('../api/posts.js.new');

// Middleware to check if the user is authenticated for protected routes
router.use(authenticateToken);

// Get all posts (with optional filtering)
router.get('/', async (req, res) => {
  await posts.getPosts(req, res);
});

// Get a specific post by ID
router.get('/:id', async (req, res) => {
  await posts.getPost(req, res);
});

// Get posts for a specific community
router.get('/community/:communityId', checkNotBanned, async (req, res) => {
  req.params.communityId = req.params.communityId;
  await posts.getCommunityPosts(req, res);
});

// Get posts for a specific user
router.get('/user/:userId', async (req, res) => {
  await posts.getUserPosts(req, res);
});

// Create a new post
router.post('/', authenticateToken, posts.canPostInCommunity, async (req, res) => {
  await posts.createPost(req, res);
});

// Update a post
router.put('/:id', authenticateToken, async (req, res) => {
  await posts.updatePost(req, res);
});

// Delete a post
router.delete('/:id', authenticateToken, async (req, res) => {
  await posts.deletePost(req, res);
});

module.exports = router;

================
File: routes/posts.js.new
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const posts = require('../api/posts.js.new');

// Middleware to check if the user is authenticated for protected routes
router.use(authenticateToken);

// Get all posts (with optional filtering)
router.get('/', async (req, res) => {
  await posts.getPosts(req, res);
});

// Get a specific post by ID
router.get('/:id', async (req, res) => {
  await posts.getPost(req, res);
});

// Get posts for a specific community
router.get('/community/:communityId', checkNotBanned, async (req, res) => {
  req.params.communityId = req.params.communityId;
  await posts.getCommunityPosts(req, res);
});

// Get posts for a specific user
router.get('/user/:userId', async (req, res) => {
  await posts.getUserPosts(req, res);
});

// Create a new post
router.post('/', authenticateToken, posts.canPostInCommunity, async (req, res) => {
  await posts.createPost(req, res);
});

// Update a post
router.put('/:id', authenticateToken, async (req, res) => {
  await posts.updatePost(req, res);
});

// Delete a post
router.delete('/:id', authenticateToken, async (req, res) => {
  await posts.deletePost(req, res);
});

module.exports = router;

================
File: routes/users.js
================
const express = require('express');
const router = express.Router();
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');
const { authenticateToken } = require('../middleware/auth');
const pool = require('../db/connection');

// Get all users
router.get('/', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.display_name,
         u.role, u.bio, u.avatar_url, u.profile_banner_url, u.website, u.location,
         u.is_verified, u.status, u.cake_day, u.last_active, u.created_at, u.updated_at,
         us.karma, us.posts_count, us.comments_count, us.upvotes_received, 
         us.downvotes_received, us.upvotes_given, us.downvotes_given, us.communities_joined
         FROM user u
         LEFT JOIN user_statistic us ON u.id = us.user_id`
      );
      
      // Remove sensitive information
      const users = rows.map(user => {
        const { password_hash, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      
      res.json(users);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user profile by ID
router.get('/:userId', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.display_name,
         u.role, u.bio, u.avatar_url, u.profile_banner_url, u.website, u.location,
         u.is_verified, u.status, u.cake_day, u.last_active, u.created_at, u.updated_at,
         us.karma, us.posts_count, us.comments_count, us.upvotes_received, 
         us.downvotes_received, us.upvotes_given, us.downvotes_given, us.communities_joined
         FROM user u
         LEFT JOIN user_statistic us ON u.id = us.user_id
         WHERE u.id = ?`,
        [req.params.userId]
      );
      
      if (rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      // Remove sensitive information
      const user = rows[0];
      delete user.password_hash;
      
      res.json(user);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user profile
router.put('/profile', authenticateToken, async (req, res) => {
  try {
    const { 
      username, 
      email, 
      first_name, 
      last_name, 
      display_name, 
      bio, 
      avatar_url, 
      profile_banner_url, 
      website, 
      location 
    } = req.body;
    
    const userId = req.user.id;
    
    // Validate input
    if (!username || !email) {
      return res.status(400).json({ error: 'Username and email are required' });
    }
    
    const connection = await pool.getConnection();
    
    try {
      // Check if username is already taken by another user
      const [existingUsers] = await connection.execute(
        'SELECT id FROM user WHERE username = ? AND id != ?',
        [username, userId]
      );
      
      if (existingUsers.length > 0) {
        return res.status(400).json({ error: 'Username is already taken' });
      }
      
      // Update user profile
      await connection.execute(
        `UPDATE user SET 
         username = ?, 
         email = ?, 
         first_name = ?,
         last_name = ?,
         display_name = ?,
         bio = ?, 
         avatar_url = ?,
         profile_banner_url = ?,
         website = ?,
         location = ?,
         updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [
          username, 
          email, 
          first_name || null, 
          last_name || null, 
          display_name || null, 
          bio || null, 
          avatar_url || null, 
          profile_banner_url || null, 
          website || null, 
          location || null, 
          userId
        ]
      );
      
      // Get updated user data
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.display_name,
         u.role, u.bio, u.avatar_url, u.profile_banner_url, u.website, u.location,
         u.is_verified, u.status, u.cake_day, u.last_active, u.created_at, u.updated_at,
         us.karma, us.posts_count, us.comments_count, us.upvotes_received, 
         us.downvotes_received, us.upvotes_given, us.downvotes_given, us.communities_joined
         FROM user u
         LEFT JOIN user_statistic us ON u.id = us.user_id
         WHERE u.id = ?`,
        [userId]
      );
      
      // Remove sensitive information
      const user = rows[0];
      delete user.password_hash;
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'UPDATE'),
          ?, 'user', NOW()
        )`,
        [uuidv4(), userId, userId]
      );
      
      res.json(user);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error updating user profile:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user statistics
router.get('/:userId/statistics', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT * FROM user_statistic WHERE user_id = ?`,
        [req.params.userId]
      );
      
      if (rows.length === 0) {
        return res.status(404).json({ error: 'User statistics not found' });
      }
      
      res.json(rows[0]);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user statistics:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user settings
router.get('/settings', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT * FROM user_setting WHERE user_id = ?`,
        [userId]
      );
      
      if (rows.length === 0) {
        // Create default settings if they don't exist
        const defaultSettings = {
          email_notifications: true,
          push_notifications: true,
          theme: 'light',
          content_filter: 'standard',
          allow_followers: true,
          display_online_status: true,
          language: 'en',
          timezone: 'UTC'
        };
        
        await connection.execute(
          `INSERT INTO user_setting (
            user_id, email_notifications, push_notifications, theme,
            content_filter, allow_followers, display_online_status,
            language, timezone
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            userId,
            defaultSettings.email_notifications ? 1 : 0,
            defaultSettings.push_notifications ? 1 : 0,
            defaultSettings.theme,
            defaultSettings.content_filter,
            defaultSettings.allow_followers ? 1 : 0,
            defaultSettings.display_online_status ? 1 : 0,
            defaultSettings.language,
            defaultSettings.timezone
          ]
        );
        
        return res.json(defaultSettings);
      }
      
      // Convert boolean fields from 0/1 to false/true
      const settings = rows[0];
      settings.email_notifications = !!settings.email_notifications;
      settings.push_notifications = !!settings.push_notifications;
      settings.allow_followers = !!settings.allow_followers;
      settings.display_online_status = !!settings.display_online_status;
      
      res.json(settings);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user settings:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user settings
router.put('/settings', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      email_notifications,
      push_notifications,
      theme,
      content_filter,
      allow_followers,
      display_online_status,
      language,
      timezone
    } = req.body;
    
    const connection = await pool.getConnection();
    
    try {
      // Check if settings exist
      const [existingSettings] = await connection.execute(
        `SELECT * FROM user_setting WHERE user_id = ?`,
        [userId]
      );
      
      if (existingSettings.length === 0) {
        // Create settings if they don't exist
        await connection.execute(
          `INSERT INTO user_setting (
            user_id, email_notifications, push_notifications, theme,
            content_filter, allow_followers, display_online_status,
            language, timezone
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            userId,
            email_notifications ? 1 : 0,
            push_notifications ? 1 : 0,
            theme || 'light',
            content_filter || 'standard',
            allow_followers ? 1 : 0,
            display_online_status ? 1 : 0,
            language || 'en',
            timezone || 'UTC'
          ]
        );
      } else {
        // Update existing settings
        await connection.execute(
          `UPDATE user_setting SET
            email_notifications = ?,
            push_notifications = ?,
            theme = ?,
            content_filter = ?,
            allow_followers = ?,
            display_online_status = ?,
            language = ?,
            timezone = ?,
            updated_at = CURRENT_TIMESTAMP
          WHERE user_id = ?`,
          [
            email_notifications ? 1 : 0,
            push_notifications ? 1 : 0,
            theme || 'light',
            content_filter || 'standard',
            allow_followers ? 1 : 0,
            display_online_status ? 1 : 0,
            language || 'en',
            timezone || 'UTC',
            userId
          ]
        );
      }
      
      // Get updated settings
      const [rows] = await connection.execute(
        `SELECT * FROM user_setting WHERE user_id = ?`,
        [userId]
      );
      
      // Convert boolean fields from 0/1 to false/true
      const settings = rows[0];
      settings.email_notifications = !!settings.email_notifications;
      settings.push_notifications = !!settings.push_notifications;
      settings.allow_followers = !!settings.allow_followers;
      settings.display_online_status = !!settings.display_online_status;
      
      res.json(settings);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error updating user settings:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user relationships (friends)
router.get('/:userId/friends', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      // Get accepted friends
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.display_name, u.avatar_url, ur.created_at as friendship_date
         FROM user_relationship ur
         JOIN user u ON (ur.related_user_id = u.id)
         WHERE ur.user_id = ? AND ur.relationship_type = 'friend' AND ur.status = 'accepted'
         UNION
         SELECT u.id, u.username, u.display_name, u.avatar_url, ur.created_at as friendship_date
         FROM user_relationship ur
         JOIN user u ON (ur.user_id = u.id)
         WHERE ur.related_user_id = ? AND ur.relationship_type = 'friend' AND ur.status = 'accepted'
         ORDER BY friendship_date DESC`,
        [req.params.userId, req.params.userId]
      );
      
      res.json(rows);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user friends:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Add friend request
router.post('/friends/:targetUserId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const targetUserId = req.params.targetUserId;
    
    // Prevent self-friending
    if (userId === targetUserId) {
      return res.status(400).json({ error: 'Cannot add yourself as a friend' });
    }
    
    const connection = await pool.getConnection();
    
    try {
      // Check if relationship already exists
      const [existingRelationship] = await connection.execute(
        `SELECT * FROM user_relationship 
         WHERE (user_id = ? AND related_user_id = ?) 
         OR (user_id = ? AND related_user_id = ?)
         AND relationship_type = 'friend'`,
        [userId, targetUserId, targetUserId, userId]
      );
      
      if (existingRelationship.length > 0) {
        return res.status(400).json({ 
          error: 'Relationship already exists', 
          status: existingRelationship[0].status 
        });
      }
      
      // Create friend request
      const relationshipId = uuidv4();
      await connection.execute(
        `INSERT INTO user_relationship (
          id, user_id, related_user_id, relationship_type, status, created_at
        ) VALUES (?, ?, ?, 'friend', 'pending', NOW())`,
        [relationshipId, userId, targetUserId]
      );
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'user_relationship', NOW()
        )`,
        [uuidv4(), userId, relationshipId]
      );
      
      res.status(201).json({ message: 'Friend request sent' });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error sending friend request:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Accept/reject friend request
router.put('/friends/:relationshipId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const relationshipId = req.params.relationshipId;
    const { status } = req.body; // 'accepted' or 'rejected'
    
    if (status !== 'accepted' && status !== 'rejected') {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    const connection = await pool.getConnection();
    
    try {
      // Check if relationship exists and user is the target
      const [relationship] = await connection.execute(
        `SELECT * FROM user_relationship 
         WHERE id = ? AND related_user_id = ? AND relationship_type = 'friend' AND status = 'pending'`,
        [relationshipId, userId]
      );
      
      if (relationship.length === 0) {
        return res.status(404).json({ error: 'Friend request not found' });
      }
      
      // Update relationship status
      await connection.execute(
        `UPDATE user_relationship SET status = ?, updated_at = NOW() WHERE id = ?`,
        [status, relationshipId]
      );
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'UPDATE'),
          ?, 'user_relationship', NOW()
        )`,
        [uuidv4(), userId, relationshipId]
      );
      
      res.json({ message: `Friend request ${status}` });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error updating friend request:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Remove friend
router.delete('/friends/:targetUserId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const targetUserId = req.params.targetUserId;
    
    const connection = await pool.getConnection();
    
    try {
      // Delete the relationship in both directions
      await connection.execute(
        `DELETE FROM user_relationship 
         WHERE ((user_id = ? AND related_user_id = ?) 
         OR (user_id = ? AND related_user_id = ?))
         AND relationship_type = 'friend'`,
        [userId, targetUserId, targetUserId, userId]
      );
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'DELETE'),
          ?, 'user_relationship', NOW()
        )`,
        [uuidv4(), userId, targetUserId]
      );
      
      res.json({ message: 'Friend removed' });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error removing friend:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user ID by username
router.get('/lookup/:username', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        'SELECT id FROM user WHERE username = ?',
        [req.params.username]
      );
      
      if (rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json({ id: rows[0].id });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error looking up user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user communities
router.get('/:userId/communities', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT c.id, c.name, c.description, cm.role, cm.joined_at
         FROM community_member cm
         JOIN community c ON cm.community_id = c.id
         WHERE cm.user_id = ?
         ORDER BY cm.joined_at DESC`,
        [req.params.userId]
      );
      
      res.json(rows);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user communities:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user activities
router.get('/:userId/activities', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT a.id, a.created_at, at.name as activity_type, ac.name as action,
         a.entity_id, a.entity_type, a.metadata
         FROM activity a
         JOIN activity_type at ON a.activity_type_id = at.id
         JOIN action ac ON a.action_id = ac.id
         WHERE a.user_id = ?
         ORDER BY a.created_at DESC
         LIMIT 50`,
        [req.params.userId]
      );
      
      res.json(rows);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;

================
File: routes/votes.js
================
const express = require('express');
const router = express.Router();
const { 
  voteOnPost, 
  voteOnComment, 
  getUserPostVote, 
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes
} = require('../api/votes.js.new');

// Middleware for authentication and ban checking
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');

// Vote on a post
router.post('/posts/:postId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { postId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnPost(userId, postId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on post:', error);
    res.status(400).json({ error: error.message });
  }
});

// Vote on a comment
router.post('/comments/:commentId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { commentId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnComment(userId, commentId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on comment:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a post
router.get('/posts/:postId/user', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserPostVote(userId, postId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user post vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a comment
router.get('/comments/:commentId/user', authenticateToken, async (req, res) => {
  try {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserCommentVote(userId, commentId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a post
router.get('/posts/:postId/counts', async (req, res) => {
  try {
    const { postId } = req.params;
    
    const counts = await getPostVoteCounts(postId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a comment
router.get('/comments/:commentId/counts', async (req, res) => {
  try {
    const { commentId } = req.params;
    
    const counts = await getCommentVoteCounts(commentId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get all votes for a user
router.get('/user/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own votes
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own votes' });
    }
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get current user's votes
router.get('/user', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;

================
File: routes/votes.js.new
================
const express = require('express');
const router = express.Router();
const { 
  voteOnPost, 
  voteOnComment, 
  getUserPostVote, 
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes
} = require('../api/votes.js.new');

// Middleware for authentication and ban checking
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');

// Vote on a post
router.post('/posts/:postId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { postId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnPost(userId, postId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on post:', error);
    res.status(400).json({ error: error.message });
  }
});

// Vote on a comment
router.post('/comments/:commentId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { commentId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnComment(userId, commentId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on comment:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a post
router.get('/posts/:postId/user', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserPostVote(userId, postId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user post vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a comment
router.get('/comments/:commentId/user', authenticateToken, async (req, res) => {
  try {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserCommentVote(userId, commentId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a post
router.get('/posts/:postId/counts', async (req, res) => {
  try {
    const { postId } = req.params;
    
    const counts = await getPostVoteCounts(postId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a comment
router.get('/comments/:commentId/counts', async (req, res) => {
  try {
    const { commentId } = req.params;
    
    const counts = await getCommentVoteCounts(commentId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get all votes for a user
router.get('/user/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own votes
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own votes' });
    }
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get current user's votes
router.get('/user', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;

================
File: test-api.js
================
const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
require('dotenv').config();

const app = express();
const PORT = 3001;

// Middleware
app.use(express.json());
app.use(cors());

// Database connection
const createConnection = async () => {
  return mysql.createConnection({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME
  });
};

// Simple health check endpoint
app.get('/', (req, res) => {
  res.json({ status: 'API is running' });
});

// Get all communities
app.get('/api/communities', async (req, res) => {
  try {
    const conn = await createConnection();
    const [communities] = await conn.query('SELECT * FROM community');
    await conn.end();
    res.json(communities);
  } catch (error) {
    console.error('Error fetching communities:', error);
    res.status(500).json({ error: 'Failed to fetch communities' });
  }
});

// Get a single community
app.get('/api/communities/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [communities] = await conn.query('SELECT * FROM community WHERE id = ?', [id]);
    await conn.end();
    
    if (communities.length === 0) {
      return res.status(404).json({ error: 'Community not found' });
    }
    
    res.json(communities[0]);
  } catch (error) {
    console.error('Error fetching community:', error);
    res.status(500).json({ error: 'Failed to fetch community' });
  }
});

// Get community members
app.get('/api/communities/:id/members', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [members] = await conn.query(
      `SELECT cm.*, u.username 
       FROM community_member cm
       JOIN user u ON cm.user_id = u.id
       WHERE cm.community_id = ?`, 
      [id]
    );
    await conn.end();
    res.json(members);
  } catch (error) {
    console.error('Error fetching community members:', error);
    res.status(500).json({ error: 'Failed to fetch community members' });
  }
});

// Get community rules
app.get('/api/communities/:id/rules', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [rules] = await conn.query('SELECT * FROM community_rule WHERE community_id = ?', [id]);
    await conn.end();
    res.json(rules);
  } catch (error) {
    console.error('Error fetching community rules:', error);
    res.status(500).json({ error: 'Failed to fetch community rules' });
  }
});

// Get community settings
app.get('/api/communities/:id/settings', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [settings] = await conn.query('SELECT * FROM community_setting WHERE community_id = ?', [id]);
    await conn.end();
    
    if (settings.length === 0) {
      return res.status(404).json({ error: 'Settings not found' });
    }
    
    res.json(settings[0]);
  } catch (error) {
    console.error('Error fetching community settings:', error);
    res.status(500).json({ error: 'Failed to fetch community settings' });
  }
});

// Get posts for a community
app.get('/api/posts', async (req, res) => {
  try {
    const { communityId } = req.query;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID required' });
    }
    
    const conn = await createConnection();
    const [posts] = await conn.query(
      `SELECT p.*, u.username 
       FROM post p
       JOIN user u ON p.user_id = u.id
       WHERE p.community_id = ?
       ORDER BY p.created_at DESC`, 
      [communityId]
    );
    await conn.end();
    res.json(posts);
  } catch (error) {
    console.error('Error fetching posts:', error);
    res.status(500).json({ error: 'Failed to fetch posts' });
  }
});

// Auth/me mock endpoint
app.get('/api/auth/me', (req, res) => {
  // Return a mock user for testing
  res.json({
    id: '123',
    username: 'testuser',
    email: 'test@example.com',
    role: 'user'
  });
});

// Activity mock endpoint
app.get('/api/activity/community/:id', (req, res) => {
  // Return empty activity array 
  res.json([]);
});

// Start the server
app.listen(PORT, () => {
  console.log(`Test API server running on port ${PORT}`);
});

================
File: testServer.js
================
const express = require('express');
const cors = require('cors');
const pool = require('./dist/db/connection');

const app = express();
const port = 3001;

// Middlewares
app.use(express.json());
app.use(cors());

// Test database connection
app.get('/api/test', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    const [rows] = await connection.query('SELECT 1 as test');
    connection.release();
    res.json({ message: 'Database connection successful', data: rows });
  } catch (error) {
    console.error('Database connection error:', error);
    res.status(500).json({ error: 'Database connection failed', details: error.message });
  }
});

// API routes
app.get('/api/communities', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    // Try both singular and plural table names
    let rows;
    try {
      [rows] = await connection.query('SELECT * FROM community');
    } catch (err) {
      // If singular name fails, try plural
      [rows] = await connection.query('SELECT * FROM communities');
    }
    connection.release();
    res.json(rows);
  } catch (error) {
    console.error('Error fetching communities:', error);
    res.status(500).json({ error: 'Failed to fetch communities', details: error.message });
  }
});

// Auth test endpoint
app.get('/api/auth/me', (req, res) => {
  // A simple mocked response for testing
  res.json({
    id: '1',
    username: 'testuser',
    email: 'test@example.com',
    role: 'user'
  });
});

// Start the server
app.listen(port, () => {
  console.log(`Backend test server is running on http://localhost:${port}`);
});

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["*.ts", "api/**/*.ts", "db/**/*.ts", "middleware/**/*.ts", "routes/**/*.ts", "types/**/*.ts"],
  "files": ["index.ts"]
}

================
File: types/index.ts
================
export interface ActivityOptions {
  limit?: number;
  offset?: number;
  activityType?: string;
  actionType?: string;
  entityType?: string;
  startDate?: string;
  endDate?: string;
}

export interface ActivityData {
  userId: string;
  activityType: string;
  actionType: string;
  entityId?: string;
  entityType?: string;
  metadata?: any;
  ipAddress?: string;
  userAgent?: string;
}

export interface Activity {
  id: string;
  user_id: string;
  activity_type_id: string;
  action_id: string;
  entity_id?: string | null;
  entity_type?: string | null;
  metadata?: string | null;
  created_at: Date;
  entity_details?: any;
}

export interface ActivityType {
  id: string;
  name: string;
}

export interface ActionType {
  id: string;
  name: string;
}

export interface ModeratorPermission {
  community_id: string;
  user_id: string;
  can_manage_settings: boolean;
  can_manage_members: boolean;
  can_manage_posts: boolean;
  can_manage_comments: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface ModeratorPermissionInput {
  can_manage_settings?: boolean;
  can_manage_members?: boolean;
  can_manage_posts?: boolean;
  can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
  community_id: string;
  allow_post_images: boolean;
  allow_post_links: boolean;
  require_post_approval: boolean;
  restricted_words: string | null;
  custom_theme_color: string | null;
  custom_banner_url: string | null;
  minimum_account_age_days: number;
  minimum_karma_required: number;
  updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
  allow_post_images?: boolean;
  allow_post_links?: boolean;
  require_post_approval?: boolean;
  restricted_words?: string;
  custom_theme_color?: string;
  custom_banner_url?: string;
  minimum_account_age_days?: number;
  minimum_karma_required?: number;
}

export interface PostModeration {
  post_id: string;
  status: 'pending' | 'approved' | 'rejected';
  moderator_id: string | null;
  reason: string | null;
  moderated_at: Date | null;
  created_at: Date;
}

export interface ModerationLog {
  id: string;
  community_id: string;
  moderator_id: string;
  action_type: string;
  entity_type: string;
  entity_id: string;
  reason: string | null;
  metadata: any | null;
  created_at: Date;
}

export interface BannedUser {
  community_id: string;
  user_id: string;
  reason: string | null;
  banned_by: string;
  expires_at: Date | null;
  created_at: Date;
}

// Express request with user
export interface AuthRequest extends Express.Request {
  user: {
    id: string;
    username: string;
    email: string;
    role: string;
  };
}



================================================================
End of Codebase
================================================================
