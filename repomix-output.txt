This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
backend/.env
backend/.env.backup
backend/activity-handler.js
backend/api/activity.js
backend/api/activity.ts
backend/api/auth.js
backend/api/auth.js.new
backend/api/auth.ts
backend/api/auth.ts.new
backend/api/comments.js
backend/api/comments.js.new
backend/api/comments.ts
backend/api/communities.js
backend/api/communities.js.new
backend/api/communities.js.new.part2
backend/api/communities.ts
backend/api/communities.ts.new
backend/api/community_fix.js
backend/api/community/community-core.js
backend/api/community/community-members.js
backend/api/community/community-requests.js
backend/api/community/community-rules.js
backend/api/community/community-search.js
backend/api/community/community-settings.js
backend/api/community/index.js
backend/api/community/README.md
backend/api/moderation.ts
backend/api/moderation.ts.new
backend/api/posts_enhanced.js
backend/api/posts.js
backend/api/posts.js.new
backend/api/posts.ts
backend/api/routes/communities.js
backend/api/routes/community-members.js
backend/api/users.ts
backend/api/votes.js
backend/api/votes.js.new
backend/api/votes.ts
backend/check-community.js
backend/check-tables.js
backend/db/add_admin_user.js
backend/db/apply_auth_schema.js
backend/db/apply_comments_schema.js
backend/db/apply_community_updates.js
backend/db/apply_moderator_schema.js
backend/db/apply_new_schema.js
backend/db/apply_user_auth_schema.js
backend/db/apply_user_statistics_schema.js
backend/db/apply_votes_schema.js
backend/db/comments_schema_updates.sql
backend/db/community_schema_updates.sql
backend/db/connection.d.ts
backend/db/connection.js
backend/db/connection.ts
backend/db/fetch_usernames.js
backend/db/fix_community_api.js
backend/db/fix_community_join_request.js
backend/db/fix_community_join_request.sql
backend/db/fix_community_join_table.bat
backend/db/fix_join_request_name.js
backend/db/fix_join_request.bat
backend/db/fixed_schema.sql
backend/db/generate_sample_data.js
backend/db/init_schema.js
backend/db/init.js
backend/db/migrate_data.js
backend/db/migrate_database.bat
backend/db/moderator_schema_updates.sql
backend/db/new_schema.sql
backend/db/README_DATABASE_REFACTORING.md
backend/db/schema.sql
backend/db/seed_communities.js
backend/db/simple_schema.sql
backend/db/update_auth_files.js
backend/db/update_connection.js
backend/db/user_auth_schema.sql
backend/db/user_statistics_schema.sql
backend/db/votes_schema_update.sql
backend/fix_moderator_usernames.js
backend/fix-table-names.js
backend/index.js
backend/index.ts
backend/middleware/activity.js
backend/middleware/auth.js
backend/middleware/moderation.js
backend/middleware/moderation.js.new
backend/package.json
backend/routes/activity.js
backend/routes/auth.js
backend/routes/auth.js.new
backend/routes/comments.js
backend/routes/comments.js.new
backend/routes/communities.js
backend/routes/communities.js.new
backend/routes/community-members.js
backend/routes/moderation.js
backend/routes/moderation.js.new
backend/routes/posts.js
backend/routes/posts.js.new
backend/routes/users.js
backend/routes/votes.js
backend/routes/votes.js.new
backend/test-api.js
backend/testServer.js
backend/tsconfig.json
backend/types/index.ts
eslint.config.js
index.html
package.json
postcss.config.js
REFACTORING.md
src/api/activities.ts
src/api/comments.ts
src/api/communities-fix.ts
src/api/communities.ts
src/api/compatibility.ts
src/api/mockData.ts
src/api/moderation.ts
src/api/posts.ts
src/api/users.ts
src/api/votes.ts
src/App.tsx
src/components/ActivityHistory.tsx
src/components/ActivityHistory.tsxold
src/components/CommentItem.tsx
src/components/CommentSection.tsx
src/components/CommunityAbout.tsx
src/components/CommunityCard.tsx
src/components/CommunityDiscovery.tsx
src/components/CommunityDiscoverySidebar.tsx
src/components/CommunityHeader.tsx
src/components/CommunityInfo.tsx
src/components/CommunityList.tsx
src/components/CommunityModControls.tsx
src/components/CommunityRules.tsx
src/components/CommunitySearch.tsx
src/components/CommunitySettings.tsx
src/components/CommunitySidebar.tsx
src/components/CreateCommunityModal.tsx
src/components/CreatePostModal.tsx
src/components/EditProfileModal.tsx
src/components/JoinCommunityButton.tsx
src/components/ModeratorDashboard.tsx
src/components/Navbar.tsx
src/components/Post.tsx
src/components/PostCreationForm.tsx
src/components/PostItem.tsx
src/components/PostList.tsx
src/components/ProfileActions.tsx
src/components/Sidebar.tsx
src/components/UserInfo.tsx
src/components/UserPosts.tsx
src/context/AuthContext.tsx
src/context/CommunityContext.tsx
src/debug/ModeratorDebug.tsx
src/index.css
src/main.tsx
src/pages/Communities.tsx
src/pages/Community.tsx
src/pages/CommunityModeration.tsx
src/pages/Home.tsx
src/pages/Login.tsx
src/pages/PostDetail.tsx
src/pages/Profile.tsx
src/pages/Register.tsx
src/routes/index.tsx
src/types.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
vite.config.ts.timestamp-1740451079238-bcbb258007fe8.mjs

================================================================
Files
================================================================

================
File: .gitignore
================
# Logs
logs
ARCHIVED
.git_disabled
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
ARCHIVED
.git_disabled

================
File: backend/.env
================
API_KEY=AIzaSyCqBgYt00ik2BzpxDKz2b6aNHK6yt2cdeE
DB_HOST=68.146.102.33
DB_PORT=3306
DB_USER=rumfornew2
DB_PASSWORD=Oswald1986!
DB_NAME=rumfornew2
JWT_SECRET=rumfor-secret-key-for-jwt-authentication

================
File: backend/.env.backup
================
API_KEY=AIzaSyCqBgYt00ik2BzpxDKz2b6aNHK6yt2cdeE
DB_HOST=192.168.0.139
DB_PORT=3306
DB_USER=root
DB_PASSWORD=Oswald1986!
DB_NAME=rumfor1
JWT_SECRET=rumfor-secret-key-for-jwt-authentication

================
File: backend/activity-handler.js
================
// Simple activity endpoint handler that works with singular table names
const express = require('express');
const router = express.Router();
const mysql = require('mysql2/promise');
require('dotenv').config();

// Create a database connection pool
const pool = mysql.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 5
});

/**
 * @route GET /api/activity/community/:communityId
 * @desc Get activities for a specific community
 */
router.get('/community/:communityId', async (req, res) => {
  try {
    const { communityId } = req.params;
    
    // Extract query parameters
    const limit = parseInt(req.query.limit || '10', 10);
    const offset = parseInt(req.query.offset || '0', 10);
    
    // Just return minimum data for now
    res.json([]);
  } catch (error) {
    console.error('Error fetching community activities:', error);
    res.status(500).json({ error: 'Failed to fetch community activities' });
  }
});

module.exports = router;

================
File: backend/api/activity.js
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

/**
 * Get activities for a specific user
 * @param {string} userId - The user ID to get activities for
 * @param {Object} options - Query options
 * @param {number} options.limit - Maximum number of activities to return
 * @param {number} options.offset - Number of activities to skip
 * @param {string} options.activityType - Filter by activity type
 * @param {string} options.actionType - Filter by action type
 * @param {string} options.entityType - Filter by entity type
 * @param {string} options.startDate - Filter by start date (ISO format)
 * @param {string} options.endDate - Filter by end date (ISO format)
 * @returns {Promise<Array>} - Array of activities
 */
async function getUserActivities(userId, options = {}) {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      WHERE a.user_id = ?
    `;
    
    const queryParams = [userId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit), parseInt(offset));
    
    const activities = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(activities)) {
      for (let activity of activities) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = null;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof activities);
    }
    
    return activities;
  } catch (error) {
    console.error("Error fetching user activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific community
 * @param {string} communityId - The community ID to get activities for
 * @param {Object} options - Query options
 * @param {number} options.limit - Maximum number of activities to return
 * @param {number} options.offset - Number of activities to skip
 * @param {string} options.activityType - Filter by activity type
 * @param {string} options.actionType - Filter by action type
 * @param {string} options.entityType - Filter by entity type
 * @param {string} options.startDate - Filter by start date (ISO format)
 * @param {string} options.endDate - Filter by end date (ISO format)
 * @returns {Promise<Array>} - Array of activities
 */
async function getCommunityActivities(communityId, options = {}) {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'community' AND a.entity_id = ?) OR
        (a.entity_type = 'post' AND a.entity_id IN (
          SELECT id FROM post WHERE community_id = ?
        )) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT c.id FROM comment c
          JOIN post p ON c.post_id = p.id
          WHERE p.community_id = ?
        ))
      )
    `;
    
    const queryParams = [communityId, communityId, communityId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit), parseInt(offset));
    
    const activities = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(activities)) {
      for (let activity of activities) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = null;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof activities);
    }
    
    return activities;
  } catch (error) {
    console.error("Error fetching community activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific post
 * @param {string} postId - The post ID to get activities for
 * @param {Object} options - Query options
 * @param {number} options.limit - Maximum number of activities to return
 * @param {number} options.offset - Number of activities to skip
 * @returns {Promise<Array>} - Array of activities
 */
async function getPostActivities(postId, options = {}) {
  const { limit = 20, offset = 0 } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'post' AND a.entity_id = ?) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT id FROM comment WHERE post_id = ?
        ))
      )
      ORDER BY a.created_at DESC
      LIMIT ? OFFSET ?
    `;
    
    const activities = await conn.query(query, [postId, postId, parseInt(limit), parseInt(offset)]);
    
    // Enrich activities with entity details
    if (Array.isArray(activities)) {
      for (let activity of activities) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = null;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof activities);
    }
    
    return activities;
  } catch (error) {
    console.error("Error fetching post activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all activity types
 * @returns {Promise<Array>} - Array of activity types
 */
async function getActivityTypes() {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const activityTypes = await conn.query(
      "SELECT * FROM activity_type ORDER BY name"
    );
    
    return activityTypes || [];
  } catch (error) {
    console.error("Error fetching activity types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all action types
 * @returns {Promise<Array>} - Array of action types
 */
async function getActionTypes() {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const actionTypes = await conn.query(
      "SELECT * FROM action ORDER BY name"
    );
    
    return actionTypes || [];
  } catch (error) {
    console.error("Error fetching action types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Log an activity
 * @param {Object} activityData - Activity data
 * @param {string} activityData.userId - User ID
 * @param {string} activityData.activityType - Activity type name
 * @param {string} activityData.actionType - Action type name
 * @param {string} activityData.entityId - Entity ID
 * @param {string} activityData.entityType - Entity type
 * @param {Object} activityData.metadata - Additional metadata
 * @param {string} activityData.ipAddress - IP address
 * @param {string} activityData.userAgent - User agent
 * @returns {Promise<Object>} - Created activity
 */
async function logActivity(activityData) {
  if (!activityData || !activityData.userId) {
    console.warn("Attempted to log activity without user ID:", activityData);
    return null;
  }
  
  const {
    userId,
    activityType,
    actionType,
    entityId,
    entityType,
    metadata,
    ipAddress,
    userAgent
  } = activityData;

  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get activity type ID
    const [activityTypeRecord] = await conn.query(
      "SELECT id FROM activity_type WHERE name = ?",
      [activityType]
    );
    
    if (!activityTypeRecord) {
      // Create the activity type if it doesn't exist
      console.warn(`Activity type '${activityType}' not found, creating it.`);
      const activityTypeId = uuidv4();
      await conn.query(
        "INSERT INTO activity_type (id, name) VALUES (?, ?)",
        [activityTypeId, activityType]
      );
      activityTypeRecord = { id: activityTypeId };
    }
    
    // Get action type ID
    const [actionTypeRecord] = await conn.query(
      "SELECT id FROM action WHERE name = ?",
      [actionType]
    );
    
    if (!actionTypeRecord) {
      // Create the action type if it doesn't exist
      console.warn(`Action type '${actionType}' not found, creating it.`);
      const actionTypeId = uuidv4();
      await conn.query(
        "INSERT INTO action (id, name) VALUES (?, ?)",
        [actionTypeId, actionType]
      );
      actionTypeRecord = { id: actionTypeId };
    }
    
    // Create activity
    const activityId = uuidv4();
    
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, 
        metadata, ip_address, user_agent
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        activityId,
        userId,
        activityTypeRecord.id,
        actionTypeRecord.id,
        entityId,
        entityType,
        metadata ? JSON.stringify(metadata) : null,
        ipAddress,
        userAgent
      ]
    );
    
    // Get the created activity
    const [activity] = await conn.query(
      `SELECT a.*, at.name as activity_type_name, act.name as action_name
       FROM activity a
       JOIN activity_type at ON a.activity_type_id = at.id
       JOIN action act ON a.action_id = act.id
       WHERE a.id = ?`,
      [activityId]
    );
    
    return activity;
  } catch (error) {
    console.error("Error logging activity:", error);
    // Don't throw - we don't want activity logging to break the application
    return null;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get entity details based on entity ID and type
 * @param {Object} conn - Database connection
 * @param {string} entityId - Entity ID
 * @param {string} entityType - Entity type
 * @returns {Promise<Object>} - Entity details
 */
async function getEntityDetails(conn, entityId, entityType) {
  if (!entityId || !entityType) {
    return null;
  }
  
  try {
    switch (entityType) {
      case 'post': {
        const [post] = await conn.query(
          `SELECT p.id, p.title, p.content, p.community_id, c.name as community_name, u.username
           FROM post p
           LEFT JOIN community c ON p.community_id = c.id
           LEFT JOIN user u ON p.user_id = u.id
           WHERE p.id = ?`,
          [entityId]
        );
        return post;
      }
      case 'comment': {
        const [comment] = await conn.query(
          `SELECT c.id, c.content, c.post_id, p.title as post_title, u.username
           FROM comment c
           LEFT JOIN post p ON c.post_id = p.id
           LEFT JOIN user u ON c.user_id = u.id
           WHERE c.id = ?`,
          [entityId]
        );
        return comment;
      }
      case 'community': {
        const [community] = await conn.query(
          "SELECT id, name, description FROM community WHERE id = ?",
          [entityId]
        );
        return community;
      }
      case 'user': {
        const [user] = await conn.query(
          "SELECT id, username, display_name FROM user WHERE id = ?",
          [entityId]
        );
        return user;
      }
      default:
        return null;
    }
  } catch (error) {
    console.error(`Error getting ${entityType} details:`, error);
    return null;
  }
}

module.exports = {
  getUserActivities,
  getCommunityActivities,
  getPostActivities,
  getActivityTypes,
  getActionTypes,
  logActivity
};

================
File: backend/api/activity.ts
================
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection';
import type { ActivityOptions, ActivityData, Activity, ActivityType, ActionType } from '../types/index';

// Custom type for activity row data
interface ActivityRow {
  entity_id?: string;
  entity_type?: string;
  entity_details?: any;
  [key: string]: any;
}

/**
 * Get activities for a specific user
 */
export async function getUserActivities(userId: string, options: ActivityOptions = {}): Promise<Activity[]> {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      WHERE a.user_id = ?
    `;
    
    const queryParams: any[] = [userId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit.toString()), parseInt(offset.toString()));
    
    const [rows] = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(rows)) {
      for (let activity of rows as ActivityRow[]) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = undefined;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof rows);
    }
    
    return rows as Activity[];
  } catch (error) {
    console.error("Error fetching user activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific community
 */
export async function getCommunityActivities(communityId: string, options: ActivityOptions = {}): Promise<Activity[]> {
  const {
    limit = 20,
    offset = 0,
    activityType,
    actionType,
    entityType,
    startDate,
    endDate
  } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'community' AND a.entity_id = ?) OR
        (a.entity_type = 'post' AND a.entity_id IN (
          SELECT id FROM post WHERE community_id = ?
        )) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT c.id FROM comment c
          JOIN post p ON c.post_id = p.id
          WHERE p.community_id = ?
        ))
      )
    `;
    
    const queryParams: any[] = [communityId, communityId, communityId];
    
    if (activityType) {
      query += " AND at.name = ?";
      queryParams.push(activityType);
    }
    
    if (actionType) {
      query += " AND act.name = ?";
      queryParams.push(actionType);
    }
    
    if (entityType) {
      query += " AND a.entity_type = ?";
      queryParams.push(entityType);
    }
    
    if (startDate) {
      query += " AND a.created_at >= ?";
      queryParams.push(startDate);
    }
    
    if (endDate) {
      query += " AND a.created_at <= ?";
      queryParams.push(endDate);
    }
    
    query += " ORDER BY a.created_at DESC LIMIT ? OFFSET ?";
    queryParams.push(parseInt(limit.toString()), parseInt(offset.toString()));
    
    const [rows] = await conn.query(query, queryParams);
    
    // Enrich activities with entity details
    if (Array.isArray(rows)) {
      for (let activity of rows as ActivityRow[]) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = undefined;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof rows);
    }
    
    return rows as Activity[];
  } catch (error) {
    console.error("Error fetching community activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get activities for a specific post
 */
export async function getPostActivities(postId: string, options: ActivityOptions = {}): Promise<Activity[]> {
  const { limit = 20, offset = 0 } = options;

  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = `
      SELECT a.*, at.name as activity_type_name, act.name as action_name, u.username
      FROM activity a
      JOIN activity_type at ON a.activity_type_id = at.id
      JOIN action act ON a.action_id = act.id
      JOIN user u ON a.user_id = u.id
      WHERE (
        (a.entity_type = 'post' AND a.entity_id = ?) OR
        (a.entity_type = 'comment' AND a.entity_id IN (
          SELECT id FROM comment WHERE post_id = ?
        ))
      )
      ORDER BY a.created_at DESC
      LIMIT ? OFFSET ?
    `;
    
    const [rows] = await conn.query(query, [postId, postId, parseInt(limit.toString()), parseInt(offset.toString())]);
    
    // Enrich activities with entity details
    if (Array.isArray(rows)) {
      for (let activity of rows as ActivityRow[]) {
        if (activity && activity.entity_id && activity.entity_type) {
          try {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            activity.entity_details = entityDetails;
          } catch (detailsError) {
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
            activity.entity_details = undefined;
          }
        }
      }
    } else {
      console.warn("Expected activities array but received:", typeof rows);
    }
    
    return rows as Activity[];
  } catch (error) {
    console.error("Error fetching post activities:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all activity types
 */
export async function getActivityTypes(): Promise<ActivityType[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [rows] = await conn.query("SELECT * FROM activity_type ORDER BY name");
    
    return rows as ActivityType[];
  } catch (error) {
    console.error("Error fetching activity types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get all action types
 */
export async function getActionTypes(): Promise<ActionType[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [rows] = await conn.query("SELECT * FROM action ORDER BY name");
    
    return rows as ActionType[];
  } catch (error) {
    console.error("Error fetching action types:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Log an activity
 */
export async function logActivity(activityData: ActivityData): Promise<Activity | null> {
  if (!activityData || !activityData.userId) {
    console.warn("Attempted to log activity without user ID:", activityData);
    return null;
  }
  
  const {
    userId,
    activityType,
    actionType,
    entityId,
    entityType,
    metadata,
    ipAddress,
    userAgent
  } = activityData;

  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get activity type ID
    const [activityTypeRows] = await conn.query(
      "SELECT id FROM activity_type WHERE name = ?",
      [activityType]
    );
    
    let activityTypeId: string;
    if (!activityTypeRows || (Array.isArray(activityTypeRows) && activityTypeRows.length === 0)) {
      // Create the activity type if it doesn't exist
      console.warn(`Activity type '${activityType}' not found, creating it.`);
      activityTypeId = uuidv4();
      await conn.query(
        "INSERT INTO activity_type (id, name) VALUES (?, ?)",
        [activityTypeId, activityType]
      );
    } else {
      // Access as object with indexed property
      const rows = activityTypeRows as any[];
      activityTypeId = rows[0]['id'];
    }
    
    // Get action type ID
    const [actionTypeRows] = await conn.query(
      "SELECT id FROM action WHERE name = ?",
      [actionType]
    );
    
    let actionTypeId: string;
    if (!actionTypeRows || (Array.isArray(actionTypeRows) && actionTypeRows.length === 0)) {
      // Create the action type if it doesn't exist
      console.warn(`Action type '${actionType}' not found, creating it.`);
      actionTypeId = uuidv4();
      await conn.query(
        "INSERT INTO action (id, name) VALUES (?, ?)",
        [actionTypeId, actionType]
      );
    } else {
      // Access as object with indexed property
      const rows = actionTypeRows as any[];
      actionTypeId = rows[0]['id'];
    }
    
    // Create activity
    const activityId = uuidv4();
    
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, 
        metadata, ip_address, user_agent
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        activityId,
        userId,
        activityTypeId,
        actionTypeId,
        entityId,
        entityType,
        metadata ? JSON.stringify(metadata) : null,
        ipAddress,
        userAgent
      ]
    );
    
    // Get the created activity
    const [activityRows] = await conn.query(
      `SELECT a.*, at.name as activity_type_name, act.name as action_name
       FROM activity a
       JOIN activity_type at ON a.activity_type_id = at.id
       JOIN action act ON a.action_id = act.id
       WHERE a.id = ?`,
      [activityId]
    );
    
    return Array.isArray(activityRows) && activityRows.length > 0 ? activityRows[0] as Activity : null;
  } catch (error) {
    console.error("Error logging activity:", error);
    // Don't throw - we don't want activity logging to break the application
    return null;
  } finally {
    if (conn) conn.release();
  }
}

/**
 * Get entity details based on entity ID and type
 */
async function getEntityDetails(conn: any, entityId: string, entityType: string): Promise<any | null> {
  if (!entityId || !entityType) {
    return null;
  }
  
  try {
    switch (entityType) {
      case 'post': {
        const [rows] = await conn.query(
          `SELECT p.id, p.title, p.content, p.community_id, c.name as community_name, u.username
           FROM post p
           LEFT JOIN community c ON p.community_id = c.id
           LEFT JOIN user u ON p.user_id = u.id
           WHERE p.id = ?`,
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      case 'comment': {
        const [rows] = await conn.query(
          `SELECT c.id, c.content, c.post_id, p.title as post_title, u.username
           FROM comment c
           LEFT JOIN post p ON c.post_id = p.id
           LEFT JOIN user u ON c.user_id = u.id
           WHERE c.id = ?`,
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      case 'community': {
        const [rows] = await conn.query(
          "SELECT id, name, description FROM community WHERE id = ?",
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      case 'user': {
        const [rows] = await conn.query(
          "SELECT id, username, display_name FROM user WHERE id = ?",
          [entityId]
        );
        return Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      }
      default:
        return null;
    }
  } catch (error) {
    console.error(`Error getting ${entityType} details:`, error);
    return null;
  }
}

================
File: backend/api/auth.js
================
// Updated auth.js for the new database schema
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');
const { logActivity } = require('./activity.js');

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Password validation
const isStrongPassword = (password) => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// Register a new user
const register = async (userData) => {
  const { username, email, password } = userData;
  let conn;
  
  try {
    // Validate password strength
    if (!isStrongPassword(password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    try {
      // Check if username or email already exists
      const [existingUsers] = await conn.query(
        "SELECT username, email FROM user WHERE username = ? OR email = ?",
        [username, email]
      );
      
      if (Array.isArray(existingUsers) && existingUsers.length > 0) {
        if (existingUsers.some(user => user.username === username)) {
          throw new Error('Username already exists');
        }
        if (existingUsers.some(user => user.email === email)) {
          throw new Error('Email already exists');
        }
        throw new Error('Username or email already exists');
      }
      
      // Hash the password
      const salt = await bcrypt.genSalt(10);
      const password_hash = await bcrypt.hash(password, salt);
      
      // Create a new user
      const id = uuidv4();
      const now = new Date();
      
      await conn.query(
        `INSERT INTO user (
          id, username, email, password_hash, role, 
          created_at, updated_at, cake_day, last_active
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [id, username, email, password_hash, 'user', now, now, now, now]
      );
      
      // Create user statistics record
      await conn.query(
        `INSERT INTO user_statistic (
          user_id, karma, posts_count, comments_count, 
          upvotes_received, downvotes_received, upvotes_given, 
          downvotes_given, communities_joined, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
      );
      
      // Create user settings record
      await conn.query(
        `INSERT INTO user_setting (
          user_id, email_notifications, push_notifications, 
          theme, content_filter, allow_followers, 
          display_online_status, language, timezone, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
      );
      
      // Commit transaction
      await conn.commit();
      
      // Return user without password
      const [results] = await conn.query(
        `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
          s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
          s.downvotes_received, s.upvotes_given, s.downvotes_given, 
          s.communities_joined
        FROM user u
        LEFT JOIN user_statistic s ON u.id = s.user_id
        WHERE u.id = ?`,
        [id]
      );
      
      const newUser = Array.isArray(results) && results.length > 0 ? results[0] : null;
      
      if (!newUser) {
        throw new Error('Failed to retrieve created user');
      }
      
      // Log activity (don't wait for it to complete)
      logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username, email },
        ipAddress: null,
        userAgent: null
      }).catch(error => {
        console.error("Error logging registration activity:", error);
        // Don't throw, just log the error
      });
      
      return { user: newUser };
    } catch (transactionError) {
      // Rollback transaction on error
      await conn.rollback();
      throw transactionError;
    }
  } catch (error) {
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Login a user
const login = async (credentials) => {
  const { username, password } = credentials;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [users] = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [username]
    );
    
    const user = Array.isArray(users) && users.length > 0 ? users[0] : null;
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Check password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id, 
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    // Log activity (don't wait for it to complete)
    logActivity({
      userId: user.id,
      activityType: 'USER',
      actionType: 'LOGIN',
      entityId: user.id,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    }).catch(error => {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    });
    
    // Return user and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get current user
const getCurrentUser = async (userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [users] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    const user = Array.isArray(users) && users.length > 0 ? users[0] : null;
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Verify JWT token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Logout (just for activity logging)
const logout = async (userId) => {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
};

module.exports = {
  register,
  login,
  getCurrentUser,
  verifyToken,
  logout
};

================
File: backend/api/auth.js.new
================
// Updated auth.js for the new database schema
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');
const { logActivity } = require('./activity.js');

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Password validation
const isStrongPassword = (password) => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// Register a new user
const register = async (userData) => {
  const { username, email, password } = userData;
  let conn;
  
  try {
    // Validate password strength
    if (!isStrongPassword(password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [username, email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const password_hash = await bcrypt.hash(password, salt);
    
    // Create a new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, username, email, password_hash, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Return user without password
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username, email },
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Login a user
const login = async (credentials) => {
  const { username, password } = credentials;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [user] = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [username]
    );
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Check password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id, 
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get current user
const getCurrentUser = async (userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [user] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Verify JWT token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Logout (just for activity logging)
const logout = async (userId) => {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
};

module.exports = {
  register,
  login,
  getCurrentUser,
  verifyToken,
  logout
};

================
File: backend/api/auth.ts
================
// Updated auth.ts for the new database schema
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { logActivity } from './activity';
import pool from '../db/connection';
import { QueryResult } from 'mysql2';

dotenv.config();

// JWT secret key
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
// Token expiration (1 day)
const TOKEN_EXPIRATION = '1d';

// User interface
interface User {
  id: string;
  username: string;
  email: string;
  password_hash?: string;
  role: string;
  first_name?: string;
  last_name?: string;
  display_name?: string;
  date_of_birth?: Date;
  bio?: string;
  avatar_url?: string;
  profile_banner_url?: string;
  website?: string;
  location?: string;
  is_verified?: boolean;
  status?: string;
  cake_day?: Date;
  created_at: Date;
  updated_at: Date;
  last_active?: Date;
  karma?: number;
  posts_count?: number;
  comments_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
}

// Password validation
const isStrongPassword = (password: string): boolean => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// User registration
export async function register(userData: { username: string; email: string; password: string }) {
  let conn;
  try {
    // Validate password strength
    if (!isStrongPassword(userData.password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [userData.username, userData.email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
    
    // Create new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, userData.username, userData.email, hashedPassword, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Get the created user (without password)
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username: userData.username, email: userData.email },
        ipAddress: undefined,
        userAgent: undefined
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// User login
export async function login(credentials: { username: string; password: string }) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const userResult = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [credentials.username]
    );
    
    const [rows] = userResult as [any[], any];
    const user = rows[0] as User;
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Compare passwords
    const passwordMatch = await bcrypt.compare(credentials.password, user.password_hash || '');
    
    if (!passwordMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRATION }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: undefined,
        userAgent: undefined
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user info and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get current user from token
export async function getCurrentUser(userId: string) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const userResult = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    const [rows] = userResult as [any[], any];
    const user = rows[0] as User;
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Middleware to verify JWT token
export function verifyToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// User logout
export async function logout(userId: string) {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: undefined,
      userAgent: undefined
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
}

================
File: backend/api/auth.ts.new
================
// Updated auth.ts for the new database schema
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { logActivity } from './activity';
import pool from '../db/connection';

dotenv.config();

// JWT secret key
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
// Token expiration (1 day)
const TOKEN_EXPIRATION = '1d';

// User interface
interface User {
  id: string;
  username: string;
  email: string;
  password_hash?: string;
  role: string;
  first_name?: string;
  last_name?: string;
  display_name?: string;
  date_of_birth?: Date;
  bio?: string;
  avatar_url?: string;
  profile_banner_url?: string;
  website?: string;
  location?: string;
  is_verified?: boolean;
  status?: string;
  cake_day?: Date;
  created_at: Date;
  updated_at: Date;
  last_active?: Date;
  karma?: number;
  posts_count?: number;
  comments_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
}

// Password validation
const isStrongPassword = (password: string): boolean => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// User registration
export async function register(userData: { username: string; email: string; password: string }) {
  let conn;
  try {
    // Validate password strength
    if (!isStrongPassword(userData.password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [userData.username, userData.email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
    
    // Create new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, userData.username, userData.email, hashedPassword, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Get the created user (without password)
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username: userData.username, email: userData.email },
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// User login
export async function login(credentials: { username: string; password: string }) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [user] = await conn.query<User[]>(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [credentials.username]
    );
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Compare passwords
    const passwordMatch = await bcrypt.compare(credentials.password, user.password_hash || '');
    
    if (!passwordMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRATION }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user info and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get current user from token
export async function getCurrentUser(userId: string) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [user] = await conn.query<User[]>(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Middleware to verify JWT token
export function verifyToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// Logout (just for activity logging)
export async function logout(userId: string) {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
}

================
File: backend/api/comments.js
================
// JavaScript version of comments.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all comments for a post
const getPostComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching post comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get a specific comment
const getComment = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [comment] = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.id = ?
    `, [commentId]);
    
    return comment || null;
  } catch (error) {
    console.error("Error fetching comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Create a new comment
const createComment = async (userId, commentData) => {
  const { content, post_id, parent_comment_id } = commentData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if post exists
      const [post] = await conn.query(
        "SELECT * FROM post WHERE id = ?",
        [post_id]
      );
      
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if parent comment exists if provided
      if (parent_comment_id) {
        const [parentComment] = await conn.query(
          "SELECT * FROM comment WHERE id = ?",
          [parent_comment_id]
        );
        
        if (!parentComment) {
          throw new Error('Parent comment not found');
        }
      }
      
      // Create the comment
      const id = uuidv4();
      
      let query = "INSERT INTO comment (id, content, user_id, post_id";
      let values = [id, content, userId, post_id];
      
      if (parent_comment_id) {
        query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
        values.push(parent_comment_id);
      } else {
        query += ") VALUES (?, ?, ?, ?)";
      }
      
      await conn.query(query, values);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'CREATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          id,
          'comment',
          JSON.stringify({
            post_id: post_id,
            parent_comment_id: parent_comment_id || null
          })
        ]
      );
      
      // Get the created comment with username
      const [newComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      return newComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Update a comment
const updateComment = async (commentId, userId, content) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return null;
      }
      
      if (comment.user_id !== userId) {
        throw new Error('You can only update your own comments');
      }
      
      // Update the comment
      await conn.query(
        "UPDATE comment SET content = ? WHERE id = ?",
        [content, commentId]
      );
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Get the updated comment with username
      const [updatedComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [commentId]);
      
      // Commit the transaction
      await conn.commit();
      
      return updatedComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Delete a comment
const deleteComment = async (commentId, userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return false;
      }
      
      // Check if user is the comment author or a moderator of the community
      if (comment.user_id !== userId) {
        // Get the post to find the community
        const [post] = await conn.query(
          "SELECT community_id FROM post WHERE id = ?",
          [comment.post_id]
        );
        
        if (!post) {
          throw new Error('Post not found');
        }
        
        // Check if user is a moderator
        const [moderator] = await conn.query(
          "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
          [post.community_id, userId]
        );
        
        if (!moderator) {
          throw new Error('You can only delete your own comments or comments in communities you moderate');
        }
      }
      
      // Find all replies to this comment recursively
      const findReplies = async (parentId, replyIds = []) => {
        const replies = await conn.query(
          "SELECT id FROM comment WHERE parent_comment_id = ?",
          [parentId]
        );
        
        for (const reply of replies) {
          replyIds.push(reply.id);
          await findReplies(reply.id, replyIds);
        }
        
        return replyIds;
      };
      
      const replyIds = await findReplies(commentId);
      
      // Log activity for the main comment
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Delete all replies
      if (replyIds.length > 0) {
        // Log activity for each reply
        for (const replyId of replyIds) {
          const [reply] = await conn.query(
            "SELECT * FROM comment WHERE id = ?",
            [replyId]
          );
          
          if (reply) {
            await conn.query(
              `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
               VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                uuidv4(),
                userId,
                activityTypeId,
                actionId,
                replyId,
                'comment',
                JSON.stringify({
                  post_id: reply.post_id,
                  parent_comment_id: reply.parent_comment_id || null
                })
              ]
            );
          }
        }
        
        const placeholders = replyIds.map(() => '?').join(',');
        await conn.query(
          `DELETE FROM comment WHERE id IN (${placeholders})`,
          replyIds
        );
      }
      
      // Delete the comment
      await conn.query(
        "DELETE FROM comment WHERE id = ?",
        [commentId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      return true;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get replies to a comment
const getCommentReplies = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const replies = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.parent_comment_id = ?
      ORDER BY c.created_at ASC
    `, [commentId]);
    
    return replies;
  } catch (error) {
    console.error("Error fetching comment replies:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get threaded comments for a post
const getThreadedComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get all comments for the post with usernames
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    // Add replies array to each comment
    const commentsWithReplies = comments.map(comment => ({
      ...comment,
      username: comment.username || 'Anonymous',
      replies: []
    }));
    
    // Create a map for quick lookup
    const commentMap = new Map();
    commentsWithReplies.forEach(comment => {
      commentMap.set(comment.id, comment);
    });
    
    // Organize into a tree structure
    const rootComments = [];
    
    commentsWithReplies.forEach(comment => {
      if (comment.parent_comment_id) {
        const parent = commentMap.get(comment.parent_comment_id);
        if (parent) {
          parent.replies.push(comment);
        } else {
          rootComments.push(comment);
        }
      } else {
        rootComments.push(comment);
      }
    });
    
    return rootComments;
  } catch (error) {
    console.error("Error fetching threaded comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get user comments
const getUserComments = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username, p.title as post_title, p.community_id
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      LEFT JOIN post p ON c.post_id = p.id
      WHERE c.user_id = ?
      ORDER BY c.created_at DESC
    `, [userId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching user comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPostComments,
  getComment,
  createComment,
  updateComment,
  deleteComment,
  getCommentReplies,
  getThreadedComments,
  getUserComments
};

================
File: backend/api/comments.js.new
================
// JavaScript version of comments.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all comments for a post
const getPostComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching post comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get a specific comment
const getComment = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [comment] = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.id = ?
    `, [commentId]);
    
    return comment || null;
  } catch (error) {
    console.error("Error fetching comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Create a new comment
const createComment = async (userId, commentData) => {
  const { content, post_id, parent_comment_id } = commentData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if post exists
      const [post] = await conn.query(
        "SELECT * FROM post WHERE id = ?",
        [post_id]
      );
      
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if parent comment exists if provided
      if (parent_comment_id) {
        const [parentComment] = await conn.query(
          "SELECT * FROM comment WHERE id = ?",
          [parent_comment_id]
        );
        
        if (!parentComment) {
          throw new Error('Parent comment not found');
        }
      }
      
      // Create the comment
      const id = uuidv4();
      
      let query = "INSERT INTO comment (id, content, user_id, post_id";
      let values = [id, content, userId, post_id];
      
      if (parent_comment_id) {
        query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
        values.push(parent_comment_id);
      } else {
        query += ") VALUES (?, ?, ?, ?)";
      }
      
      await conn.query(query, values);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'CREATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          id,
          'comment',
          JSON.stringify({
            post_id: post_id,
            parent_comment_id: parent_comment_id || null
          })
        ]
      );
      
      // Get the created comment with username
      const [newComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      return newComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Update a comment
const updateComment = async (commentId, userId, content) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return null;
      }
      
      if (comment.user_id !== userId) {
        throw new Error('You can only update your own comments');
      }
      
      // Update the comment
      await conn.query(
        "UPDATE comment SET content = ? WHERE id = ?",
        [content, commentId]
      );
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Get the updated comment with username
      const [updatedComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [commentId]);
      
      // Commit the transaction
      await conn.commit();
      
      return updatedComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Delete a comment
const deleteComment = async (commentId, userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return false;
      }
      
      // Check if user is the comment author or a moderator of the community
      if (comment.user_id !== userId) {
        // Get the post to find the community
        const [post] = await conn.query(
          "SELECT community_id FROM post WHERE id = ?",
          [comment.post_id]
        );
        
        if (!post) {
          throw new Error('Post not found');
        }
        
        // Check if user is a moderator
        const [moderator] = await conn.query(
          "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
          [post.community_id, userId]
        );
        
        if (!moderator) {
          throw new Error('You can only delete your own comments or comments in communities you moderate');
        }
      }
      
      // Find all replies to this comment recursively
      const findReplies = async (parentId, replyIds = []) => {
        const replies = await conn.query(
          "SELECT id FROM comment WHERE parent_comment_id = ?",
          [parentId]
        );
        
        for (const reply of replies) {
          replyIds.push(reply.id);
          await findReplies(reply.id, replyIds);
        }
        
        return replyIds;
      };
      
      const replyIds = await findReplies(commentId);
      
      // Log activity for the main comment
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Delete all replies
      if (replyIds.length > 0) {
        // Log activity for each reply
        for (const replyId of replyIds) {
          const [reply] = await conn.query(
            "SELECT * FROM comment WHERE id = ?",
            [replyId]
          );
          
          if (reply) {
            await conn.query(
              `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
               VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                uuidv4(),
                userId,
                activityTypeId,
                actionId,
                replyId,
                'comment',
                JSON.stringify({
                  post_id: reply.post_id,
                  parent_comment_id: reply.parent_comment_id || null
                })
              ]
            );
          }
        }
        
        const placeholders = replyIds.map(() => '?').join(',');
        await conn.query(
          `DELETE FROM comment WHERE id IN (${placeholders})`,
          replyIds
        );
      }
      
      // Delete the comment
      await conn.query(
        "DELETE FROM comment WHERE id = ?",
        [commentId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      return true;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get replies to a comment
const getCommentReplies = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const replies = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.parent_comment_id = ?
      ORDER BY c.created_at ASC
    `, [commentId]);
    
    return replies;
  } catch (error) {
    console.error("Error fetching comment replies:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get threaded comments for a post
const getThreadedComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get all comments for the post with usernames
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    // Add replies array to each comment
    const commentsWithReplies = comments.map(comment => ({
      ...comment,
      username: comment.username || 'Anonymous',
      replies: []
    }));
    
    // Create a map for quick lookup
    const commentMap = new Map();
    commentsWithReplies.forEach(comment => {
      commentMap.set(comment.id, comment);
    });
    
    // Organize into a tree structure
    const rootComments = [];
    
    commentsWithReplies.forEach(comment => {
      if (comment.parent_comment_id) {
        const parent = commentMap.get(comment.parent_comment_id);
        if (parent) {
          parent.replies.push(comment);
        } else {
          rootComments.push(comment);
        }
      } else {
        rootComments.push(comment);
      }
    });
    
    return rootComments;
  } catch (error) {
    console.error("Error fetching threaded comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get user comments
const getUserComments = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username, p.title as post_title, p.community_id
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      LEFT JOIN post p ON c.post_id = p.id
      WHERE c.user_id = ?
      ORDER BY c.created_at DESC
    `, [userId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching user comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPostComments,
  getComment,
  createComment,
  updateComment,
  deleteComment,
  getCommentReplies,
  getThreadedComments,
  getUserComments
};

================
File: backend/api/comments.ts
================
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Comment {
    id: string;
    content: string;
    user_id: string;
    post_id: string;
    parent_comment_id?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommentInput {
    content: string;
    post_id: string;
    parent_comment_id?: string;
}

// Get all comments for a post
export async function getPostComments(postId: string): Promise<Comment[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const comments = await conn.query(
            "SELECT * FROM comments WHERE post_id = ? ORDER BY created_at ASC",
            [postId]
        );
        return comments;
    } catch (error) {
        console.error("Error fetching comments:", error);
        throw new Error('Failed to fetch comments');
    } finally {
        if (conn) conn.end();
    }
}

// Get a specific comment
export async function getComment(commentId: string): Promise<Comment | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [comment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        return comment || null;
    } catch (error) {
        console.error("Error fetching comment:", error);
        throw new Error('Failed to fetch comment');
    } finally {
        if (conn) conn.end();
    }
}

// Create a new comment
export async function createComment(userId: string, commentData: CommentInput): Promise<Comment> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Build the query based on whether parent_comment_id is provided
        let query = "INSERT INTO comments (id, content, user_id, post_id";
        let values = [id, commentData.content, userId, commentData.post_id];
        
        if (commentData.parent_comment_id) {
            query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
            values.push(commentData.parent_comment_id);
        } else {
            query += ") VALUES (?, ?, ?, ?)";
        }
        
        await conn.query(query, values);
        
        const [newComment] = await conn.query("SELECT * FROM comments WHERE id = ?", [id]);
        return newComment;
    } catch (error) {
        console.error("Error creating comment:", error);
        throw new Error('Failed to create comment');
    } finally {
        if (conn) conn.end();
    }
}

// Update a comment
export async function updateComment(
    commentId: string, 
    userId: string, 
    content: string
): Promise<Comment | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if the user is the author of the comment
        const [comment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        
        if (!comment) {
            return null;
        }
        
        if (comment.user_id !== userId) {
            throw new Error('You can only update your own comments');
        }
        
        await conn.query(
            "UPDATE comments SET content = ?, updated_at = NOW() WHERE id = ?",
            [content, commentId]
        );
        
        const [updatedComment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        return updatedComment;
    } catch (error) {
        console.error("Error updating comment:", error);
        throw error;
    } finally {
        if (conn) conn.end();
    }
}

// Delete a comment
export async function deleteComment(commentId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if the user is the author of the comment
        const [comment] = await conn.query(
            "SELECT * FROM comments WHERE id = ?",
            [commentId]
        );
        
        if (!comment) {
            return false;
        }
        
        if (comment.user_id !== userId) {
            throw new Error('You can only delete your own comments');
        }
        
        // Start a transaction to handle deleting the comment and its replies
        await conn.beginTransaction();
        
        // Delete all replies to this comment
        await conn.query(
            "DELETE FROM comments WHERE parent_comment_id = ?",
            [commentId]
        );
        
        // Delete the comment itself
        const result = await conn.query(
            "DELETE FROM comments WHERE id = ?",
            [commentId]
        );
        
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (conn) {
            await conn.rollback();
        }
        throw error;
    } finally {
        if (conn) conn.end();
    }
}

// Get replies to a comment
export async function getCommentReplies(commentId: string): Promise<Comment[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const replies = await conn.query(
            "SELECT * FROM comments WHERE parent_comment_id = ? ORDER BY created_at ASC",
            [commentId]
        );
        return replies;
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        throw new Error('Failed to fetch comment replies');
    } finally {
        if (conn) conn.end();
    }
}

// Define a type for threaded comments
export interface ThreadedComment extends Comment {
    username: string;
    replies: ThreadedComment[];
}

// Get threaded comments for a post
export async function getThreadedComments(postId: string): Promise<ThreadedComment[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get all comments for the post
        const comments: ThreadedComment[] = await conn.query(
            "SELECT c.*, u.username FROM comments c " +
            "JOIN users u ON c.user_id = u.id " +
            "WHERE c.post_id = ? " +
            "ORDER BY c.created_at ASC",
            [postId]
        );
        
        // Organize comments into a threaded structure
        const commentMap = new Map<string, ThreadedComment>();
        const rootComments: ThreadedComment[] = [];
        
        // First pass: create a map of all comments
        comments.forEach((comment: ThreadedComment) => {
            comment.replies = [];
            commentMap.set(comment.id, comment);
        });
        
        // Second pass: organize into a tree structure
        comments.forEach((comment: ThreadedComment) => {
            if (comment.parent_comment_id) {
                const parent = commentMap.get(comment.parent_comment_id);
                if (parent) {
                    parent.replies.push(comment);
                } else {
                    rootComments.push(comment);
                }
            } else {
                rootComments.push(comment);
            }
        });
        
        return rootComments;
    } catch (error) {
        console.error("Error fetching threaded comments:", error);
        throw new Error('Failed to fetch threaded comments');
    } finally {
        if (conn) conn.end();
    }
}

================
File: backend/api/communities.js
================
// Fix for the community join request functionality
// This file extends the communities.ts code to handle both singular/plural naming issues

const mariadb = require('mariadb');
const dotenv = require('dotenv');
const { v4: uuidv4 } = require('uuid');

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

// Override the addCommunityMember function to handle the table name issue
exports.addCommunityMember = async function(communityId, userId, role = 'member') {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if user is already a member
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // Just update their role if needed
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // If they had a pending join request, try to mark it as approved
            // We catch errors here to handle the case where the table might not exist
            try {
                await conn.query(
                    "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
                    [communityId, userId]
                );
            } catch (error) {
                console.log("Note: community_join_request table might not exist yet. Continuing anyway.");
            }
            
            // Get user details
            const [user] = await conn.query(
                "SELECT username FROM user WHERE id = ?",
                [userId]
            );
            
            // Commit the transaction
            await conn.commit();
            
            return {
                community_id: communityId,
                user_id: userId,
                username: user.username,
                role: role,
                joined_at: existingMember.joined_at
            };
        }
        
        // Insert new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role, joined_at) VALUES (?, ?, ?, NOW())",
            [communityId, userId, role]
        );
        
        // If they had a pending join request, try to mark it as approved
        try {
            await conn.query(
                "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
                [communityId, userId]
            );
        } catch (error) {
            console.log("Note: community_join_request table might not exist yet. Continuing anyway.");
        }
        
        // Get user details
        const [user] = await conn.query(
            "SELECT username FROM user WHERE id = ?",
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ role })
            ]
        );
        
        // Update user statistics
        await conn.query(
            "UPDATE user_statistic SET communities_joined = communities_joined + 1 WHERE user_id = ?",
            [userId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return {
            community_id: communityId,
            user_id: userId,
            username: user.username,
            role,
            joined_at: new Date()
        };
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
};

================
File: backend/api/communities.js.new
================
llconst mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community CRUD operations
const getCommunities = async () => {
  let conn;
  try {
    conn = await pool.getConnection();
    const communities = await conn.query("SELECT * FROM community");
    return communities;
  } catch (error) {
    console.error("Error fetching communities:", error);
    throw new Error('Failed to fetch communities');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunity = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    return community || null;
  } catch (error) {
    console.error("Error fetching community:", error);
    throw new Error('Failed to fetch community');
  } finally {
    if (conn) conn.end();
  }
};

const createCommunity = async (communityData) => {
  const { name, description, privacy, icon_url, banner_url, theme_color, creator_id } = communityData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Include all fields in the insert
    await conn.query(
      `INSERT INTO community (
        id, name, description, privacy, icon_url, banner_url, theme_color
      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        id, 
        name, 
        description, 
        privacy || 'public',
        icon_url || null,
        banner_url || null,
        theme_color || null
      ]
    );
    
    // Create default settings for the community
    await conn.query(
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, allow_post_videos,
        allow_polls, require_post_flair, show_in_discovery,
        join_method, content_filter_level
      ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
      [id]
    );
    
    // Log activity if creator_id is provided
    if (creator_id) {
      const activityId = uuidv4();
      await conn.query(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'community', NOW()
        )`,
        [activityId, creator_id, id]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
    return newCommunity;
  } catch (error) {
    console.error("Error creating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create community');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunity = async (communityId, communityData, userId) => {
  const { name, description, privacy, icon_url, banner_url, theme_color } = communityData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (name !== undefined) {
      updates.push("name = ?");
      values.push(name);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (privacy !== undefined) {
      updates.push("privacy = ?");
      values.push(privacy);
    }
    
    if (icon_url !== undefined) {
      updates.push("icon_url = ?");
      values.push(icon_url);
    }
    
    if (banner_url !== undefined) {
      updates.push("banner_url = ?");
      values.push(banner_url);
    }
    
    if (theme_color !== undefined) {
      updates.push("theme_color = ?");
      values.push(theme_color);
    }
    
    if (updates.length === 0) {
      // No fields to update
      return await getCommunity(communityId);
    }
    
    // Add the ID to the values array
    values.push(communityId);
    
    await conn.query(
      `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return await getCommunity(communityId);
  } catch (error) {
    console.error("Error updating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunity = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction to ensure all related data is deleted
    await conn.beginTransaction();
    
    // Delete community settings
    await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
    
    // Delete community rules
    await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
    
    // Delete community members
    await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
    
    // Delete join requests
    await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
    
    // Log activity before deleting the community
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Delete the community itself
    const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community');
  } finally {
    if (conn) conn.end();
  }
};

// Community Rules operations
const getCommunityRules = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const rules = await conn.query(
      "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
      [communityId]
    );
    return rules;
  } catch (error) {
    console.error("Error fetching community rules:", error);
    throw new Error('Failed to fetch community rules');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityRule = async (communityId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the highest position to determine the next position
    const [positionResult] = await conn.query(
      "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
      [communityId]
    );
    const nextPosition = (positionResult.maxPosition || 0) + 1;
    
    await conn.query(
      "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
      [id, communityId, title, description, position || nextPosition]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [id]
    );
    return newRule;
  } catch (error) {
    console.error("Error adding community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community rule');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityRule = async (ruleId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (title !== undefined) {
      updates.push("title = ?");
      values.push(title);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (position !== undefined) {
      updates.push("position = ?");
      values.push(position);
    }
    
    if (updates.length === 0) {
      // No fields to update
      const [rule] = await conn.query(
        "SELECT * FROM community_rule WHERE id = ?",
        [ruleId]
      );
      return rule || null;
    }
    
    // Add the ID to the values array
    values.push(ruleId);
    
    await conn.query(
      `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [updatedRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [ruleId]
    );
    return updatedRule || null;
  } catch (error) {
    console.error("Error updating community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community rule');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunityRule = async (ruleId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the rule to log its community_id
    const [rule] = await conn.query(
      "SELECT community_id FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    if (!rule) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_rule', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        ruleId, 
        JSON.stringify({ community_id: rule.community_id })
      ]
    );
    
    // Delete the rule
    const result = await conn.query(
      "DELETE FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community rule');
  } finally {
    if (conn) conn.end();
  }
};

// Community Settings operations
const getCommunitySettings = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get settings from the community_setting table
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    // If settings don't exist, create default settings
    if (!settings) {
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
        [communityId]
      );
      
      const [newSettings] = await conn.query(
        "SELECT * FROM community_setting WHERE community_id = ?",
        [communityId]
      );
      return newSettings;
    }
    
    return settings;
  } catch (error) {
    console.error("Error fetching community settings:", error);
    throw new Error('Failed to fetch community settings');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunitySettings = async (communityId, settingsData, userId) => {
  const { 
    allow_post_images, 
    allow_post_links, 
    allow_post_videos,
    allow_polls,
    require_post_flair,
    show_in_discovery,
    join_method,
    content_filter_level
  } = settingsData;
  
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if settings exist
    const [existingSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (!existingSettings) {
      // Create settings if they don't exist
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          communityId,
          allow_post_images !== undefined ? allow_post_images : true,
          allow_post_links !== undefined ? allow_post_links : true,
          allow_post_videos !== undefined ? allow_post_videos : true,
          allow_polls !== undefined ? allow_polls : true,
          require_post_flair !== undefined ? require_post_flair : false,
          show_in_discovery !== undefined ? show_in_discovery : true,
          join_method !== undefined ? join_method : 'auto_approve',
          content_filter_level !== undefined ? content_filter_level : 'none'
        ]
      );
    } else {
      // Build the update query dynamically based on provided fields
      const updates = [];
      const values = [];
      
      if (allow_post_images !== undefined) {
        updates.push("allow_post_images = ?");
        values.push(allow_post_images);
      }
      
      if (allow_post_links !== undefined) {
        updates.push("allow_post_links = ?");
        values.push(allow_post_links);
      }
      
      if (allow_post_videos !== undefined) {
        updates.push("allow_post_videos = ?");
        values.push(allow_post_videos);
      }
      
      if (allow_polls !== undefined) {
        updates.push("allow_polls = ?");
        values.push(allow_polls);
      }
      
      if (require_post_flair !== undefined) {
        updates.push("require_post_flair = ?");
        values.push(require_post_flair);
      }
      
      if (show_in_discovery !== undefined) {
        updates.push("show_in_discovery = ?");
        values.push(show_in_discovery);
      }
      
      if (join_method !== undefined) {
        updates.push("join_method = ?");
        values.push(join_method);
      }
      
      if (content_filter_level !== undefined) {
        updates.push("content_filter_level = ?");
        values.push(content_filter_level);
      }
      
      if (updates.length > 0) {
        // Add the community ID to the values array
        values.push(communityId);
        
        await conn.query(
          `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
          values
        );
      }
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_setting', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated settings
    const [updatedSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    return updatedSettings;
  } catch (error) {
    console.error("Error updating community settings:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community settings');
  } finally {
    if (conn) conn.end();
  }
};

// Community Members operations
const getCommunityMembers = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const members = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ?",
      [communityId]
    );
    return members;
  } catch (error) {
    console.error("Error fetching community members:", error);
    throw new Error('Failed to fetch community members');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityMember = async (communityId, userId, role = 'member') => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if the member already exists
    const [existingMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    if (existingMember) {
      // If the member already exists, update their role if different
      if (existingMember.role !== role) {
        await conn.query(
          "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
          [role, communityId, userId]
        );
      }
      
      // Commit the transaction
      await conn.commit();
      
      return existingMember;
    }
    
    // Add the new member
    await conn.query(
      "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
      [communityId, userId, role]
    );
    
    // Update user statistics
    await conn.query(
      `UPDATE user_statistic 
       SET communities_joined = communities_joined + 1
       WHERE user_id = ?`,
      [userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return newMember;
  } catch (error) {
    console.error("Error adding community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community member');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityMemberRole = async (communityId, userId, role, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Update the member's role
    await conn.query(
      "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
      [role, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_member', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        userId, 
        JSON.stringify({ 
          community_id: communityId,
          user_id: userId,
          new_role: role
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated member
    const [updatedMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return updatedMember || null;
  } catch (error) {
    console.error("Error updating community member role:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community member role');
  } finally {
    if (conn) conn.end();
  }
};

const removeCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Log activity before removing the member
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Remove the member
    const result = await conn.query(
      "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    // Update user statistics
    if (result.affectedRows > 0) {
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = GREATEST(communities_joined - 1, 0)
         WHERE user_id = ?`,
        [userId]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error removing community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to remove community member');
  } finally {
    if (conn) conn.end();
  }
};

// Community Join Request operations
const getJoinRequests = async (communityId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
};

const getJoinRequest = async (requestId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
};

const createJoinRequest = async (communityId, userId) => {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
};

const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestI

================
File: backend/api/communities.js.new.part2
================
const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request || request.status !== 'pending') {
      // Only pending requests can be updated
      await conn.rollback();
      return null;
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
      [status, requestId]
    );
    
    // If approved, add the user as a community member
    if (status === 'approved') {
      await conn.query(
        "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, 'member') " +
        "ON DUPLICATE KEY UPDATE role = 'member'",
        [request.community_id, request.user_id]
      );
      
      // Update user statistics
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = communities_joined + 1
         WHERE user_id = ?`,
        [request.user_id]
      );
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id,
          status: status
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest || null;
  } catch (error) {
    console.error("Error updating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request');
  } finally {
    if (conn) conn.end();
  }
};

const deleteJoinRequest = async (requestId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the request to log its details
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Delete the request
    const result = await conn.query(
      "DELETE FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete join request');
  } finally {
    if (conn) conn.end();
  }
};

const getUserJoinRequests = async (userId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE user_id = ?";
    const params = [userId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching user join requests:", error);
    throw new Error('Failed to fetch user join requests');
  } finally {
    if (conn) conn.end();
  }
};

// Enhanced community information
const getCommunityAbout = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get the community
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return null;
    }
    
    // Get the member count
    const [memberCountResult] = await conn.query(
      "SELECT COUNT(*) as memberCount FROM community_member WHERE community_id = ?",
      [communityId]
    );
    const memberCount = memberCountResult.memberCount || 0;
    
    // Get the post count
    const [postCountResult] = await conn.query(
      "SELECT COUNT(*) as postCount FROM post WHERE community_id = ?",
      [communityId]
    );
    const postCount = postCountResult.postCount || 0;
    
    // Get the moderators
    const moderators = await conn.query(
      "SELECT user_id FROM community_member WHERE community_id = ? AND role IN ('moderator', 'admin')",
      [communityId]
    );
    const moderatorIds = moderators.map(mod => mod.user_id);
    
    // Return the enhanced community information
    return {
      ...community,
      memberCount,
      postCount,
      moderators: moderatorIds
    };
  } catch (error) {
    console.error("Error fetching community about:", error);
    throw new Error('Failed to fetch community about');
  } finally {
    if (conn) conn.end();
  }
};

const getUserCommunities = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get the communities the user is a member of
    const communities = await conn.query(
      `SELECT c.* 
       FROM community c
       JOIN community_member cm ON c.id = cm.community_id
       WHERE cm.user_id = ?`,
      [userId]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching user communities:", error);
    throw new Error('Failed to fetch user communities');
  } finally {
    if (conn) conn.end();
  }
};

const searchCommunities = async (searchTerm) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Search for communities by name or description
    const communities = await conn.query(
      `SELECT * FROM community 
       WHERE name LIKE ? OR description LIKE ?`,
      [`%${searchTerm}%`, `%${searchTerm}%`]
    );
    
    return communities;
  } catch (error) {
    console.error("Error searching communities:", error);
    throw new Error('Failed to search communities');
  } finally {
    if (conn) conn.end();
  }
};

// Export all functions
module.exports = {
  getCommunities,
  getCommunity,
  createCommunity,
  updateCommunity,
  deleteCommunity,
  getCommunityRules,
  addCommunityRule,
  updateCommunityRule,
  deleteCommunityRule,
  getCommunitySettings,
  updateCommunitySettings,
  getCommunityMembers,
  getCommunityMember,
  addCommunityMember,
  updateCommunityMemberRole,
  removeCommunityMember,
  getJoinRequests,
  getJoinRequest,
  createJoinRequest,
  updateJoinRequestStatus,
  deleteJoinRequest,
  getUserJoinRequests,
  getCommunityAbout,
  getUserCommunities,
  searchCommunities
};

================
File: backend/api/communities.ts
================
// backend/api/communities.ts
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Community {
    id: string;
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityInput {
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    creator_id?: string;
}

export interface CommunityRule {
    id: string;
    community_id: string;
    title: string;
    description: string;
    position: number;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityRuleInput {
    title: string;
    description: string;
    position?: number;
}

export interface CommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    join_method: 'auto_approve' | 'requires_approval' | 'invite_only';
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface CommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    join_method?: 'auto_approve' | 'requires_approval' | 'invite_only';
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface CommunityMember {
    community_id: string;
    user_id: string;
    username: string;
    role: 'member' | 'moderator' | 'admin';
    joined_at: Date;
}

export interface JoinRequest {
    id: string;
    community_id: string;
    user_id: string;
    status: 'pending' | 'approved' | 'rejected';
    requested_at: Date;
    updated_at: Date;
}

export async function getCommunities(): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query("SELECT * FROM community");
        return communities;
    } catch (error) {
        console.error("Error fetching communities:", error);
        throw new Error('Failed to fetch communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunity(communityId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query("SELECT * FROM community WHERE id = ?", [communityId]);
        return community || null;
    } catch (error) {
        console.error("Error fetching community:", error);
        throw new Error('Failed to fetch community');
    } finally {
        if (conn) conn.end();
    }
}

export async function createCommunity(communityData: CommunityInput): Promise<Community> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Include all fields in the insert
        await conn.query(
            `INSERT INTO community (
                id, name, description, privacy, icon_url, banner_url, theme_color
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                id, 
                communityData.name, 
                communityData.description, 
                communityData.privacy || 'public',
                communityData.icon_url || null,
                communityData.banner_url || null,
                communityData.theme_color || null
            ]
        );
        
        // Create default settings for the community
        await conn.query(
            `INSERT INTO community_setting (
                community_id, allow_post_images, allow_post_links, join_method,
                require_post_approval, restricted_words, custom_theme_color,
                custom_banner_url, minimum_account_age_days, minimum_karma_required,
                updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
            [
                id,
                true, // allow_post_images
                true, // allow_post_links
                'auto_approve', // join_method
                false, // require_post_approval
                null, // restricted_words
                null, // custom_theme_color
                null, // custom_banner_url
                0, // minimum_account_age_days
                0, // minimum_karma_required
            ]
        );
        
        // Log the activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community', NOW()
            )`,
            [
                activityId, 
                communityData.creator_id || null, 
                id
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the created community
        const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
        return newCommunity;
    } catch (error) {
        console.error("Error creating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to create community');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunity(communityId: string, communityData: Partial<CommunityInput>, userId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (communityData.name !== undefined) {
            updates.push("name = ?");
            values.push(communityData.name);
        }
        
        if (communityData.description !== undefined) {
            updates.push("description = ?");
            values.push(communityData.description);
        }
        
        if (communityData.privacy !== undefined) {
            updates.push("privacy = ?");
            values.push(communityData.privacy);
        }
        
        if (communityData.icon_url !== undefined) {
            updates.push("icon_url = ?");
            values.push(communityData.icon_url);
        }
        
        if (communityData.banner_url !== undefined) {
            updates.push("banner_url = ?");
            values.push(communityData.banner_url);
        }
        
        if (communityData.theme_color !== undefined) {
            updates.push("theme_color = ?");
            values.push(communityData.theme_color);
        }
        
        if (updates.length === 0) {
            // No fields to update
            return await getCommunity(communityId);
        }
        
        // Add the ID to the values array
        values.push(communityId);
        
        await conn.query(
            `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify(communityData)
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated community
        return await getCommunity(communityId);
    } catch (error) {
        console.error("Error updating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunity(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Log activity before deletion
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Delete the community itself
        const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community');
    } finally {
        if (conn) conn.end();
    }
}

// Community Rules operations
export async function getCommunityRules(communityId: string): Promise<CommunityRule[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const rules = await conn.query(
            "SELECT * FROM community_rule WHERE community_id = ?",
            [communityId]
        );
        return rules;
    } catch (error) {
        console.error("Error fetching community rules:", error);
        throw new Error('Failed to fetch community rules');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityRule(communityId: string, ruleData: CommunityRuleInput, userId: string): Promise<CommunityRule> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        await conn.query(
            `INSERT INTO community_rule (
                id, community_id, title, description, created_at, updated_at
            ) VALUES (?, ?, ?, ?, NOW(), NOW())`,
            [
                id,
                communityId,
                ruleData.title,
                ruleData.description
            ]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, id]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [id]
        );
        return newRule;
    } catch (error) {
        console.error("Error adding community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityRule(ruleId: string, ruleData: Partial<CommunityRuleInput>, userId: string): Promise<CommunityRule | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (ruleData.title !== undefined) {
            updates.push("title = ?");
            values.push(ruleData.title);
        }
        
        if (ruleData.description !== undefined) {
            updates.push("description = ?");
            values.push(ruleData.description);
        }
        
        if (updates.length === 0) {
            // No fields to update
            const [rule] = await conn.query(
                "SELECT * FROM community_rule WHERE id = ?",
                [ruleId]
            );
            return rule || null;
        }
        
        // Add the ID to the values array
        values.push(ruleId);
        
        await conn.query(
            `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [updatedRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [ruleId]
        );
        return updatedRule || null;
    } catch (error) {
        console.error("Error updating community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunityRule(ruleId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the rule to log its community_id
        const [rule] = await conn.query(
            "SELECT community_id FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        if (!rule) {
            return false;
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community_rule', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                ruleId, 
                JSON.stringify({ community_id: rule.community_id })
            ]
        );
        
        // Delete the rule
        const result = await conn.query(
            "DELETE FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community rule');
    } finally {
        if (conn) conn.end();
    }
}

// Community Settings operations
export async function getCommunitySettings(communityId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        return settings || null;
    } catch (error) {
        console.error("Error fetching community settings:", error);
        throw new Error('Failed to fetch community settings');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunitySettings(communityId: string, settingsData: CommunitySettingsInput, userId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create default settings
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, join_method,
                    require_post_approval, restricted_words, custom_theme_color,
                    custom_banner_url, minimum_account_age_days, minimum_karma_required,
                    updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
                [
                    communityId,
                    settingsData.allow_post_images !== undefined ? settingsData.allow_post_images : true,
                    settingsData.allow_post_links !== undefined ? settingsData.allow_post_links : true,
                    settingsData.join_method || 'auto_approve',
                    settingsData.require_post_approval !== undefined ? settingsData.require_post_approval : false,
                    settingsData.restricted_words || null,
                    settingsData.custom_theme_color || null,
                    settingsData.custom_banner_url || null,
                    settingsData.minimum_account_age_days !== undefined ? settingsData.minimum_account_age_days : 0,
                    settingsData.minimum_karma_required !== undefined ? settingsData.minimum_karma_required : 0
                ]
            );
        } else {
            // Build the update query dynamically based on provided fields
            const updates: string[] = [];
            const values: any[] = [];
            
            if (settingsData.allow_post_images !== undefined) {
                updates.push("allow_post_images = ?");
                values.push(settingsData.allow_post_images);
            }
            
            if (settingsData.allow_post_links !== undefined) {
                updates.push("allow_post_links = ?");
                values.push(settingsData.allow_post_links);
            }
            
            if (settingsData.join_method !== undefined) {
                updates.push("join_method = ?");
                values.push(settingsData.join_method);
            }
            
            if (settingsData.require_post_approval !== undefined) {
                updates.push("require_post_approval = ?");
                values.push(settingsData.require_post_approval);
            }
            
            if (settingsData.restricted_words !== undefined) {
                updates.push("restricted_words = ?");
                values.push(settingsData.restricted_words);
            }
            
            if (settingsData.custom_theme_color !== undefined) {
                updates.push("custom_theme_color = ?");
                values.push(settingsData.custom_theme_color);
            }
            
            if (settingsData.custom_banner_url !== undefined) {
                updates.push("custom_banner_url = ?");
                values.push(settingsData.custom_banner_url);
            }
            
            if (settingsData.minimum_account_age_days !== undefined) {
                updates.push("minimum_account_age_days = ?");
                values.push(settingsData.minimum_account_age_days);
            }
            
            if (settingsData.minimum_karma_required !== undefined) {
                updates.push("minimum_karma_required = ?");
                values.push(settingsData.minimum_karma_required);
            }
            
            if (updates.length > 0) {
                // Add the ID to the values array
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE_SETTINGS'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify(settingsData)
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated settings
        return await getCommunitySettings(communityId);
    } catch (error) {
        console.error("Error updating community settings:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community settings');
    } finally {
        if (conn) conn.end();
    }
}

// Community Members operations
export async function getCommunityMembers(communityId: string): Promise<CommunityMember[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const members = await conn.query(
            `SELECT cm.*, u.username 
             FROM community_member cm
             JOIN user u ON cm.user_id = u.id
             WHERE cm.community_id = ?`,
            [communityId]
        );
        return members;
    } catch (error) {
        console.error("Error fetching community members:", error);
        throw new Error('Failed to fetch community members');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityMember(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin' = 'member'): Promise<CommunityMember> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if user is already a member
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // Just update their role if needed
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // If they had a pending join request, mark it as approved
            await conn.query(
                "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
                [communityId, userId]
            );
            
            // Get user details
            const [user] = await conn.query(
                "SELECT username FROM user WHERE id = ?",
                [userId]
            );
            
            // Commit the transaction
            await conn.commit();
            
            return {
                community_id: communityId,
                user_id: userId,
                username: user.username,
                role: role,
                joined_at: existingMember.joined_at
            };
        }
        
        // Insert new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role, joined_at) VALUES (?, ?, ?, NOW())",
            [communityId, userId, role]
        );
        
        // If they had a pending join request, mark it as approved
        await conn.query(
            "UPDATE community_join_request SET status = 'approved', updated_at = NOW() WHERE community_id = ? AND user_id = ? AND status = 'pending'",
            [communityId, userId]
        );
        
        // Get user details
        const [user] = await conn.query(
            "SELECT username FROM user WHERE id = ?",
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ role })
            ]
        );
        
        // Update user statistics
        await conn.query(
            "UPDATE user_statistic SET communities_joined = communities_joined + 1 WHERE user_id = ?",
            [userId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return {
            community_id: communityId,
            user_id: userId,
            username: user.username,
            role,
            joined_at: new Date()
        };
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityMemberRole(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin', updatedBy: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if member exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingMember) {
            return null;
        }
        
        // Update role
        await conn.query(
            "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
            [role, communityId, userId]
        );
        
        // If promoting to moderator, add default permissions
        if (role === 'moderator' && existingMember.role !== 'moderator' && existingMember.role !== 'admin') {
            try {
                await conn.query(
                    `INSERT INTO moderator_permission (
                        community_id, user_id, 
                        can_manage_settings, can_manage_members, can_manage_posts, can_manage_comments,
                        created_at, updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())`,
                    [communityId, userId, true, true, true, true]
                );
            } catch (error) {
                // Ignore duplicate key errors (might already have permissions from before)
                if (error.code !== 'ER_DUP_ENTRY') {
                    throw error;
                }
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE_MEMBER_ROLE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                updatedBy, 
                communityId, 
                JSON.stringify({ user_id: userId, role })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Get user details
        const [user] = await conn.query(
            "SELECT username FROM user WHERE id = ?",
            [userId]
        );
        
        return {
            community_id: communityId,
            user_id: userId,
            username: user.username,
            role,
            joined_at: existingMember.joined_at
        };
    } catch (error) {
        console.error("Error updating community member role:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community member role');
    } finally {
        if (conn) conn.end();
    }
}

export async function removeCommunityMember(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if member exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingMember) {
            return false;
        }
        
        // Remove member
        await conn.query(
            "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Also remove any moderator permissions
        if (existingMember.role === 'moderator' || existingMember.role === 'admin') {
            await conn.query(
                "DELETE FROM moderator_permission WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'LEAVE'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Update user statistics
        await conn.query(
            "UPDATE user_statistic SET communities_joined = GREATEST(0, communities_joined - 1) WHERE user_id = ?",
            [userId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return true;
    } catch (error) {
        console.error("Error removing community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to remove community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityMember(communityId: string, userId: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
        const [member] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        console.log("Query result:", member);
        return member || null;
    } catch (error) {
        console.error("Error fetching community member:", error);
        throw new Error('Failed to fetch community member');
    } finally {
        if (conn) conn.end();
    }
}

// Community Join Request operations
export async function getJoinRequests(communityId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        let query = "SELECT * FROM community_join_request WHERE community_id = ?";
        const params: any[] = [communityId];
        
        if (status) {
            query += " AND status = ?";
            params.push(status);
        }
        
        const requests = await conn.query(query, params);
        return requests;
    } catch (error) {
        console.error("Error fetching join requests:", error);
        throw new Error('Failed to fetch join requests');
    } finally {
        if (conn) conn.end();
    }
}

export async function createJoinRequest(communityId: string, userId: string): Promise<JoinRequest> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Check if user is already a member
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            throw new Error('User is already a member of this community');
        }
        
        // Check if request already exists
        const [existingRequest] = await conn.query(
            "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
            [communityId, userId]
        );
        
        if (existingRequest) {
            throw new Error('Join request already exists');
        }
        
        // Create join request
        await conn.query(
            "INSERT INTO community_join_request (id, community_id, user_id, status, requested_at, updated_at) VALUES (?, ?, ?, 'pending', NOW(), NOW())",
            [id, communityId, userId]
        );
        
        // Get the created request
        const [newRequest] = await conn.query(
            "SELECT * FROM community_join_request WHERE id = ?",
            [id]
        );
        
        return newRequest;
    } catch (error) {
        console.error("Error creating join request:", error);
        throw error;
    } finally {
        if (conn) conn.end();
    }
}

export async function updateJoinRequest(requestId: string, status: 'approved' | 'rejected', moderatorId: string): Promise<JoinRequest | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the request
        const [request] = await conn.query(
            "SELECT * FROM community_join_request WHERE id = ?",
            [requestId]
        );
        
        if (!request) {
            return null;
        }
        
        // Update the request status
        await conn.query(
            "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
            [status, requestId]
        );
        
        // If approved, add the user as a community member
        if (status === 'approved') {
            await addCommunityMember(request.community_id, request.user_id, 'member');
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = ?),
                ?, 'community_join_request', ?, NOW()
            )`,
            [
                activityId, 
                moderatorId, 
                status === 'approved' ? 'APPROVE' : 'REJECT',
                requestId, 
                JSON.stringify({ community_id: request.community_id, user_id: request.user_id })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Get the updated request
        const [updatedRequest] = await conn.query(
            "SELECT * FROM community_join_request WHERE id = ?",
            [requestId]
        );
        
        return updatedRequest || null;
    } catch (error) {
        console.error("Error updating join request:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update join request');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityAbout(communityId: string): Promise<any | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get community details
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return null;
        }
        
        // Get moderators
        const moderators = await conn.query(
            `SELECT cm.*, u.username 
             FROM community_member cm
             JOIN user u ON cm.user_id = u.id
             WHERE cm.community_id = ? AND cm.role IN ('moderator', 'admin')`,
            [communityId]
        );
        
        // Get member count
        const [memberCountRow] = await conn.query(
            "SELECT COUNT(*) as count FROM community_member WHERE community_id = ?",
            [communityId]
        );
        
        // Get post count
        const [postCountRow] = await conn.query(
            "SELECT COUNT(*) as count FROM post WHERE community_id = ?",
            [communityId]
        );
        
        // Get creation date and format it
        const creationDate = new Date(community.created_at);
        const creationDateString = creationDate.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        });
        
        return {
            ...community,
            moderators,
            memberCount: memberCountRow.count,
            postCount: postCountRow.count,
            creationDateFormatted: creationDateString
        };
    } catch (error) {
        console.error("Error fetching community about:", error);
        throw new Error('Failed to fetch community about');
    } finally {
        if (conn) conn.end();
    }
}

export async function getUserCommunities(userId: string): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query(
            `SELECT c.*, cm.role
             FROM community c
             JOIN community_member cm ON c.id = cm.community_id
             WHERE cm.user_id = ?`,
            [userId]
        );
        return communities;
    } catch (error) {
        console.error("Error fetching user communities:", error);
        throw new Error('Failed to fetch user communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function searchCommunities(query: string): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Prepare the search query - simple LIKE search for now
        const searchPattern = `%${query}%`;
        
        const communities = await conn.query(
            `SELECT * FROM community 
             WHERE name LIKE ? OR description LIKE ? 
             ORDER BY name`,
            [searchPattern, searchPattern]
        );
        
        return communities;
    } catch (error) {
        console.error("Error searching communities:", error);
        throw new Error('Failed to search communities');
    } finally {
        if (conn) conn.end();
    }
}

================
File: backend/api/communities.ts.new
================
// backend/api/communities.ts
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Community {
    id: string;
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityInput {
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    creator_id?: string;
}

export interface CommunityRule {
    id: string;
    community_id: string;
    title: string;
    description: string;
    position: number;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityRuleInput {
    title: string;
    description: string;
    position?: number;
}

export interface CommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    allow_post_videos: boolean;
    allow_polls: boolean;
    require_post_flair: boolean;
    show_in_discovery: boolean;
    join_method: 'auto_approve' | 'requires_approval' | 'invite_only';
    content_filter_level: 'none' | 'low' | 'medium' | 'high';
    updated_at: Date;
}

export interface CommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    allow_post_videos?: boolean;
    allow_polls?: boolean;
    require_post_flair?: boolean;
    show_in_discovery?: boolean;
    join_method?: 'auto_approve' | 'requires_approval' | 'invite_only';
    content_filter_level?: 'none' | 'low' | 'medium' | 'high';
}

export interface CommunityMember {
    community_id: string;
    user_id: string;
    role: 'member' | 'moderator' | 'admin';
    joined_at: Date;
}

export interface JoinRequest {
    id: string;
    community_id: string;
    user_id: string;
    status: 'pending' | 'approved' | 'rejected';
    requested_at: Date;
    updated_at: Date;
}

// Community CRUD operations
export async function getCommunities(): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query("SELECT * FROM community");
        return communities;
    } catch (error) {
        console.error("Error fetching communities:", error);
        throw new Error('Failed to fetch communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunity(communityId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query("SELECT * FROM community WHERE id = ?", [communityId]);
        return community || null;
    } catch (error) {
        console.error("Error fetching community:", error);
        throw new Error('Failed to fetch community');
    } finally {
        if (conn) conn.end();
    }
}

export async function createCommunity(communityData: CommunityInput): Promise<Community> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Include all fields in the insert
        await conn.query(
            `INSERT INTO community (
                id, name, description, privacy, icon_url, banner_url, theme_color
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                id, 
                communityData.name, 
                communityData.description, 
                communityData.privacy || 'public',
                communityData.icon_url || null,
                communityData.banner_url || null,
                communityData.theme_color || null
            ]
        );
        
        // Create default settings for the community
        await conn.query(
            `INSERT INTO community_setting (
                community_id, allow_post_images, allow_post_links, allow_post_videos,
                allow_polls, require_post_flair, show_in_discovery,
                join_method, content_filter_level
            ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
            [id]
        );
        
        // Log activity if creator_id is provided
        if (communityData.creator_id) {
            const activityId = uuidv4();
            await conn.query(
                `INSERT INTO activity (
                    id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
                ) VALUES (
                    ?, ?, 
                    (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                    (SELECT id FROM action WHERE name = 'CREATE'),
                    ?, 'community', NOW()
                )`,
                [activityId, communityData.creator_id, id]
            );
        }
        
        // Commit the transaction
        await conn.commit();
        
        const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
        return newCommunity;
    } catch (error) {
        console.error("Error creating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to create community');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunity(communityId: string, communityData: Partial<CommunityInput>, userId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (communityData.name !== undefined) {
            updates.push("name = ?");
            values.push(communityData.name);
        }
        
        if (communityData.description !== undefined) {
            updates.push("description = ?");
            values.push(communityData.description);
        }
        
        if (communityData.privacy !== undefined) {
            updates.push("privacy = ?");
            values.push(communityData.privacy);
        }
        
        if (communityData.icon_url !== undefined) {
            updates.push("icon_url = ?");
            values.push(communityData.icon_url);
        }
        
        if (communityData.banner_url !== undefined) {
            updates.push("banner_url = ?");
            values.push(communityData.banner_url);
        }
        
        if (communityData.theme_color !== undefined) {
            updates.push("theme_color = ?");
            values.push(communityData.theme_color);
        }
        
        if (updates.length === 0) {
            // No fields to update
            return await getCommunity(communityId);
        }
        
        // Add the ID to the values array
        values.push(communityId);
        
        await conn.query(
            `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return await getCommunity(communityId);
    } catch (error) {
        console.error("Error updating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunity(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction to ensure all related data is deleted
        await conn.beginTransaction();
        
        // Delete community settings
        await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
        
        // Delete community rules
        await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
        
        // Delete community members
        await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
        
        // Delete join requests
        await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
        
        // Log activity before deleting the community
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Delete the community itself
        const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community');
    } finally {
        if (conn) conn.end();
    }
}

// Community Rules operations
export async function getCommunityRules(communityId: string): Promise<CommunityRule[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const rules = await conn.query(
            "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
            [communityId]
        );
        return rules;
    } catch (error) {
        console.error("Error fetching community rules:", error);
        throw new Error('Failed to fetch community rules');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityRule(communityId: string, ruleData: CommunityRuleInput, userId: string): Promise<CommunityRule> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the highest position to determine the next position
        const [positionResult] = await conn.query(
            "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
            [communityId]
        );
        const nextPosition = (positionResult.maxPosition || 0) + 1;
        
        await conn.query(
            "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
            [id, communityId, ruleData.title, ruleData.description, ruleData.position || nextPosition]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, id]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [id]
        );
        return newRule;
    } catch (error) {
        console.error("Error adding community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityRule(ruleId: string, ruleData: Partial<CommunityRuleInput>, userId: string): Promise<CommunityRule | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (ruleData.title !== undefined) {
            updates.push("title = ?");
            values.push(ruleData.title);
        }
        
        if (ruleData.description !== undefined) {
            updates.push("description = ?");
            values.push(ruleData.description);
        }
        
        if (ruleData.position !== undefined) {
            updates.push("position = ?");
            values.push(ruleData.position);
        }
        
        if (updates.length === 0) {
            // No fields to update
            const [rule] = await conn.query(
                "SELECT * FROM community_rule WHERE id = ?",
                [ruleId]
            );
            return rule || null;
        }
        
        // Add the ID to the values array
        values.push(ruleId);
        
        await conn.query(
            `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [updatedRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [ruleId]
        );
        return updatedRule || null;
    } catch (error) {
        console.error("Error updating community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunityRule(ruleId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the rule to log its community_id
        const [rule] = await conn.query(
            "SELECT community_id FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        if (!rule) {
            return false;
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community_rule', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                ruleId, 
                JSON.stringify({ community_id: rule.community_id })
            ]
        );
        
        // Delete the rule
        const result = await conn.query(
            "DELETE FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community rule');
    } finally {
        if (conn) conn.end();
    }
}

// Community Settings operations
export async function getCommunitySettings(communityId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get settings from the community_setting table
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        // If settings don't exist, create default settings
        if (!settings) {
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, allow_post_videos,
                    allow_polls, require_post_flair, show_in_discovery,
                    join_method, content_filter_level
                ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
                [communityId]
            );
            
            const [newSettings] = await conn.query(
                "SELECT * FROM community_setting WHERE community_id = ?",
                [communityId]
            );
            return newSettings;
        }
        
        return settings;
    } catch (error) {
        console.error("Error fetching community settings:", error);
        throw new Error('Failed to fetch community settings');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunitySettings(communityId: string, settingsData: CommunitySettingsInput, userId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create settings if they don't exist
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, allow_post_videos,
                    allow_polls, require_post_flair, show_in_discovery,
                    join_method, content_filter_level
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    settingsData.allow_post_images !== undefined ? settingsData.allow_post_images : true,
                    settingsData.allow_post_links !== undefined ? settingsData.allow_post_links : true,
                    settingsData.allow_post_videos !== undefined ? settingsData.allow_post_videos : true,
                    settingsData.allow_polls !== undefined ? settingsData.allow_polls : true,
                    settingsData.require_post_flair !== undefined ? settingsData.require_post_flair : false,
                    settingsData.show_in_discovery !== undefined ? settingsData.show_in_discovery : true,
                    settingsData.join_method !== undefined ? settingsData.join_method : 'auto_approve',
                    settingsData.content_filter_level !== undefined ? settingsData.content_filter_level : 'none'
                ]
            );
        } else {
            // Build the update query dynamically based on provided fields
            const updates: string[] = [];
            const values: any[] = [];
            
            if (settingsData.allow_post_images !== undefined) {
                updates.push("allow_post_images = ?");
                values.push(settingsData.allow_post_images);
            }
            
            if (settingsData.allow_post_links !== undefined) {
                updates.push("allow_post_links = ?");
                values.push(settingsData.allow_post_links);
            }
            
            if (settingsData.allow_post_videos !== undefined) {
                updates.push("allow_post_videos = ?");
                values.push(settingsData.allow_post_videos);
            }
            
            if (settingsData.allow_polls !== undefined) {
                updates.push("allow_polls = ?");
                values.push(settingsData.allow_polls);
            }
            
            if (settingsData.require_post_flair !== undefined) {
                updates.push("require_post_flair = ?");
                values.push(settingsData.require_post_flair);
            }
            
            if (settingsData.show_in_discovery !== undefined) {
                updates.push("show_in_discovery = ?");
                values.push(settingsData.show_in_discovery);
            }
            
            if (settingsData.join_method !== undefined) {
                updates.push("join_method = ?");
                values.push(settingsData.join_method);
            }
            
            if (settingsData.content_filter_level !== undefined) {
                updates.push("content_filter_level = ?");
                values.push(settingsData.content_filter_level);
            }
            
            if (updates.length > 0) {
                // Add the community ID to the values array
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_setting', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated settings
        const [updatedSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        return updatedSettings;
    } catch (error) {
        console.error("Error updating community settings:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community settings');
    } finally {
        if (conn) conn.end();
    }
}

// Community Members operations
export async function getCommunityMembers(communityId: string): Promise<CommunityMember[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const members = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ?",
            [communityId]
        );
        return members;
    } catch (error) {
        console.error("Error fetching community members:", error);
        throw new Error('Failed to fetch community members');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityMember(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin' = 'member'): Promise<CommunityMember> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if the member already exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // If the member already exists, update their role if different
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // Commit the transaction
            await conn.commit();
            
            return existingMember;
        }
        
        // Add the new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
            [communityId, userId, role]
        );
        
        // Update user statistics
        await conn.query(
            `UPDATE user_statistic 
             SET communities_joined = communities_joined + 1
             WHERE user_id = ?`,
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        return newMember;
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityMemberRole(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin', updatedBy: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Update the member's role
        await conn.query(
            "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
            [role, communityId, userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_member', ?, NOW()
            )`,
            [
                activityId, 
                updatedBy, 
                userId, 
                JSON.stringify({ 
                    community_id: communityId,
                    user_id: userId,
                    new_role: role
                })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated member
        const [updatedMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        return updatedMember || null;
    } catch (error) {
        console.error("Error updating community member role:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community member role');
    } finally {
        if (conn) conn.end();
    }
}

export async function removeCommunityMember(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Log activity before removing the member
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'LEAVE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Remove the member
        const result = await conn.query(
            "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Update user statistics
        if (result.affectedRows > 0) {
            await conn.query(
                `UPDATE user_statistic 
                 SET communities_joined = GREATEST(communities_joined - 1, 0)
                 WHERE user_id = ?`,
                [userId]
            );
        }
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error removing community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to remove community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityMember(communityId: string, userId: string): Promise<CommunityMember | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
}

// Community Join Request operations
export async function getJoinRequests(communityId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params: any[] = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
}

export async function getJoinRequest(requestId: string): Promise<JoinRequest | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function createJoinRequest(communityId: string, userId: string): Promise<JoinRequest> {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function updateJoinRequestStatus(
  requestId: string, 
  status: 'approved' | 'rejected', 
  updatedBy: string
): Promise<JoinRequest | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request || request.status !== 'pending') {
      // Only pending requests can be updated
      await conn.rollback();
      return null;
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
      [status, requestId]
    );
    
    // If approved, add the user as a community member
    if (status === 'approved') {
      await conn.query(
        "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, 'member') " +
        "ON DUPLICATE KEY UPDATE role = 'member'",
        [request.community_id, request.user_id]
      );
      
      // Update user statistics
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = communities_joined + 1
         WHERE user_id = ?`,
        [request.user_id]
      );
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id,
          status: status
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest || null;
  } catch (error) {
    console.error("Error updating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function deleteJoinRequest(requestId: string, userId: string): Promise<boolean> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the request to log its details
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Delete the request
    const result = await conn.query(
      "DELETE FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function getUserJoinRequests(userId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE user_id = ?";
    const params: any[] = [userId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching user join requests:", error);
    throw new Error('Failed to fetch user join requests');
  } finally {
    if (conn) conn.end();
  }
}

================
File: backend/api/community_fix.js
================
// This script temporarily patche the implementation of getCommunityAbout
// to ensure the API returns proper data format.

const fs = require('fs');
const path = require('path');

// File to patch
const filePath = path.join(__dirname, 'communities.js');

// Read the file
fs.readFile(filePath, 'utf8', (err, data) => {
  if (err) {
    console.error(`Error reading the file: ${err}`);
    return;
  }

  // Define the patch for the getCommunityAbout function
  const patchedFunction = `// Enhanced community information
const getCommunityAbout = async (communityId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Get the community
    const [community] = await conn.query(
      "SELECT * FROM communities WHERE id = ?", 
      [communityId]
    );
    
    if (!community) {
      return null;
    }
    
    // Get member count - fixed to properly extract count from result set
    let memberCount = 0;
    try {
      const memberCountResults = await conn.query(
        "SELECT COUNT(*) as count FROM community_members WHERE community_id = ?",
        [communityId]
      );
      
      // MariaDB returns count in first row, first column named 'count'
      if (memberCountResults && memberCountResults[0] && 
          memberCountResults[0].count !== undefined) {
        memberCount = memberCountResults[0].count;
      }
    } catch (error) {
      console.log("Error getting member count:", error.message);
    }
    
    // Get post count - with proper error handling
    let postCount = 0;
    try {
      const postCountResults = await conn.query(
        "SELECT COUNT(*) as count FROM posts WHERE community_id = ?",
        [communityId]
      );
      
      // MariaDB returns count in first row, first column named 'count'
      if (postCountResults && postCountResults[0] && 
          postCountResults[0].count !== undefined) {
        postCount = postCountResults[0].count;
      }
    } catch (error) {
      console.log("Note: posts table may not exist yet or error occurred:", error.message);
    }
    
    // Get moderators
    let moderatorIds = [];
    try {
      const moderators = await conn.query(
        "SELECT user_id FROM community_members WHERE community_id = ? AND (role = 'moderator' OR role = 'admin')",
        [communityId]
      );
      
      if (moderators && Array.isArray(moderators)) {
        moderatorIds = moderators.map(m => m.user_id);
      }
    } catch (error) {
      console.log("Error getting moderators:", error.message);
    }
    
    // Format the response to match frontend expectations
    return {
      id: community.id,
      name: community.name,
      description: community.description,
      privacy: community.privacy || 'public',
      created_at: community.created_at,
      updated_at: community.updated_at,
      memberCount: memberCount,
      postCount: postCount,
      moderators: moderatorIds
    };
  } catch (error) {
    console.error("Error fetching community about:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};`;

  // Find the getCommunityAbout implementation and replace it
  const regex = /\/\/ Enhanced community information[\s\S]*?const getCommunityAbout[\s\S]*?};/g;
  
  // Check if the function exists in the file
  if (!regex.test(data)) {
    console.error('Could not find getCommunityAbout function in the file');
    return;
  }
  
  // Replace the function with our patched version
  const updatedContent = data.replace(regex, patchedFunction);
  
  // Write the updated content back to the file
  fs.writeFile(filePath, updatedContent, 'utf8', (err) => {
    if (err) {
      console.error(`Error writing to the file: ${err}`);
      return;
    }
    console.log('Successfully patched communities.js');
  });
});

console.log('Attempting to patch communities.js file...');

================
File: backend/api/community/community-core.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community CRUD operations
const getCommunities = async () => {
  let conn;
  try {
    conn = await pool.getConnection();
    const communities = await conn.query("SELECT * FROM community");
    return communities;
  } catch (error) {
    console.error("Error fetching communities:", error);
    throw new Error('Failed to fetch communities');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunity = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    return community || null;
  } catch (error) {
    console.error("Error fetching community:", error);
    throw new Error('Failed to fetch community');
  } finally {
    if (conn) conn.end();
  }
};

const createCommunity = async (communityData) => {
  const { name, description, privacy, icon_url, banner_url, theme_color, creator_id } = communityData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Include all fields in the insert
    await conn.query(
      `INSERT INTO community (
        id, name, description, privacy, icon_url, banner_url, theme_color
      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        id, 
        name, 
        description, 
        privacy || 'public',
        icon_url || null,
        banner_url || null,
        theme_color || null
      ]
    );
    
    // Create default settings for the community
    await conn.query(
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, allow_post_videos,
        allow_polls, require_post_flair, show_in_discovery,
        join_method, content_filter_level
      ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
      [id]
    );
    
    // Log activity if creator_id is provided
    if (creator_id) {
      const activityId = uuidv4();
      await conn.query(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'community', NOW()
        )`,
        [activityId, creator_id, id]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
    return newCommunity;
  } catch (error) {
    console.error("Error creating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create community');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunity = async (communityId, communityData, userId) => {
  const { name, description, privacy, icon_url, banner_url, theme_color } = communityData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (name !== undefined) {
      updates.push("name = ?");
      values.push(name);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (privacy !== undefined) {
      updates.push("privacy = ?");
      values.push(privacy);
    }
    
    if (icon_url !== undefined) {
      updates.push("icon_url = ?");
      values.push(icon_url);
    }
    
    if (banner_url !== undefined) {
      updates.push("banner_url = ?");
      values.push(banner_url);
    }
    
    if (theme_color !== undefined) {
      updates.push("theme_color = ?");
      values.push(theme_color);
    }
    
    if (updates.length === 0) {
      // No fields to update
      return await getCommunity(communityId);
    }
    
    // Add the ID to the values array
    values.push(communityId);
    
    await conn.query(
      `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return await getCommunity(communityId);
  } catch (error) {
    console.error("Error updating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunity = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction to ensure all related data is deleted
    await conn.beginTransaction();
    
    // Delete community settings
    await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
    
    // Delete community rules
    await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
    
    // Delete community members
    await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
    
    // Delete join requests
    await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
    
    // Log activity before deleting the community
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Delete the community itself
    const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunities,
  getCommunity,
  createCommunity,
  updateCommunity,
  deleteCommunity
};

================
File: backend/api/community/community-members.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Members operations
const getCommunityMembers = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const members = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ?",
      [communityId]
    );
    return members;
  } catch (error) {
    console.error("Error fetching community members:", error);
    throw new Error('Failed to fetch community members');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityMember = async (communityId, userId, role = 'member') => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if the member already exists
    const [existingMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    if (existingMember) {
      // If the member already exists, update their role if different
      if (existingMember.role !== role) {
        await conn.query(
          "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
          [role, communityId, userId]
        );
      }
      
      // Commit the transaction
      await conn.commit();
      
      return existingMember;
    }
    
    // Add the new member
    await conn.query(
      "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
      [communityId, userId, role]
    );
    
    // Update user statistics
    await conn.query(
      `UPDATE user_statistic 
       SET communities_joined = communities_joined + 1
       WHERE user_id = ?`,
      [userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return newMember;
  } catch (error) {
    console.error("Error adding community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community member');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityMemberRole = async (communityId, userId, role, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Update the member's role
    await conn.query(
      "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
      [role, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_member', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        userId, 
        JSON.stringify({ 
          community_id: communityId,
          user_id: userId,
          new_role: role
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated member
    const [updatedMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return updatedMember || null;
  } catch (error) {
    console.error("Error updating community member role:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community member role');
  } finally {
    if (conn) conn.end();
  }
};

const removeCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Log activity before removing the member
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Remove the member
    const result = await conn.query(
      "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    // Update user statistics
    if (result.affectedRows > 0) {
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = GREATEST(communities_joined - 1, 0)
         WHERE user_id = ?`,
        [userId]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error removing community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to remove community member');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunityMembers,
  getCommunityMember,
  addCommunityMember,
  updateCommunityMemberRole,
  removeCommunityMember
};

================
File: backend/api/community/community-requests.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Import the addCommunityMember function from community-members.js
const { addCommunityMember } = require('./community-members');

// Community Join Request operations
const getJoinRequests = async (communityId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
};

const getJoinRequest = async (requestId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
};

const createJoinRequest = async (communityId, userId) => {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
};

const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      throw new Error('Join request not found');
    }
    
    if (request.status !== 'pending') {
      throw new Error('Join request has already been processed');
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW(), updated_by = ? WHERE id = ?",
      [status, updatedBy, requestId]
    );
    
    // If the request is approved, add the user to the community
    if (status === 'approved') {
      await addCommunityMember(request.community_id, request.user_id, 'member');
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          status,
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest;
  } catch (error) {
    console.error("Error updating join request status:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request status: ' + error.message);
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getJoinRequests,
  getJoinRequest,
  createJoinRequest,
  updateJoinRequestStatus
};

================
File: backend/api/community/community-rules.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Rules operations
const getCommunityRules = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const rules = await conn.query(
      "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
      [communityId]
    );
    return rules;
  } catch (error) {
    console.error("Error fetching community rules:", error);
    throw new Error('Failed to fetch community rules');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityRule = async (communityId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the highest position to determine the next position
    const [positionResult] = await conn.query(
      "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
      [communityId]
    );
    const nextPosition = (positionResult.maxPosition || 0) + 1;
    
    await conn.query(
      "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
      [id, communityId, title, description, position || nextPosition]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [id]
    );
    return newRule;
  } catch (error) {
    console.error("Error adding community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community rule');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityRule = async (ruleId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (title !== undefined) {
      updates.push("title = ?");
      values.push(title);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (position !== undefined) {
      updates.push("position = ?");
      values.push(position);
    }
    
    if (updates.length === 0) {
      // No fields to update
      const [rule] = await conn.query(
        "SELECT * FROM community_rule WHERE id = ?",
        [ruleId]
      );
      return rule || null;
    }
    
    // Add the ID to the values array
    values.push(ruleId);
    
    await conn.query(
      `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [updatedRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [ruleId]
    );
    return updatedRule || null;
  } catch (error) {
    console.error("Error updating community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community rule');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunityRule = async (ruleId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the rule to log its community_id
    const [rule] = await conn.query(
      "SELECT community_id FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    if (!rule) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_rule', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        ruleId, 
        JSON.stringify({ community_id: rule.community_id })
      ]
    );
    
    // Delete the rule
    const result = await conn.query(
      "DELETE FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community rule');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunityRules,
  addCommunityRule,
  updateCommunityRule,
  deleteCommunityRule
};

================
File: backend/api/community/community-search.js
================
const mariadb = require('mariadb');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Search operations
const searchCommunities = async (searchTerm, limit = 20, offset = 0) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Search for communities by name or description
    const communities = await conn.query(
      `SELECT c.*, 
        (SELECT COUNT(*) FROM community_member WHERE community_id = c.id) as member_count
       FROM community c
       WHERE c.name LIKE ? OR c.description LIKE ?
       ORDER BY member_count DESC, c.created_at DESC
       LIMIT ? OFFSET ?`,
      [`%${searchTerm}%`, `%${searchTerm}%`, limit, offset]
    );
    
    return communities;
  } catch (error) {
    console.error("Error searching communities:", error);
    throw new Error('Failed to search communities');
  } finally {
    if (conn) conn.end();
  }
};

const getDiscoverableCommunities = async (limit = 20, offset = 0) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get communities that are set to be discoverable
    const communities = await conn.query(
      `SELECT c.*, 
        (SELECT COUNT(*) FROM community_member WHERE community_id = c.id) as member_count
       FROM community c
       JOIN community_setting cs ON c.id = cs.community_id
       WHERE cs.show_in_discovery = TRUE
       ORDER BY member_count DESC, c.created_at DESC
       LIMIT ? OFFSET ?`,
      [limit, offset]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching discoverable communities:", error);
    throw new Error('Failed to fetch discoverable communities');
  } finally {
    if (conn) conn.end();
  }
};

const getTrendingCommunities = async (limit = 10) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get trending communities based on recent activity
    const communities = await conn.query(
      `SELECT c.*, 
        COUNT(DISTINCT cm.user_id) as member_count,
        COUNT(DISTINCT a.id) as recent_activity_count
       FROM community c
       LEFT JOIN community_member cm ON c.id = cm.community_id
       LEFT JOIN activity a ON a.entity_id = c.id 
         AND a.entity_type = 'community'
         AND a.created_at > DATE_SUB(NOW(), INTERVAL 7 DAY)
       JOIN community_setting cs ON c.id = cs.community_id
       WHERE cs.show_in_discovery = TRUE
       GROUP BY c.id
       ORDER BY recent_activity_count DESC, member_count DESC
       LIMIT ?`,
      [limit]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching trending communities:", error);
    throw new Error('Failed to fetch trending communities');
  } finally {
    if (conn) conn.end();
  }
};

const getRecommendedCommunities = async (userId, limit = 10) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get recommended communities based on user's interests and activity
    // This is a simplified recommendation algorithm
    const communities = await conn.query(
      `SELECT c.*, 
        COUNT(DISTINCT cm.user_id) as member_count
       FROM community c
       JOIN community_member cm ON c.id = cm.community_id
       JOIN community_setting cs ON c.id = cs.community_id
       WHERE cs.show_in_discovery = TRUE
       AND c.id NOT IN (
         SELECT community_id FROM community_member WHERE user_id = ?
       )
       AND cm.user_id IN (
         -- Users who are in the same communities as this user
         SELECT DISTINCT cm2.user_id 
         FROM community_member cm1
         JOIN community_member cm2 ON cm1.community_id = cm2.community_id
         WHERE cm1.user_id = ? AND cm2.user_id != ?
       )
       GROUP BY c.id
       ORDER BY member_count DESC
       LIMIT ?`,
      [userId, userId, userId, limit]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching recommended communities:", error);
    throw new Error('Failed to fetch recommended communities');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  searchCommunities,
  getDiscoverableCommunities,
  getTrendingCommunities,
  getRecommendedCommunities
};

================
File: backend/api/community/community-settings.js
================
const mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community Settings operations
const getCommunitySettings = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get settings from the community_setting table
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    // If settings don't exist, create default settings
    if (!settings) {
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
        [communityId]
      );
      
      const [newSettings] = await conn.query(
        "SELECT * FROM community_setting WHERE community_id = ?",
        [communityId]
      );
      return newSettings;
    }
    
    return settings;
  } catch (error) {
    console.error("Error fetching community settings:", error);
    throw new Error('Failed to fetch community settings');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunitySettings = async (communityId, settingsData, userId) => {
  const { 
    allow_post_images, 
    allow_post_links, 
    allow_post_videos,
    allow_polls,
    require_post_flair,
    show_in_discovery,
    join_method,
    content_filter_level
  } = settingsData;
  
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if settings exist
    const [existingSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (!existingSettings) {
      // Create settings if they don't exist
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          communityId,
          allow_post_images !== undefined ? allow_post_images : true,
          allow_post_links !== undefined ? allow_post_links : true,
          allow_post_videos !== undefined ? allow_post_videos : true,
          allow_polls !== undefined ? allow_polls : true,
          require_post_flair !== undefined ? require_post_flair : false,
          show_in_discovery !== undefined ? show_in_discovery : true,
          join_method !== undefined ? join_method : 'auto_approve',
          content_filter_level !== undefined ? content_filter_level : 'none'
        ]
      );
    } else {
      // Build the update query dynamically based on provided fields
      const updates = [];
      const values = [];
      
      if (allow_post_images !== undefined) {
        updates.push("allow_post_images = ?");
        values.push(allow_post_images);
      }
      
      if (allow_post_links !== undefined) {
        updates.push("allow_post_links = ?");
        values.push(allow_post_links);
      }
      
      if (allow_post_videos !== undefined) {
        updates.push("allow_post_videos = ?");
        values.push(allow_post_videos);
      }
      
      if (allow_polls !== undefined) {
        updates.push("allow_polls = ?");
        values.push(allow_polls);
      }
      
      if (require_post_flair !== undefined) {
        updates.push("require_post_flair = ?");
        values.push(require_post_flair);
      }
      
      if (show_in_discovery !== undefined) {
        updates.push("show_in_discovery = ?");
        values.push(show_in_discovery);
      }
      
      if (join_method !== undefined) {
        updates.push("join_method = ?");
        values.push(join_method);
      }
      
      if (content_filter_level !== undefined) {
        updates.push("content_filter_level = ?");
        values.push(content_filter_level);
      }
      
      if (updates.length > 0) {
        // Add the community ID to the values array
        values.push(communityId);
        
        await conn.query(
          `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
          values
        );
      }
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_setting', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated settings
    const [updatedSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    return updatedSettings;
  } catch (error) {
    console.error("Error updating community settings:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community settings');
  } finally {
    if (conn) conn.end();
  }
};

// Export the functions
module.exports = {
  getCommunitySettings,
  updateCommunitySettings
};

================
File: backend/api/community/index.js
================
/**
 * Community API Module
 * 
 * This module exports all community-related functions from the individual modules.
 * It serves as the main entry point for the community API.
 */

// Import all community modules
const communityCore = require('./community-core');
const communityRules = require('./community-rules');
const communitySettings = require('./community-settings');
const communityMembers = require('./community-members');
const communityRequests = require('./community-requests');
const communitySearch = require('./community-search');

// Re-export all functions
module.exports = {
  // Core operations
  getCommunities: communityCore.getCommunities,
  getCommunity: communityCore.getCommunity,
  createCommunity: communityCore.createCommunity,
  updateCommunity: communityCore.updateCommunity,
  deleteCommunity: communityCore.deleteCommunity,
  
  // Rules operations
  getCommunityRules: communityRules.getCommunityRules,
  addCommunityRule: communityRules.addCommunityRule,
  updateCommunityRule: communityRules.updateCommunityRule,
  deleteCommunityRule: communityRules.deleteCommunityRule,
  
  // Settings operations
  getCommunitySettings: communitySettings.getCommunitySettings,
  updateCommunitySettings: communitySettings.updateCommunitySettings,
  
  // Members operations
  getCommunityMembers: communityMembers.getCommunityMembers,
  getCommunityMember: communityMembers.getCommunityMember,
  addCommunityMember: communityMembers.addCommunityMember,
  updateCommunityMemberRole: communityMembers.updateCommunityMemberRole,
  removeCommunityMember: communityMembers.removeCommunityMember,
  
  // Join request operations
  getJoinRequests: communityRequests.getJoinRequests,
  getJoinRequest: communityRequests.getJoinRequest,
  createJoinRequest: communityRequests.createJoinRequest,
  updateJoinRequestStatus: communityRequests.updateJoinRequestStatus,
  
  // Search operations
  searchCommunities: communitySearch.searchCommunities,
  getDiscoverableCommunities: communitySearch.getDiscoverableCommunities,
  getTrendingCommunities: communitySearch.getTrendingCommunities,
  getRecommendedCommunities: communitySearch.getRecommendedCommunities
};

================
File: backend/api/community/README.md
================
# Community API Module

This directory contains the refactored Community API module, which has been split into smaller, more maintainable files.

## Module Structure

- `index.js` - Main entry point that re-exports all functions
- `community-core.js` - Basic CRUD operations for communities
- `community-rules.js` - Community rule management
- `community-settings.js` - Community settings operations
- `community-members.js` - Community member management
- `community-requests.js` - Join request handling
- `community-search.js` - Search and discovery functions

## Usage

### Importing the entire module

```javascript
const communityApi = require('./community');

// Use any function from the module
const communities = await communityApi.getCommunities();
const community = await communityApi.getCommunity(communityId);
```

### Importing specific functions

```javascript
const { getCommunity, createCommunity } = require('./community');

// Use the imported functions
const community = await getCommunity(communityId);
const newCommunity = await createCommunity(communityData);
```

### Importing from specific submodules

```javascript
// Import only the search functions
const communitySearch = require('./community/community-search');

// Use the search functions
const results = await communitySearch.searchCommunities('gaming');
const trending = await communitySearch.getTrendingCommunities();
```

## Database Schema

This module interacts with the following tables:

- `community` - Core community data
- `community_setting` - Community settings
- `community_rule` - Community rules
- `community_member` - Community membership
- `community_join_request` - Join requests
- `activity` - Activity logging
- `activity_type` - Activity type definitions
- `action` - Action type definitions

## Activity Logging

All operations that modify data include activity logging. The activity logs include:

- User who performed the action
- Type of activity (COMMUNITY, COMMUNITY_RULE, etc.)
- Action performed (CREATE, UPDATE, DELETE, etc.)
- Entity affected
- Timestamp
- Additional metadata where relevant

## Error Handling

All functions include proper error handling and will throw descriptive error messages if operations fail. Transactions are used to ensure data consistency, with automatic rollback on failure.

================
File: backend/api/moderation.ts
================
// backend/api/moderation.ts
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection';
import { RowDataPacket, ResultSetHeader } from 'mysql2/promise';

// Types
export interface ModeratorPermission {
    community_id: string;
    user_id: string;
    can_manage_settings: boolean;
    can_manage_members: boolean;
    can_manage_posts: boolean;
    can_manage_comments: boolean;
    created_at: Date;
    updated_at: Date;
}

export interface ModeratorPermissionInput {
    can_manage_settings?: boolean;
    can_manage_members?: boolean;
    can_manage_posts?: boolean;
    can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface PostModeration {
    post_id: string;
    status: 'pending' | 'approved' | 'rejected';
    moderator_id: string | null;
    reason: string | null;
    moderated_at: Date | null;
    created_at: Date;
}

export interface ModerationLog {
    id: string;
    community_id: string;
    moderator_id: string;
    action_type: string;
    entity_type: string;
    entity_id: string;
    reason: string | null;
    metadata: any | null;
    created_at: Date;
}

export interface BannedUser {
    community_id: string;
    user_id: string;
    reason: string | null;
    banned_by: string;
    expires_at: Date | null;
    created_at: Date;
}

// Define interfaces for query results
interface ModeratorPermissionRow extends RowDataPacket, ModeratorPermission {}
interface CommunitySettingsRow extends RowDataPacket, ExtendedCommunitySettings {}
interface PostModerationRow extends RowDataPacket, PostModeration {}
interface ModerationLogRow extends RowDataPacket, ModerationLog {}
interface BannedUserRow extends RowDataPacket, BannedUser {}
interface UserRow extends RowDataPacket {
    id: string;
    username: string;
    role: string;
}

/**
 * Check if a user is a moderator for a community
 */
export async function isModerator(userId: string, communityId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a community moderator or admin
        const [rows] = await conn.query<UserRow[]>(
            `SELECT role FROM community_member 
             WHERE community_id = ? AND user_id = ? 
             AND (role = 'moderator' OR role = 'admin')`,
            [communityId, userId]
        );
        
        if (!rows || rows.length === 0) {
            return false;
        }
        
        const member = rows[0];
        return Boolean(member && (member.role === 'moderator' || member.role === 'admin'));
    } catch (error) {
        console.error('Error checking if user is moderator:', error);
        return false;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Check if a moderator has a specific permission
 */
export async function hasModeratorPermission(
    userId: string, 
    communityId: string, 
    permission: 'can_manage_settings' | 'can_manage_members' | 'can_manage_posts' | 'can_manage_comments'
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // First, check if user is community admin (can do everything)
        const [memberRows] = await conn.query<UserRow[]>(
            `SELECT role FROM community_member 
             WHERE community_id = ? AND user_id = ? AND role = 'admin'`,
            [communityId, userId]
        );
        
        const member = memberRows && memberRows.length > 0 ? memberRows[0] : null;
        if (member && member.role === 'admin') {
            return true;
        }
        
        // Check specific permission
        const [permissionRows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        const permissions = permissionRows && permissionRows.length > 0 ? permissionRows[0] : null;
        return permissions ? Boolean(permissions[permission]) : false;
    } catch (error) {
        console.error('Error checking moderator permission:', error);
        return false;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get moderator permissions for a user in a community
 */
export async function getModeratorPermissions(
    userId: string, 
    communityId: string
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        return rows && rows.length > 0 ? rows[0] : null;
    } catch (error) {
        console.error('Error getting moderator permissions:', error);
        return null;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Update moderator permissions
 */
export async function updateModeratorPermissions(
    userId: string, 
    communityId: string, 
    permissions: ModeratorPermissionInput
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a moderator
        const [memberRows] = await conn.query<UserRow[]>(
            `SELECT role FROM community_member 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        const member = memberRows && memberRows.length > 0 ? memberRows[0] : null;
        if (!member || (member.role !== 'moderator' && member.role !== 'admin')) {
            throw new Error('User is not a moderator of this community');
        }
        
        // Get existing permissions
        const [existingRows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        const now = new Date();
        
        if (existingRows && existingRows.length > 0) {
            // Update existing permissions
            await conn.query(
                `UPDATE moderator_permission SET
                 can_manage_settings = ?,
                 can_manage_members = ?,
                 can_manage_posts = ?,
                 can_manage_comments = ?,
                 updated_at = ?
                 WHERE community_id = ? AND user_id = ?`,
                [
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : existingRows[0].can_manage_settings,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : existingRows[0].can_manage_members,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : existingRows[0].can_manage_posts,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : existingRows[0].can_manage_comments,
                    now,
                    communityId,
                    userId
                ]
            );
        } else {
            // Create new permissions
            await conn.query(
                `INSERT INTO moderator_permission (
                 community_id, user_id, can_manage_settings, can_manage_members,
                 can_manage_posts, can_manage_comments, created_at, updated_at
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : true,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : true,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : true,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : true,
                    now,
                    now
                ]
            );
        }
        
        // Get updated permissions
        const [updatedRows] = await conn.query<ModeratorPermissionRow[]>(
            `SELECT * FROM moderator_permission 
             WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        return updatedRows && updatedRows.length > 0 ? updatedRows[0] : null;
    } catch (error) {
        console.error('Error updating moderator permissions:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get community settings
 */
export async function getCommunitySettings(communityId: string): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<CommunitySettingsRow[]>(
            `SELECT * FROM community_setting 
             WHERE community_id = ?`,
            [communityId]
        );
        
        return rows && rows.length > 0 ? rows[0] : null;
    } catch (error) {
        console.error('Error getting community settings:', error);
        return null;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Update community settings
 */
export async function updateCommunitySettings(
    communityId: string, 
    settings: ExtendedCommunitySettingsInput,
    moderatorId: string
): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if settings already exist
        const [existingRows] = await conn.query<CommunitySettingsRow[]>(
            `SELECT * FROM community_setting 
             WHERE community_id = ?`,
            [communityId]
        );
        
        const now = new Date();
        
        await conn.beginTransaction();
        
        try {
            if (existingRows && existingRows.length > 0) {
                // Update existing settings
                await conn.query(
                    `UPDATE community_setting SET
                     allow_post_images = ?,
                     allow_post_links = ?,
                     require_post_approval = ?,
                     restricted_words = ?,
                     custom_theme_color = ?,
                     custom_banner_url = ?,
                     minimum_account_age_days = ?,
                     minimum_karma_required = ?,
                     updated_at = ?
                     WHERE community_id = ?`,
                    [
                        settings.allow_post_images !== undefined ? settings.allow_post_images : existingRows[0].allow_post_images,
                        settings.allow_post_links !== undefined ? settings.allow_post_links : existingRows[0].allow_post_links,
                        settings.require_post_approval !== undefined ? settings.require_post_approval : existingRows[0].require_post_approval,
                        settings.restricted_words !== undefined ? settings.restricted_words : existingRows[0].restricted_words,
                        settings.custom_theme_color !== undefined ? settings.custom_theme_color : existingRows[0].custom_theme_color,
                        settings.custom_banner_url !== undefined ? settings.custom_banner_url : existingRows[0].custom_banner_url,
                        settings.minimum_account_age_days !== undefined ? settings.minimum_account_age_days : existingRows[0].minimum_account_age_days,
                        settings.minimum_karma_required !== undefined ? settings.minimum_karma_required : existingRows[0].minimum_karma_required,
                        now,
                        communityId
                    ]
                );
            } else {
                // Create new settings
                await conn.query(
                    `INSERT INTO community_setting (
                     community_id, allow_post_images, allow_post_links, require_post_approval,
                     restricted_words, custom_theme_color, custom_banner_url,
                     minimum_account_age_days, minimum_karma_required, updated_at
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                    [
                        communityId,
                        settings.allow_post_images !== undefined ? settings.allow_post_images : true,
                        settings.allow_post_links !== undefined ? settings.allow_post_links : true,
                        settings.require_post_approval !== undefined ? settings.require_post_approval : false,
                        settings.restricted_words || null,
                        settings.custom_theme_color || null,
                        settings.custom_banner_url || null,
                        settings.minimum_account_age_days !== undefined ? settings.minimum_account_age_days : 0,
                        settings.minimum_karma_required !== undefined ? settings.minimum_karma_required : 0,
                        now
                    ]
                );
            }
            
            // Log the settings update
            await logModerationAction(
                communityId,
                moderatorId,
                'UPDATE',
                'SETTINGS',
                communityId,
                null,
                { settings }
            );
            
            await conn.commit();
            
            // Get updated settings
            const [newSettingsRows] = await conn.query<CommunitySettingsRow[]>(
                `SELECT * FROM community_setting 
                 WHERE community_id = ?`,
                [communityId]
            );
            
            return newSettingsRows && newSettingsRows.length > 0 ? newSettingsRows[0] : null;
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error updating community settings:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get post moderation status
 */
export async function getPostModerationStatus(postId: string): Promise<PostModeration | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<PostModerationRow[]>(
            `SELECT * FROM post_moderation 
             WHERE post_id = ?`,
            [postId]
        );
        
        return rows && rows.length > 0 ? rows[0] : null;
    } catch (error) {
        console.error('Error getting post moderation status:', error);
        return null;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Update post moderation status
 */
export async function updatePostModerationStatus(
    postId: string,
    status: 'pending' | 'approved' | 'rejected',
    moderatorId: string,
    reason?: string
): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        await conn.beginTransaction();
        
        try {
            // Check if post moderation entry exists
            const [existingRows] = await conn.query<PostModerationRow[]>(
                `SELECT * FROM post_moderation 
                 WHERE post_id = ?`,
                [postId]
            );
            
            const now = new Date();
            
            if (existingRows && existingRows.length > 0) {
                // Update existing moderation status
                await conn.query(
                    `UPDATE post_moderation SET
                     status = ?,
                     moderator_id = ?,
                     reason = ?,
                     moderated_at = ?
                     WHERE post_id = ?`,
                    [
                        status,
                        moderatorId,
                        reason || null,
                        now,
                        postId
                    ]
                );
                
                // Get the post's community ID for logging
                const [postRows] = await conn.query<RowDataPacket[]>(
                    `SELECT community_id FROM post 
                     WHERE id = ?`,
                    [postId]
                );
                
                // Log the moderation action
                if (postRows && postRows.length > 0) {
                    await logModerationAction(
                        postRows[0].community_id,
                        moderatorId,
                        status === 'approved' ? 'APPROVE' : 'REJECT',
                        'POST',
                        postId,
                        reason || null,
                        { previousStatus: existingRows[0].status }
                    );
                }
                
                await conn.commit();
                
                // Get updated moderation status
                const [updatedRows] = await conn.query<PostModerationRow[]>(
                    `SELECT * FROM post_moderation 
                     WHERE post_id = ?`,
                    [postId]
                );
                
                if (!updatedRows || updatedRows.length === 0) {
                    throw new Error("Failed to retrieve updated post moderation status");
                }
                
                return updatedRows[0];
            } else {
                // Create new moderation status
                await conn.query(
                    `INSERT INTO post_moderation (
                     post_id, status, moderator_id, reason, moderated_at, created_at
                    ) VALUES (?, ?, ?, ?, ?, ?)`,
                    [
                        postId,
                        status,
                        moderatorId,
                        reason || null,
                        status === 'pending' ? null : now,
                        now
                    ]
                );
                
                // Get the post's community ID for logging
                const [postRows] = await conn.query<RowDataPacket[]>(
                    `SELECT community_id FROM post 
                     WHERE id = ?`,
                    [postId]
                );
                
                // Log the moderation action (only for approvals/rejections)
                if (status !== 'pending' && postRows && postRows.length > 0) {
                    await logModerationAction(
                        postRows[0].community_id,
                        moderatorId,
                        status === 'approved' ? 'APPROVE' : 'REJECT',
                        'POST',
                        postId,
                        reason || null,
                        null
                    );
                }
                
                await conn.commit();
                
                // Get new moderation status
                const [newRows] = await conn.query<PostModerationRow[]>(
                    `SELECT * FROM post_moderation 
                     WHERE post_id = ?`,
                    [postId]
                );
                
                if (!newRows || newRows.length === 0) {
                    throw new Error("Failed to retrieve created post moderation status");
                }
                
                return newRows[0];
            }
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error updating post moderation status:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Log a moderation action
 */
export async function logModerationAction(
    communityId: string,
    moderatorId: string,
    actionType: string,
    entityType: string,
    entityId: string,
    reason: string | null,
    metadata: any | null
): Promise<ModerationLog> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const id = uuidv4();
        const now = new Date();
        
        await conn.query(
            `INSERT INTO moderation_log (
             id, community_id, moderator_id, action_type, entity_type,
             entity_id, reason, metadata, created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [
                id,
                communityId,
                moderatorId,
                actionType,
                entityType,
                entityId,
                reason,
                metadata ? JSON.stringify(metadata) : null,
                now
            ]
        );
        
        // Get the created log entry
        const [rows] = await conn.query<ModerationLogRow[]>(
            `SELECT * FROM moderation_log 
             WHERE id = ?`,
            [id]
        );
        
        if (!rows || rows.length === 0) {
            throw new Error("Failed to retrieve created moderation log");
        }
        
        return rows[0];
    } catch (error) {
        console.error('Error logging moderation action:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Get moderation logs for a community
 */
export async function getModerationLogs(
    communityId: string,
    limit: number = 20,
    offset: number = 0
): Promise<ModerationLog[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [rows] = await conn.query<ModerationLogRow[]>(
            `SELECT ml.*, u.username as moderator_username
             FROM moderation_log ml
             JOIN user u ON ml.moderator_id = u.id
             WHERE ml.community_id = ?
             ORDER BY ml.created_at DESC
             LIMIT ? OFFSET ?`,
            [communityId, limit, offset]
        );
        
        return rows || [];
    } catch (error) {
        console.error('Error getting moderation logs:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Ban a user from a community
 */
export async function banUserFromCommunity(
    communityId: string,
    userId: string,
    moderatorId: string,
    reason: string | null,
    expiresAt: Date | null
): Promise<BannedUser> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        await conn.beginTransaction();
        
        try {
            // Delete existing community membership
            await conn.query(
                `DELETE FROM community_member 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            // Create ban record
            const now = new Date();
            
            await conn.query(
                `INSERT INTO banned_user (
                 community_id, user_id, reason, banned_by, expires_at, created_at
                ) VALUES (?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    reason,
                    moderatorId,
                    expiresAt,
                    now
                ]
            );
            
            // Log the moderation action
            await logModerationAction(
                communityId,
                moderatorId,
                'BAN',
                'USER',
                userId,
                reason,
                { expiresAt }
            );
            
            await conn.commit();
            
            // Get the ban record
            const [rows] = await conn.query<BannedUserRow[]>(
                `SELECT * FROM banned_user 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            if (!rows || rows.length === 0) {
                throw new Error("Failed to retrieve ban record");
            }
            
            return rows[0];
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error banning user from community:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Check if a user is banned from a community
 */
export async function isUserBanned(userId: string, communityId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check for an active ban
        const [rows] = await conn.query<BannedUserRow[]>(
            `SELECT * FROM banned_user 
             WHERE community_id = ? AND user_id = ? 
             AND (expires_at IS NULL OR expires_at > NOW())`,
            [communityId, userId]
        );
        
        return Boolean(rows && rows.length > 0);
    } catch (error) {
        console.error('Error checking if user is banned:', error);
        return false;
    } finally {
        if (conn) conn.release();
    }
}

/**
 * Unban a user from a community
 */
export async function unbanUserFromCommunity(
    communityId: string,
    userId: string,
    moderatorId: string
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        await conn.beginTransaction();
        
        try {
            // First, check if the user is banned
            const [banRows] = await conn.query<BannedUserRow[]>(
                `SELECT * FROM banned_user 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            if (!banRows || banRows.length === 0) {
                throw new Error('User is not banned from this community');
            }
            
            // Remove the ban
            await conn.query(
                `DELETE FROM banned_user 
                 WHERE community_id = ? AND user_id = ?`,
                [communityId, userId]
            );
            
            // Log the moderation action
            await logModerationAction(
                communityId,
                moderatorId,
                'UNBAN',
                'USER',
                userId,
                null,
                { previousBan: banRows[0] }
            );
            
            await conn.commit();
            
            return true;
        } catch (error) {
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error('Error unbanning user from community:', error);
        throw error;
    } finally {
        if (conn) conn.release();
    }
}

================
File: backend/api/moderation.ts.new
================
// backend/api/moderation.ts
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection.js';

// Types
export interface ModeratorPermission {
    community_id: string;
    user_id: string;
    can_manage_settings: boolean;
    can_manage_members: boolean;
    can_manage_posts: boolean;
    can_manage_comments: boolean;
    created_at: Date;
    updated_at: Date;
}

export interface ModeratorPermissionInput {
    can_manage_settings?: boolean;
    can_manage_members?: boolean;
    can_manage_posts?: boolean;
    can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface PostModeration {
    post_id: string;
    status: 'pending' | 'approved' | 'rejected';
    moderator_id: string | null;
    reason: string | null;
    moderated_at: Date | null;
    created_at: Date;
}

export interface ModerationLog {
    id: string;
    community_id: string;
    moderator_id: string;
    action_type: string;
    target_id: string | null;
    target_type: string | null;
    reason: string | null;
    created_at: Date;
}

export interface BannedUser {
    community_id: string;
    user_id: string;
    reason: string | null;
    banned_by: string;
    ban_expires_at: Date | null;
    created_at: Date;
}

// Helper function to check if a user has moderator permissions
export async function isUserModerator(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [member] = await conn.query(
            "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return member && (member.role === 'moderator' || member.role === 'admin');
    } catch (error) {
        console.error("Error checking moderator status:", error);
        throw new Error('Failed to check moderator status');
    } finally {
        if (conn) conn.release();
    }
}

// Helper function to check specific moderator permissions
export async function hasModeratorPermission(
    communityId: string, 
    userId: string, 
    permission: 'can_manage_settings' | 'can_manage_members' | 'can_manage_posts' | 'can_manage_comments'
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // First check if user is a moderator or admin
        const isModerator = await isUserModerator(communityId, userId);
        if (!isModerator) {
            return false;
        }
        
        // Check for specific permission
        const [permissions] = await conn.query(
            `SELECT ${permission} FROM moderator_permission WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        // If no specific permissions set, check if admin (admins have all permissions)
        if (!permissions) {
            const [member] = await conn.query(
                "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
            
            return member && member.role === 'admin';
        }
        
        return !!permissions[permission];
    } catch (error) {
        console.error(`Error checking moderator permission (${permission}):`, error);
        throw new Error(`Failed to check moderator permission: ${permission}`);
    } finally {
        if (conn) conn.release();
    }
}

// Moderator Permissions CRUD
export async function getModeratorPermissions(communityId: string, userId: string): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [permissions] = await conn.query(
            "SELECT * FROM moderator_permission WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return permissions || null;
    } catch (error) {
        console.error("Error fetching moderator permissions:", error);
        throw new Error('Failed to fetch moderator permissions');
    } finally {
        if (conn) conn.release();
    }
}

export async function setModeratorPermissions(
    communityId: string, 
    userId: string, 
    permissions: ModeratorPermissionInput
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a moderator or admin
        const [member] = await conn.query(
            "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!member || (member.role !== 'moderator' && member.role !== 'admin')) {
            throw new Error('User is not a moderator or admin of this community');
        }
        
        // Check if permissions already exist
        const [existingPermissions] = await conn.query(
            "SELECT * FROM moderator_permission WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingPermissions) {
            // Update existing permissions
            const updates: string[] = [];
            const values: any[] = [];
            
            if (permissions.can_manage_settings !== undefined) {
                updates.push("can_manage_settings = ?");
                values.push(permissions.can_manage_settings);
            }
            
            if (permissions.can_manage_members !== undefined) {
                updates.push("can_manage_members = ?");
                values.push(permissions.can_manage_members);
            }
            
            if (permissions.can_manage_posts !== undefined) {
                updates.push("can_manage_posts = ?");
                values.push(permissions.can_manage_posts);
            }
            
            if (permissions.can_manage_comments !== undefined) {
                updates.push("can_manage_comments = ?");
                values.push(permissions.can_manage_comments);
            }
            
            if (updates.length > 0) {
                values.push(communityId);
                values.push(userId);
                
                await conn.query(
                    `UPDATE moderator_permission SET ${updates.join(", ")} WHERE community_id = ? AND user_id = ?`,
                    values
                );
            }
        } else {
            // Create new permissions
            await conn.query(
                `INSERT INTO moderator_permission (
                    community_id, 
                    user_id, 
                    can_manage_settings, 
                    can_manage_members, 
                    can_manage_posts, 
                    can_manage_comments
                ) VALUES (?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : false,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : false,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : false,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : false
                ]
            );
        }
        
        // Return the updated permissions
        return await getModeratorPermissions(communityId, userId);
    } catch (error) {
        console.error("Error setting moderator permissions:", error);
        throw new Error('Failed to set moderator permissions');
    } finally {
        if (conn) conn.release();
    }
}

// Enhanced Community Settings CRUD
export async function getEnhancedCommunitySettings(communityId: string): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!settings) {
            // Create default settings if they don't exist
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, 
                    allow_post_images, 
                    allow_post_links,
                    require_post_approval,
                    minimum_account_age_days,
                    minimum_karma_required
                ) VALUES (?, TRUE, TRUE, FALSE, 0, 0)`,
                [communityId]
            );
            
            const [newSettings] = await conn.query(
                "SELECT * FROM community_setting WHERE community_id = ?",
                [communityId]
            );
            
            return newSettings;
        }
        
        return settings;
    } catch (error) {
        console.error("Error fetching enhanced community settings:", error);
        throw new Error('Failed to fetch enhanced community settings');
    } finally {
        if (conn) conn.release();
    }
}

export async function updateEnhancedCommunitySettings(
    communityId: string, 
    settings: ExtendedCommunitySettingsInput
): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create settings with provided values if they don't exist
            const insertColumns: string[] = ["community_id"];
            const placeholders: string[] = ["?"];
            const values: any[] = [communityId];
            
            // Build dynamic insert query based on provided settings
            Object.entries(settings).forEach(([key, value]) => {
                if (value !== undefined) {
                    insertColumns.push(key);
                    placeholders.push("?");
                    values.push(value);
                }
            });
            
            await conn.query(
                `INSERT INTO community_setting (${insertColumns.join(", ")}) VALUES (${placeholders.join(", ")})`,
                values
            );
        } else {
            // Update existing settings
            const updates: string[] = [];
            const values: any[] = [];
            
            Object.entries(settings).forEach(([key, value]) => {
                if (value !== undefined) {
                    updates.push(`${key} = ?`);
                    values.push(value);
                }
            });
            
            if (updates.length > 0) {
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Return the updated settings
        return await getEnhancedCommunitySettings(communityId);
    } catch (error) {
        console.error("Error updating enhanced community settings:", error);
        throw new Error('Failed to update enhanced community settings');
    } finally {
        if (conn) conn.release();
    }
}

// Post Moderation functions
export async function getPostModerationStatus(postId: string): Promise<PostModeration | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [status] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return status || null;
    } catch (error) {
        console.error("Error fetching post moderation status:", error);
        throw new Error('Failed to fetch post moderation status');
    } finally {
        if (conn) conn.release();
    }
}

export async function addPostToModQueue(postId: string): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if post already in moderation queue
        const [existingModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        if (existingModeration) {
            return existingModeration;
        }
        
        // Add post to moderation queue
        await conn.query(
            "INSERT INTO post_moderation (post_id, status) VALUES (?, 'pending')",
            [postId]
        );
        
        const [newModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return newModeration;
    } catch (error) {
        console.error("Error adding post to moderation queue:", error);
        throw new Error('Failed to add post to moderation queue');
    } finally {
        if (conn) conn.release();
    }
}

export async function moderatePost(
    postId: string, 
    moderatorId: string, 
    action: 'approve' | 'reject', 
    reason?: string
): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get post information to log the action
        const [post] = await conn.query(
            "SELECT community_id FROM post WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            throw new Error('Post not found');
        }
        
        // Update post moderation status
        await conn.query(
            "UPDATE post_moderation SET status = ?, moderator_id = ?, reason = ?, moderated_at = NOW() WHERE post_id = ?",
            [action === 'approve' ? 'approved' : 'rejected', moderatorId, reason || null, postId]
        );
        
        // Log the moderation action
        await createModerationLog(
            post.community_id,
            moderatorId,
            action === 'approve' ? 'approve_post' : 'reject_post',
            postId,
            'post',
            reason
        );
        
        // Retrieve and return updated moderation status
        const [updatedModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return updatedModeration;
    } catch (error) {
        console.error("Error moderating post:", error);
        throw new Error('Failed to moderate post');
    } finally {
        if (conn) conn.release();
    }
}

export async function getPendingModQueue(communityId: string): Promise<any[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get all pending posts for the community
        const pendingPosts = await conn.query(
            `SELECT p.*, pm.status, pm.created_at as queued_at, u.username as author_username
             FROM post p
             JOIN post_moderation pm ON p.id = pm.post_id
             JOIN user u ON p.user_id = u.id
             WHERE p.community_id = ? AND pm.status = 'pending'
             ORDER BY pm.created_at ASC`,
            [communityId]
        );
        
        return pendingPosts;
    } catch (error) {
        console.error("Error fetching pending moderation queue:", error);
        throw new Error('Failed to fetch pending moderation queue');
    } finally {
        if (conn) conn.release();
    }
}

// Moderation Log functions
export async function createModerationLog(
    communityId: string,
    moderatorId: string,
    actionType: string,
    targetId?: string,
    targetType?: string,
    reason?: string
): Promise<ModerationLog> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const id = uuidv4();
        
        await conn.query(
            `INSERT INTO moderation_log (
                id, 
                community_id, 
                moderator_id, 
                action_type, 
                target_id, 
                target_type, 
                reason
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [id, communityId, moderatorId, actionType, targetId || null, targetType || null, reason || null]
        );
        
        const [log] = await conn.query(
            "SELECT * FROM moderation_log WHERE id = ?",
            [id]
        );
        
        return log;
    } catch (error) {
        console.error("Error creating moderation log:", error);
        throw new Error('Failed to create moderation log');
    } finally {
        if (conn) conn.release();
    }
}

export async function getModerationLogs(communityId: string, limit = 50, offset = 0): Promise<ModerationLog[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const logs = await conn.query(
            `SELECT ml.*, u.username as moderator_username 
             FROM moderation_log ml
             JOIN user u ON ml.moderator_id = u.id
             WHERE ml.community_id = ?
             ORDER BY ml.created_at DESC
             LIMIT ? OFFSET ?`,
            [communityId, limit, offset]
        );
        
        return logs;
    } catch (error) {
        console.error("Error fetching moderation logs:", error);
        throw new Error('Failed to fetch moderation logs');
    } finally {
        if (conn) conn.release();
    }
}

// User banning functions
export async function banUserFromCommunity(
    communityId: string,
    userId: string,
    bannedBy: string,
    reason?: string,
    banDuration?: number // Duration in days, null for permanent
): Promise<BannedUser> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Calculate expiration date if duration provided
        let banExpiresAt = null;
        if (banDuration) {
            const expirationDate = new Date();
            expirationDate.setDate(expirationDate.getDate() + banDuration);
            banExpiresAt = expirationDate;
        }
        
        // Check if user is already banned
        const [existingBan] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingBan) {
            // Update existing ban
            await conn.query(
                "UPDATE banned_user SET reason = ?, banned_by = ?, ban_expires_at = ? WHERE community_id = ? AND user_id = ?",
                [reason || null, bannedBy, banExpiresAt, communityId, userId]
            );
        } else {
            // Create new ban
            await conn.query(
                "INSERT INTO banned_user (community_id, user_id, reason, banned_by, ban_expires_at) VALUES (?, ?, ?, ?, ?)",
                [communityId, userId, reason || null, bannedBy, banExpiresAt]
            );
            
            // Remove user from community members if they're a member
            await conn.query(
                "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
        }
        
        // Log the ban action
        await createModerationLog(
            communityId,
            bannedBy,
            'ban_user',
            userId,
            'user',
            reason
        );
        
        const [ban] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return ban;
    } catch (error) {
        console.error("Error banning user from community:", error);
        throw new Error('Failed to ban user from community');
    } finally {
        if (conn) conn.release();
    }
}

export async function unbanUserFromCommunity(
    communityId: string,
    userId: string,
    unbannedBy: string,
    reason?: string
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is banned
        const [existingBan] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingBan) {
            return false; // User wasn't banned
        }
        
        // Remove ban
        await conn.query(
            "DELETE FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Log the unban action
        await createModerationLog(
            communityId,
            unbannedBy,
            'unban_user',
            userId,
            'user',
            reason
        );
        
        return true;
    } catch (error) {
        console.error("Error unbanning user from community:", error);
        throw new Error('Failed to unban user from community');
    } finally {
        if (conn) conn.release();
    }
}

export async function getBannedUsers(communityId: string): Promise<any[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const bannedUsers = await conn.query(
            `SELECT bu.*, 
                    u.username as banned_username, 
                    m.username as moderator_username
             FROM banned_user bu
             JOIN user u ON bu.user_id = u.id
             JOIN user m ON bu.banned_by = m.id
             WHERE bu.community_id = ?
             ORDER BY bu.created_at DESC`,
            [communityId]
        );
        
        return bannedUsers;
    } catch (error) {
        console.error("Error fetching banned users:", error);
        throw new Error('Failed to fetch banned users');
    } finally {
        if (conn) conn.release();
    }
}

export async function isUserBanned(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check for active bans
        const [ban] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
            [communityId, userId]
        );
        
        return !!ban;
    } catch (error) {
        console.error("Error checking if user is banned:", error);
        throw new Error('Failed to check if user is banned');
    } finally {
        if (conn) conn.release();
    }
}

================
File: backend/api/posts_enhanced.js
================
// backend/api/posts_enhanced.js
const { v4: uuidv4 } = require('uuid');
const mariadb = require('mariadb');
const dotenv = require('dotenv');

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

// Function to get community ID from post ID (needed for permission checks)
const getCommunityIdFromPost = async (postId) => {
    let conn;
    try {
        conn = await pool.getConnection();
        const [post] = await conn.query(
            "SELECT community_id FROM posts WHERE id = ?",
            [postId]
        );
        return post ? post.community_id : null;
    } catch (error) {
        console.error("Error fetching community ID from post:", error);
        throw new Error('Failed to fetch community ID from post');
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced post creation with moderation support
const createPostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const { title, content, communityId } = req.body;
        const userId = req.user.id;
        
        // Validate required fields
        if (!title || !content || !communityId) {
            return res.status(400).json({ message: 'Title, content, and communityId are required' });
        }
        
        // Check if community exists
        const [community] = await conn.query(
            "SELECT * FROM communities WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ message: 'Community not found' });
        }
        
        // Start a transaction
        await conn.beginTransaction();
        
        try {
            // Check if user is banned from the community
            const { isUserBanned } = require('./moderation');
            const banned = await isUserBanned(communityId, userId);
            
            if (banned) {
                return res.status(403).json({ message: 'You are banned from this community and cannot create posts' });
            }
            
            // Get community settings
            const { getEnhancedCommunitySettings } = require('./moderation');
            const settings = await getEnhancedCommunitySettings(communityId);
            
            // Create the post
            const id = uuidv4();
            const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
            
            await conn.query(
                "INSERT INTO posts (id, title, content, user_id, community_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
                [id, title, content, userId, communityId, now, now]
            );
            
            // If post approval is required, add to moderation queue
            let requiresApproval = false;
            if (settings && settings.require_post_approval) {
                const { addPostToModQueue } = require('./moderation');
                await addPostToModQueue(id);
                requiresApproval = true;
            }
            
            // Commit the transaction
            await conn.commit();
            
            // Get the created post with user information
            const [newPost] = await conn.query(`
                SELECT p.*, u.username
                FROM posts p
                LEFT JOIN users u ON p.user_id = u.id
                WHERE p.id = ?
            `, [id]);
            
            // Format the post for the frontend
            const formattedPost = {
                id: newPost.id,
                title: newPost.title,
                content: newPost.content,
                username: newPost.username || 'Anonymous',
                userId: newPost.user_id,
                communityId: newPost.community_id,
                timestamp: newPost.created_at,
                comments: 0,
                votes: 0,
                pending_approval: requiresApproval
            };
            
            res.status(201).json(formattedPost);
        } catch (error) {
            // Rollback the transaction if anything goes wrong
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error("Error creating post:", error);
        res.status(500).json({ message: 'Error creating post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced get posts with moderation support
const getPostsEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get community filter if provided
        const communityId = req.query.communityId;
        const userId = req.user ? req.user.id : null;
        
        // Get community settings if community filter is provided
        let requiresApproval = false;
        let isModerator = false;
        
        if (communityId && userId) {
            const { getEnhancedCommunitySettings, isUserModerator } = require('./moderation');
            const settings = await getEnhancedCommunitySettings(communityId);
            requiresApproval = settings && settings.require_post_approval;
            isModerator = await isUserModerator(communityId, userId);
        }
        
        // Build the query based on whether a community filter is provided
        let query = `
            SELECT p.*, u.username, 
                   (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                   COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
            FROM posts p
            LEFT JOIN users u ON p.user_id = u.id
        `;
        
        if (communityId) {
            query += " WHERE p.community_id = ?";
            
            // If community requires post approval and user is not a moderator, only show approved posts
            if (requiresApproval && !isModerator) {
                query = `
                    SELECT p.*, u.username, 
                           (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                           COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
                    FROM posts p
                    LEFT JOIN users u ON p.user_id = u.id
                    LEFT JOIN post_moderation pm ON p.id = pm.post_id
                    WHERE p.community_id = ? AND (pm.status = 'approved' OR pm.status IS NULL OR p.user_id = ?)
                `;
            }
        }
        
        query += " ORDER BY p.created_at DESC";
        
        // Execute the query with appropriate parameters
        let posts;
        if (communityId) {
            if (requiresApproval && !isModerator && userId) {
                posts = await conn.query(query, [communityId, userId]);
            } else {
                posts = await conn.query(query, [communityId]);
            }
        } else {
            posts = await conn.query(query);
        }
        
        // Get moderation status for posts if needed
        let formattedPosts = await Promise.all(posts.map(async (post) => {
            let pending_approval = false;
            
            if (requiresApproval) {
                const { getPostModerationStatus } = require('./moderation');
                const modStatus = await getPostModerationStatus(post.id);
                pending_approval = modStatus && modStatus.status === 'pending';
            }
            
            return {
                id: post.id,
                title: post.title,
                content: post.content,
                username: post.username || 'Anonymous',
                userId: post.user_id,
                communityId: post.community_id,
                timestamp: post.created_at,
                comments: post.comments || 0,
                votes: post.votes || 0,
                pending_approval: pending_approval
            };
        }));
        
        res.status(200).json(formattedPosts);
    } catch (error) {
        console.error("Error fetching posts:", error);
        res.status(500).json({ message: 'Error fetching posts' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced get single post with moderation support
const getPostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const postId = req.params.id;
        const userId = req.user ? req.user.id : null;
        
        // Get the post with additional info
        const [post] = await conn.query(`
            SELECT p.*, u.username, 
                   (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                   COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
            FROM posts p
            LEFT JOIN users u ON p.user_id = u.id
            WHERE p.id = ?
        `, [postId]);
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check moderation status
        let pending_approval = false;
        let rejected = false;
        let rejection_reason = null;
        
        if (userId) {
            const { getEnhancedCommunitySettings, getPostModerationStatus, isUserModerator } = require('./moderation');
            const settings = await getEnhancedCommunitySettings(post.community_id);
            
            if (settings && settings.require_post_approval) {
                const modStatus = await getPostModerationStatus(postId);
                
                // If post is pending approval
                if (modStatus && modStatus.status === 'pending') {
                    const isModerator = await isUserModerator(post.community_id, userId);
                    
                    // If user is not the author or a moderator, hide the post
                    if (post.user_id !== userId && !isModerator) {
                        return res.status(403).json({ message: 'Post is pending moderator approval' });
                    }
                    
                    pending_approval = true;
                }
                
                // If post was rejected
                if (modStatus && modStatus.status === 'rejected') {
                    const isModerator = await isUserModerator(post.community_id, userId);
                    
                    // If user is not the author or a moderator, hide the post
                    if (post.user_id !== userId && !isModerator) {
                        return res.status(403).json({ message: 'Post has been removed by moderators' });
                    }
                    
                    rejected = true;
                    rejection_reason = modStatus.reason;
                }
            }
        }
        
        // Format the post for the frontend
        const formattedPost = {
            id: post.id,
            title: post.title,
            content: post.content,
            username: post.username || 'Anonymous',
            userId: post.user_id,
            communityId: post.community_id,
            timestamp: post.created_at,
            comments: post.comments || 0,
            votes: post.votes || 0,
            pending_approval,
            rejected,
            rejection_reason
        };
        
        res.status(200).json(formattedPost);
    } catch (error) {
        console.error("Error fetching post:", error);
        res.status(500).json({ message: 'Error fetching post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced update post with moderation support
const updatePostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const { title, content } = req.body;
        const postId = req.params.id;
        const userId = req.user.id;
        
        // Check if post exists
        const [post] = await conn.query(
            "SELECT * FROM posts WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check if user is the author or a moderator
        let isModeratorAction = false;
        
        if (post.user_id !== userId) {
            // Check moderator permissions
            const { isUserModerator, hasModeratorPermission } = require('./moderation');
            const isModerator = await isUserModerator(post.community_id, userId);
            const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
            
            if (!isModerator || !canManagePosts) {
                return res.status(403).json({ message: 'You do not have permission to update this post' });
            }
            
            isModeratorAction = true;
        }
        
        // Update the post
        const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
        
        await conn.query(
            "UPDATE posts SET title = ?, content = ?, updated_at = ? WHERE id = ?",
            [title, content, now, postId]
        );
        
        // If it's a moderator action, log it
        if (isModeratorAction) {
            const { createModerationLog } = require('./moderation');
            await createModerationLog(
                post.community_id,
                userId,
                'edit_post',
                postId,
                'post',
                'Post edited by moderator'
            );
        }
        
        // Get the updated post with user information
        const [updatedPost] = await conn.query(`
            SELECT p.*, u.username, 
                   (SELECT COUNT(*) FROM comments c WHERE c.post_id = p.id) as comments,
                   COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes
            FROM posts p
            LEFT JOIN users u ON p.user_id = u.id
            WHERE p.id = ?
        `, [postId]);
        
        // Check moderation status
        const { getPostModerationStatus } = require('./moderation');
        const modStatus = await getPostModerationStatus(postId);
        
        // Format the post for the frontend
        const formattedPost = {
            id: updatedPost.id,
            title: updatedPost.title,
            content: updatedPost.content,
            username: updatedPost.username || 'Anonymous',
            userId: updatedPost.user_id,
            communityId: updatedPost.community_id,
            timestamp: updatedPost.created_at,
            comments: updatedPost.comments || 0,
            votes: updatedPost.votes || 0,
            pending_approval: modStatus && modStatus.status === 'pending',
            rejected: modStatus && modStatus.status === 'rejected',
            rejection_reason: modStatus && modStatus.status === 'rejected' ? modStatus.reason : null
        };
        
        res.status(200).json(formattedPost);
    } catch (error) {
        console.error("Error updating post:", error);
        res.status(500).json({ message: 'Error updating post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced delete post with moderation support
const deletePostEnhanced = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const postId = req.params.id;
        const userId = req.user.id;
        
        // Check if post exists
        const [post] = await conn.query(
            "SELECT * FROM posts WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check if user is the author or a moderator
        let isModeratorAction = false;
        
        if (post.user_id !== userId) {
            // Check moderator permissions
            const { isUserModerator, hasModeratorPermission } = require('./moderation');
            const isModerator = await isUserModerator(post.community_id, userId);
            const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
            
            if (!isModerator || !canManagePosts) {
                return res.status(403).json({ message: 'You do not have permission to delete this post' });
            }
            
            isModeratorAction = true;
        }
        
        // Start a transaction
        await conn.beginTransaction();
        
        try {
            // Delete comments associated with the post
            await conn.query(
                "DELETE FROM comments WHERE post_id = ?",
                [postId]
            );
            
            // Delete votes associated with the post
            await conn.query(
                "DELETE FROM votes WHERE post_id = ?",
                [postId]
            );
            
            // Delete from moderation queue if present
            await conn.query(
                "DELETE FROM post_moderation WHERE post_id = ?",
                [postId]
            );
            
            // Delete the post
            await conn.query(
                "DELETE FROM posts WHERE id = ?",
                [postId]
            );
            
            // If it's a moderator action, log it
            if (isModeratorAction) {
                const { createModerationLog } = require('./moderation');
                await createModerationLog(
                    post.community_id,
                    userId,
                    'remove_post',
                    postId,
                    'post',
                    'Post removed by moderator'
                );
            }
            
            // Commit the transaction
            await conn.commit();
            
            res.status(204).send();
        } catch (error) {
            // Rollback the transaction if anything goes wrong
            await conn.rollback();
            throw error;
        }
    } catch (error) {
        console.error("Error deleting post:", error);
        res.status(500).json({ message: 'Error deleting post' });
    } finally {
        if (conn) conn.release();
    }
};

// Enhanced moderator specific functions
const getPendingPosts = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        const communityId = req.params.communityId;
        const userId = req.user.id;
        
        // Check if user is a moderator with post management permissions
        const { isUserModerator, hasModeratorPermission } = require('./moderation');
        const isModerator = await isUserModerator(communityId, userId);
        const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
        
        if (!isModerator || !canManagePosts) {
            return res.status(403).json({ message: 'You do not have permission to view pending posts' });
        }
        
        // Get pending posts for the community
        const pendingPosts = await conn.query(`
            SELECT p.*, u.username, pm.created_at as queued_at
            FROM posts p
            JOIN post_moderation pm ON p.id = pm.post_id
            JOIN users u ON p.user_id = u.id
            WHERE p.community_id = ? AND pm.status = 'pending'
            ORDER BY pm.created_at ASC
        `, [communityId]);
        
        // Format the posts for the frontend
        const formattedPosts = pendingPosts.map(post => ({
            id: post.id,
            title: post.title,
            content: post.content,
            username: post.username || 'Anonymous',
            userId: post.user_id,
            communityId: post.community_id,
            timestamp: post.created_at,
            queuedAt: post.queued_at
        }));
        
        res.status(200).json(formattedPosts);
    } catch (error) {
        console.error("Error fetching pending posts:", error);
        res.status(500).json({ message: 'Error fetching pending posts' });
    } finally {
        if (conn) conn.release();
    }
};

const moderatePostAction = async (req, res) => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const postId = req.params.postId;
        const { action, reason } = req.body;
        const userId = req.user.id;
        
        if (action !== 'approve' && action !== 'reject') {
            return res.status(400).json({ message: 'Invalid action. Must be "approve" or "reject"' });
        }
        
        // Get the post to check permissions
        const [post] = await conn.query(
            "SELECT * FROM posts WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            return res.status(404).json({ message: 'Post not found' });
        }
        
        // Check if user is a moderator with post management permissions
        const { isUserModerator, hasModeratorPermission, moderatePost } = require('./moderation');
        const isModerator = await isUserModerator(post.community_id, userId);
        const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
        
        if (!isModerator || !canManagePosts) {
            return res.status(403).json({ message: 'You do not have permission to moderate posts' });
        }
        
        // Perform the moderation action
        await moderatePost(postId, userId, action, reason);
        
        res.status(200).json({ 
            message: `Post ${action === 'approve' ? 'approved' : 'rejected'} successfully`,
            postId
        });
    } catch (error) {
        console.error("Error moderating post:", error);
        res.status(500).json({ message: 'Error moderating post' });
    } finally {
        if (conn) conn.release();
    }
};

module.exports = {
    getCommunityIdFromPost,
    createPostEnhanced,
    getPostsEnhanced,
    getPostEnhanced,
    updatePostEnhanced,
    deletePostEnhanced,
    getPendingPosts,
    moderatePostAction
};

================
File: backend/api/posts.js
================
// JavaScript version of posts.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all posts with user information
const getPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get community filter if provided
    const communityId = req.query.communityId;
    
    // Build the query based on whether a community filter is provided
    let query = `
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
    `;
    
    const queryParams = [];
    
    if (communityId) {
      query += " WHERE p.community_id = ?";
      queryParams.push(communityId);
    }
    
    query += " ORDER BY p.created_at DESC";
    
    const posts = await conn.query(query, queryParams);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching posts:", error);
    res.status(500).json({ message: 'Error fetching posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get a single post with user information
const getPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [post] = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.id = ?
    `, [req.params.id]);
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    // Format the post for the frontend
    const formattedPost = {
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    };
    
    res.status(200).json(formattedPost);
  } catch (error) {
    console.error("Error fetching post:", error);
    res.status(500).json({ message: 'Error fetching post' });
  } finally {
    if (conn) conn.release();
  }
};

// Create a new post
const createPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content, communityId } = req.body;
    const userId = req.user.id;
    
    // Validate required fields
    if (!title || !content || !communityId) {
      return res.status(400).json({ message: 'Title, content, and communityId are required' });
    }
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Create the post
      const id = uuidv4();
      
      await conn.query(
        "INSERT INTO post (id, title, content, user_id, community_id) VALUES (?, ?, ?, ?, ?)",
        [id, title, content, userId, communityId]
      );
      
      // Get the created post with user information
      const [newPost] = await conn.query(`
        SELECT p.*, u.username
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: newPost.id,
        title: newPost.title,
        content: newPost.content,
        username: newPost.username || 'Anonymous',
        userId: newPost.user_id,
        communityId: newPost.community_id,
        timestamp: newPost.created_at,
        comments: 0,
        votes: 0
      };
      
      res.status(201).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating post:", error);
    res.status(500).json({ message: 'Error creating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Update a post
const updatePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content } = req.body;
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      return res.status(403).json({ message: 'You can only update your own posts' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Update the post
      await conn.query(
        "UPDATE post SET title = ?, content = ? WHERE id = ?",
        [title, content, postId]
      );
      
      // Get the updated post with user information
      const [updatedPost] = await conn.query(`
        SELECT p.*, u.username, 
               (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
               COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [postId]);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: title,
            community_id: post.community_id
          })
        ]
      );
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: updatedPost.id,
        title: updatedPost.title,
        content: updatedPost.content,
        username: updatedPost.username || 'Anonymous',
        userId: updatedPost.user_id,
        communityId: updatedPost.community_id,
        timestamp: updatedPost.created_at,
        comments: updatedPost.comments || 0,
        votes: updatedPost.votes || 0
      };
      
      res.status(200).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating post:", error);
    res.status(500).json({ message: 'Error updating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Delete a post
const deletePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      // Check if user is a moderator of the community
      const [moderator] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
        [post.community_id, userId]
      );
      
      if (!moderator) {
        return res.status(403).json({ message: 'You can only delete your own posts or posts in communities you moderate' });
      }
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Log activity before deleting the post
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: post.title,
            community_id: post.community_id
          })
        ]
      );
      
      // Delete votes associated with the post
      await conn.query(
        "DELETE FROM vote WHERE post_id = ?",
        [postId]
      );
      
      // Delete comments associated with the post
      await conn.query(
        "DELETE FROM comment WHERE post_id = ?",
        [postId]
      );
      
      // Delete the post
      await conn.query(
        "DELETE FROM post WHERE id = ?",
        [postId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      res.status(204).send();
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting post:", error);
    res.status(500).json({ message: 'Error deleting post' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific community
const getCommunityPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const communityId = req.params.communityId;
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Get posts for the community
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.community_id = ?
      ORDER BY p.created_at DESC
    `, [communityId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching community posts:", error);
    res.status(500).json({ message: 'Error fetching community posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific user
const getUserPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const userId = req.params.userId;
    
    // Check if user exists
    const [user] = await conn.query(
      "SELECT * FROM user WHERE id = ?",
      [userId]
    );
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Get posts for the user
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `, [userId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching user posts:", error);
    res.status(500).json({ message: 'Error fetching user posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Check if user can post in a community
const canPostInCommunity = async (req, res, next) => {
  const communityId = req.body.communityId;
  const userId = req.user.id;
  
  if (!communityId) {
    return next(); // No community specified, allow the post
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // If community is public, check if user is banned
    const [banned] = await conn.query(
      "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
      [communityId, userId]
    );
    
    if (banned) {
      return res.status(403).json({ message: 'You are banned from this community' });
    }
    
    // Check community settings for post approval
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (settings && settings.require_post_approval) {
      // Set a flag to indicate that this post needs approval
      req.needsApproval = true;
    }
    
    // If community is private, check if user is a member
    if (community.privacy === 'private') {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership) {
        return res.status(403).json({ message: 'You must be a member to post in this community' });
      }
    }
    
    next();
  } catch (error) {
    console.error("Error checking post permission:", error);
    return res.status(500).json({ message: 'Error checking post permission' });
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPosts,
  getPost,
  createPost,
  updatePost,
  deletePost,
  getCommunityPosts,
  getUserPosts,
  canPostInCommunity
};

================
File: backend/api/posts.js.new
================
// JavaScript version of posts.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all posts with user information
const getPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get community filter if provided
    const communityId = req.query.communityId;
    
    // Build the query based on whether a community filter is provided
    let query = `
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
    `;
    
    const queryParams = [];
    
    if (communityId) {
      query += " WHERE p.community_id = ?";
      queryParams.push(communityId);
    }
    
    query += " ORDER BY p.created_at DESC";
    
    const posts = await conn.query(query, queryParams);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching posts:", error);
    res.status(500).json({ message: 'Error fetching posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get a single post with user information
const getPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [post] = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.id = ?
    `, [req.params.id]);
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    // Format the post for the frontend
    const formattedPost = {
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    };
    
    res.status(200).json(formattedPost);
  } catch (error) {
    console.error("Error fetching post:", error);
    res.status(500).json({ message: 'Error fetching post' });
  } finally {
    if (conn) conn.release();
  }
};

// Create a new post
const createPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content, communityId } = req.body;
    const userId = req.user.id;
    
    // Validate required fields
    if (!title || !content || !communityId) {
      return res.status(400).json({ message: 'Title, content, and communityId are required' });
    }
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Create the post
      const id = uuidv4();
      
      await conn.query(
        "INSERT INTO post (id, title, content, user_id, community_id) VALUES (?, ?, ?, ?, ?)",
        [id, title, content, userId, communityId]
      );
      
      // Get the created post with user information
      const [newPost] = await conn.query(`
        SELECT p.*, u.username
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: newPost.id,
        title: newPost.title,
        content: newPost.content,
        username: newPost.username || 'Anonymous',
        userId: newPost.user_id,
        communityId: newPost.community_id,
        timestamp: newPost.created_at,
        comments: 0,
        votes: 0
      };
      
      res.status(201).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating post:", error);
    res.status(500).json({ message: 'Error creating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Update a post
const updatePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content } = req.body;
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      return res.status(403).json({ message: 'You can only update your own posts' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Update the post
      await conn.query(
        "UPDATE post SET title = ?, content = ? WHERE id = ?",
        [title, content, postId]
      );
      
      // Get the updated post with user information
      const [updatedPost] = await conn.query(`
        SELECT p.*, u.username, 
               (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
               COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [postId]);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: title,
            community_id: post.community_id
          })
        ]
      );
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: updatedPost.id,
        title: updatedPost.title,
        content: updatedPost.content,
        username: updatedPost.username || 'Anonymous',
        userId: updatedPost.user_id,
        communityId: updatedPost.community_id,
        timestamp: updatedPost.created_at,
        comments: updatedPost.comments || 0,
        votes: updatedPost.votes || 0
      };
      
      res.status(200).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating post:", error);
    res.status(500).json({ message: 'Error updating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Delete a post
const deletePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      // Check if user is a moderator of the community
      const [moderator] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
        [post.community_id, userId]
      );
      
      if (!moderator) {
        return res.status(403).json({ message: 'You can only delete your own posts or posts in communities you moderate' });
      }
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Log activity before deleting the post
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: post.title,
            community_id: post.community_id
          })
        ]
      );
      
      // Delete votes associated with the post
      await conn.query(
        "DELETE FROM vote WHERE post_id = ?",
        [postId]
      );
      
      // Delete comments associated with the post
      await conn.query(
        "DELETE FROM comment WHERE post_id = ?",
        [postId]
      );
      
      // Delete the post
      await conn.query(
        "DELETE FROM post WHERE id = ?",
        [postId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      res.status(204).send();
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting post:", error);
    res.status(500).json({ message: 'Error deleting post' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific community
const getCommunityPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const communityId = req.params.communityId;
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Get posts for the community
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.community_id = ?
      ORDER BY p.created_at DESC
    `, [communityId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching community posts:", error);
    res.status(500).json({ message: 'Error fetching community posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific user
const getUserPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const userId = req.params.userId;
    
    // Check if user exists
    const [user] = await conn.query(
      "SELECT * FROM user WHERE id = ?",
      [userId]
    );
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Get posts for the user
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `, [userId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching user posts:", error);
    res.status(500).json({ message: 'Error fetching user posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Check if user can post in a community
const canPostInCommunity = async (req, res, next) => {
  const communityId = req.body.communityId;
  const userId = req.user.id;
  
  if (!communityId) {
    return next(); // No community specified, allow the post
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // If community is public, check if user is banned
    const [banned] = await conn.query(
      "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
      [communityId, userId]
    );
    
    if (banned) {
      return res.status(403).json({ message: 'You are banned from this community' });
    }
    
    // Check community settings for post approval
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (settings && settings.require_post_approval) {
      // Set a flag to indicate that this post needs approval
      req.needsApproval = true;
    }
    
    // If community is private, check if user is a member
    if (community.privacy === 'private') {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership) {
        return res.status(403).json({ message: 'You must be a member to post in this community' });
      }
    }
    
    next();
  } catch (error) {
    console.error("Error checking post permission:", error);
    return res.status(500).json({ message: 'Error checking post permission' });
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPosts,
  getPost,
  createPost,
  updatePost,
  deletePost,
  getCommunityPosts,
  getUserPosts,
  canPostInCommunity
};

================
File: backend/api/posts.ts
================
import { Request, Response } from 'express';

let mockPosts = [
  {
    id: '1',
    title: 'First Post',
    content: 'This is the first post',
    authorId: '1',
    communityId: '1',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  },
  {
    id: '2',
    title: 'Second Post',
    content: 'This is the second post',
    authorId: '2',
    communityId: '1',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  }
];

export const getPosts = async (req: Request, res: Response) => {
  try {
    res.status(200).json(mockPosts);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching posts' });
  }
};

export const getPost = async (req: Request, res: Response) => {
  try {
    const post = mockPosts.find(p => p.id === req.params.id);
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    res.status(200).json(post);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching post' });
  }
};

export const createPost = async (req: Request, res: Response) => {
  try {
    const newPost = {
      id: String(mockPosts.length + 1),
      ...req.body,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    mockPosts.push(newPost);
    res.status(201).json(newPost);
  } catch (error) {
    res.status(500).json({ message: 'Error creating post' });
  }
};

export const updatePost = async (req: Request, res: Response) => {
  try {
    const postIndex = mockPosts.findIndex(p => p.id === req.params.id);
    if (postIndex === -1) {
      return res.status(404).json({ message: 'Post not found' });
    }

    const updatedPost = {
      ...mockPosts[postIndex],
      ...req.body,
      updatedAt: new Date().toISOString()
    };

    mockPosts[postIndex] = updatedPost;
    res.status(200).json(updatedPost);
  } catch (error) {
    res.status(500).json({ message: 'Error updating post' });
  }
};

export const deletePost = async (req: Request, res: Response) => {
  try {
    const postIndex = mockPosts.findIndex(p => p.id === req.params.id);
    if (postIndex === -1) {
      return res.status(404).json({ message: 'Post not found' });
    }

    mockPosts.splice(postIndex, 1);
    res.status(204).send();
  } catch (error) {
    res.status(500).json({ message: 'Error deleting post' });
  }
};

================
File: backend/api/routes/communities.js
================
// Import the fixed version of addCommunityMember
const communitiesAPI = require('../communities');
const communitiesAPIOriginal = require('../communities.ts');

// Route handler for adding a member to a community
exports.addMember = async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Use our fixed version that handles the table name issue
    const member = await communitiesAPI.addCommunityMember(communityId, userId);
    res.status(200).json(member);
  } catch (error) {
    console.error('Error in addMember:', error);
    res.status(500).json({ error: 'Failed to add community member' });
  }
};

// Export all the other handlers from the original API
// This ensures we're only overriding the specific function that has issues
Object.keys(communitiesAPIOriginal).forEach(key => {
  if (key !== 'addCommunityMember' && !exports[key]) {
    exports[key] = communitiesAPIOriginal[key];
  }
});

================
File: backend/api/routes/community-members.js
================
// API route handler for community members
// This adds an endpoint to check current user membership

const express = require('express');
const router = express.Router();
const { getCommunityMember } = require('../communities.ts');
const { addCommunityMember } = require('../communities.js');
const auth = require('../../middleware/auth');

// Route to check if the current user is a member of a community
router.get('/:communityId/members/current', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Check if the user is a member
    const member = await getCommunityMember(communityId, userId);
    
    if (member) {
      return res.status(200).json({ 
        is_member: true,
        role: member.role,
        member_since: member.joined_at
      });
    } else {
      return res.status(200).json({ is_member: false });
    }
  } catch (error) {
    console.error('Error checking member status:', error);
    res.status(500).json({ error: 'Failed to check membership status' });
  }
});

// Route to add a member to a community
router.post('/:communityId/members', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Use our fixed version that handles the table name issue
    const member = await addCommunityMember(communityId, userId);
    res.status(200).json(member);
  } catch (error) {
    console.error('Error in addMember:', error);
    res.status(500).json({ error: 'Failed to add community member' });
  }
});

module.exports = router;

================
File: backend/api/users.ts
================
// src/api/users.ts

export async function getUserPosts(userId: string) {
  // Get posts for a specific user.
}

================
File: backend/api/votes.js
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Vote on a post
async function voteOnPost(userId, postId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the post exists
      const [post] = await conn.query('SELECT * FROM post WHERE id = ?', [postId]);
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if the user has already voted on this post
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND post_id = ?',
        [userId, postId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND post_id = ?',
            [userId, postId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND post_id = ?',
          [value, userId, postId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, post_id, value) VALUES (?, ?, ?)',
          [userId, postId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Vote on a comment
async function voteOnComment(userId, commentId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the comment exists
      const [comment] = await conn.query('SELECT * FROM comment WHERE id = ?', [commentId]);
      if (!comment) {
        throw new Error('Comment not found');
      }
      
      // Check if the user has already voted on this comment
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND comment_id = ?',
        [userId, commentId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND comment_id = ?',
            [userId, commentId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND comment_id = ?',
          [value, userId, commentId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, comment_id, value) VALUES (?, ?, ?)',
          [userId, commentId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a post
async function getUserPostVote(userId, postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a comment
async function getUserCommentVote(userId, commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a post
async function getPostVoteCounts(postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a comment
async function getCommentVoteCounts(commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get all votes for a user
async function getUserVotes(userId) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get post votes
    const postVotes = await conn.query(
      `SELECT v.*, p.title as post_title, p.community_id
       FROM vote v
       JOIN post p ON v.post_id = p.id
       WHERE v.user_id = ? AND v.post_id IS NOT NULL`,
      [userId]
    );
    
    // Get comment votes
    const commentVotes = await conn.query(
      `SELECT v.*, c.content as comment_content, p.id as post_id, p.title as post_title, p.community_id
       FROM vote v
       JOIN comment c ON v.comment_id = c.id
       JOIN post p ON c.post_id = p.id
       WHERE v.user_id = ? AND v.comment_id IS NOT NULL`,
      [userId]
    );
    
    return {
      postVotes,
      commentVotes
    };
  } catch (error) {
    console.error('Error getting user votes:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Helper function to update SQL queries to include votes
function includePostVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes`;
}

function includeCommentVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.comment_id = c.id), 0) as votes`;
}

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

// Helper function to log vote activity
async function logVoteActivity(conn, userId, activityTypeId, actionId, entityId, entityType, voteValue) {
  await conn.query(
    `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      uuidv4(),
      userId,
      activityTypeId,
      actionId,
      entityId,
      entityType,
      JSON.stringify({ value: voteValue })
    ]
  );
}

module.exports = {
  voteOnPost,
  voteOnComment,
  getUserPostVote,
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes,
  includePostVotesInQuery,
  includeCommentVotesInQuery
};

================
File: backend/api/votes.js.new
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Vote on a post
async function voteOnPost(userId, postId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the post exists
      const [post] = await conn.query('SELECT * FROM post WHERE id = ?', [postId]);
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if the user has already voted on this post
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND post_id = ?',
        [userId, postId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND post_id = ?',
            [userId, postId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND post_id = ?',
          [value, userId, postId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, post_id, value) VALUES (?, ?, ?)',
          [userId, postId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Vote on a comment
async function voteOnComment(userId, commentId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the comment exists
      const [comment] = await conn.query('SELECT * FROM comment WHERE id = ?', [commentId]);
      if (!comment) {
        throw new Error('Comment not found');
      }
      
      // Check if the user has already voted on this comment
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND comment_id = ?',
        [userId, commentId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND comment_id = ?',
            [userId, commentId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND comment_id = ?',
          [value, userId, commentId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, comment_id, value) VALUES (?, ?, ?)',
          [userId, commentId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a post
async function getUserPostVote(userId, postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a comment
async function getUserCommentVote(userId, commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a post
async function getPostVoteCounts(postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a comment
async function getCommentVoteCounts(commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get all votes for a user
async function getUserVotes(userId) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get post votes
    const postVotes = await conn.query(
      `SELECT v.*, p.title as post_title, p.community_id
       FROM vote v
       JOIN post p ON v.post_id = p.id
       WHERE v.user_id = ? AND v.post_id IS NOT NULL`,
      [userId]
    );
    
    // Get comment votes
    const commentVotes = await conn.query(
      `SELECT v.*, c.content as comment_content, p.id as post_id, p.title as post_title, p.community_id
       FROM vote v
       JOIN comment c ON v.comment_id = c.id
       JOIN post p ON c.post_id = p.id
       WHERE v.user_id = ? AND v.comment_id IS NOT NULL`,
      [userId]
    );
    
    return {
      postVotes,
      commentVotes
    };
  } catch (error) {
    console.error('Error getting user votes:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Helper function to update SQL queries to include votes
function includePostVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes`;
}

function includeCommentVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.comment_id = c.id), 0) as votes`;
}

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

// Helper function to log vote activity
async function logVoteActivity(conn, userId, activityTypeId, actionId, entityId, entityType, voteValue) {
  await conn.query(
    `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      uuidv4(),
      userId,
      activityTypeId,
      actionId,
      entityId,
      entityType,
      JSON.stringify({ value: voteValue })
    ]
  );
}

module.exports = {
  voteOnPost,
  voteOnComment,
  getUserPostVote,
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes,
  includePostVotesInQuery,
  includeCommentVotesInQuery
};

================
File: backend/api/votes.ts
================
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Vote on a post
export async function voteOnPost(userId: string, postId: string, value: number): Promise<any> {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if the post exists
    const [post] = await conn.query('SELECT * FROM posts WHERE id = ?', [postId]);
    if (!post) {
      throw new Error('Post not found');
    }
    
    // Check if the user is voting on their own post
    // Uncomment this if you want to prevent users from voting on their own posts
    /*
    if (post.user_id === userId) {
      throw new Error('You cannot vote on your own post');
    }
    */
    
    // Check if the user has already voted on this post
    const [existingVote] = await conn.query(
      'SELECT * FROM votes WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    if (value === 0) {
      // If value is 0, remove the vote if it exists
      if (existingVote) {
        await conn.query(
          'DELETE FROM votes WHERE user_id = ? AND post_id = ?',
          [userId, postId]
        );
        return { message: 'Vote removed' };
      }
      return { message: 'No vote to remove' };
    }
    
    if (existingVote) {
      // Update the existing vote
      await conn.query(
        'UPDATE votes SET value = ? WHERE user_id = ? AND post_id = ?',
        [value, userId, postId]
      );
      return { message: 'Vote updated' };
    } else {
      // Insert a new vote
      await conn.query(
        'INSERT INTO votes (user_id, post_id, value) VALUES (?, ?, ?)',
        [userId, postId, value]
      );
      return { message: 'Vote added' };
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Vote on a comment
export async function voteOnComment(userId: string, commentId: string, value: number): Promise<any> {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if the comment exists
    const [comment] = await conn.query('SELECT * FROM comments WHERE id = ?', [commentId]);
    if (!comment) {
      throw new Error('Comment not found');
    }
    
    // Check if the user is voting on their own comment
    // Uncomment this if you want to prevent users from voting on their own comments
    /*
    if (comment.user_id === userId) {
      throw new Error('You cannot vote on your own comment');
    }
    */
    
    // Check if the user has already voted on this comment
    const [existingVote] = await conn.query(
      'SELECT * FROM votes WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    if (value === 0) {
      // If value is 0, remove the vote if it exists
      if (existingVote) {
        await conn.query(
          'DELETE FROM votes WHERE user_id = ? AND comment_id = ?',
          [userId, commentId]
        );
        return { message: 'Vote removed' };
      }
      return { message: 'No vote to remove' };
    }
    
    if (existingVote) {
      // Update the existing vote
      await conn.query(
        'UPDATE votes SET value = ? WHERE user_id = ? AND comment_id = ?',
        [value, userId, commentId]
      );
      return { message: 'Vote updated' };
    } else {
      // Insert a new vote
      await conn.query(
        'INSERT INTO votes (user_id, comment_id, value) VALUES (?, ?, ?)',
        [userId, commentId, value]
      );
      return { message: 'Vote added' };
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get user's vote on a post
export async function getUserPostVote(userId: string, postId: string): Promise<number> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM votes WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get user's vote on a comment
export async function getUserCommentVote(userId: string, commentId: string): Promise<number> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM votes WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get vote counts for a post
export async function getPostVoteCounts(postId: string): Promise<{upvotes: number, downvotes: number, total: number}> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM votes 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Get vote counts for a comment
export async function getCommentVoteCounts(commentId: string): Promise<{upvotes: number, downvotes: number, total: number}> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM votes 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.end();
  }
}

// Helper function to update SQL queries to include votes
export function includePostVotesInQuery(baseQuery: string): string {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM votes v WHERE v.post_id = p.id), 0) as votes`;
}

export function includeCommentVotesInQuery(baseQuery: string): string {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM votes v WHERE v.comment_id = c.id), 0) as votes`;
}

================
File: backend/check-community.js
================
const mysql = require('mysql2/promise');
require('dotenv').config();

async function run() {
  try {
    // Create the connection
    const connection = await mysql.createConnection({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
    });
    
    // Test for a specific community ID
    const communityId = '0b95216a-d272-47a4-ab4d-0af7417e868b'; // This is the ID that's failing
    
    // Check community details
    try {
      const [community] = await connection.query('SELECT * FROM community WHERE id = ?', [communityId]);
      console.log('Community found:', community.length > 0);
      if (community.length > 0) {
        console.log('Community details:', community[0]);
      }
    } catch (err) {
      console.error('Error accessing community:', err.message);
    }
    
    // Check community members
    try {
      const [members] = await connection.query('SELECT * FROM community_member WHERE community_id = ?', [communityId]);
      console.log('\nCommunity members found:', members.length);
      if (members.length > 0) {
        console.log('Sample member:', members[0]);
      }
    } catch (err) {
      console.error('Error accessing community members:', err.message);
    }
    
    // Check community rules
    try {
      const [rules] = await connection.query('SELECT * FROM community_rule WHERE community_id = ?', [communityId]);
      console.log('\nCommunity rules found:', rules.length);
      if (rules.length > 0) {
        console.log('Sample rule:', rules[0]);
      }
    } catch (err) {
      console.error('Error accessing community rules:', err.message);
    }
    
    // Check community settings
    try {
      const [settings] = await connection.query('SELECT * FROM community_setting WHERE community_id = ?', [communityId]);
      console.log('\nCommunity settings found:', settings.length);
      if (settings.length > 0) {
        console.log('Settings:', settings[0]);
      }
    } catch (err) {
      console.error('Error accessing community settings:', err.message);
    }
    
    // Check posts in this community
    try {
      const [posts] = await connection.query('SELECT * FROM post WHERE community_id = ? LIMIT 5', [communityId]);
      console.log('\nPosts found:', posts.length);
      if (posts.length > 0) {
        console.log('Sample post:', { 
          id: posts[0].id,
          title: posts[0].title,
          user_id: posts[0].user_id
        });
      }
    } catch (err) {
      console.error('Error accessing posts:', err.message);
    }

    await connection.end();
  } catch (err) {
    console.error('Database error:', err);
  }
}

run();

================
File: backend/check-tables.js
================
const mysql = require('mysql2/promise');
require('dotenv').config();

async function run() {
  try {
    // Create the connection directly using the .env variables
    const connection = await mysql.createConnection({
      host: process.env.DB_HOST,
      port: process.env.DB_PORT,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
    });
    
    console.log(`Connected to database: ${process.env.DB_NAME} on ${process.env.DB_HOST}`);
    
    // Check tables
    const [tables] = await connection.query('SHOW TABLES');
    console.log('Tables in the database:');
    tables.forEach(row => {
      const tableName = Object.values(row)[0];
      console.log(tableName);
    });
    
    // Check example data from a community table
    try {
      // Try both singular and plural forms
      let communities;
      try {
        [communities] = await connection.query('SELECT id, name FROM community LIMIT 5');
        console.log("\nUsing singular 'community' table name");
      } catch (err) {
        [communities] = await connection.query('SELECT id, name FROM communities LIMIT 5');
        console.log("\nUsing plural 'communities' table name");
      }
      
      console.log('Sample community data:');
      communities.forEach(community => {
        console.log(`ID: ${community.id}, Name: ${community.name}`);
      });
    } catch (err) {
      console.error('Error accessing community data:', err.message);
    }

    await connection.end();
  } catch (err) {
    console.error('Database error:', err);
  }
}

run();

================
File: backend/db/add_admin_user.js
================
// Script to add an admin user to the rumfornew2 database
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');
const bcrypt = require('bcrypt');

// Database connection configuration
const dbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  database: 'rumfornew2',
  multipleStatements: true
};

// Admin user details
const adminUser = {
  username: 'admin',
  email: 'admin@example.com',
  password: 'Oswald1986!',
  role: 'admin',
  display_name: 'Administrator'
};

// Helper function to execute a query and log the result
async function executeQuery(connection, query, params = []) {
  try {
    const [result] = await connection.execute(query, params);
    return result;
  } catch (error) {
    console.error(`Error executing query: ${query}`);
    console.error(error);
    throw error;
  }
}

// Main function to add the admin user
async function addAdminUser() {
  let connection;
  
  try {
    // Connect to the database
    connection = await mysql.createConnection(dbConfig);
    console.log('Connected to database');
    
    // Generate a UUID for the admin user
    const userId = uuidv4();
    
    // Hash the password
    const saltRounds = 10;
    const passwordHash = await bcrypt.hash(adminUser.password, saltRounds);
    
    // Check if admin user already exists
    const existingUsers = await executeQuery(
      connection,
      'SELECT * FROM user WHERE username = ? OR email = ?',
      [adminUser.username, adminUser.email]
    );
    
    if (existingUsers.length > 0) {
      console.log('Admin user already exists. Skipping creation.');
      return;
    }
    
    // Insert the admin user
    await executeQuery(
      connection,
      `INSERT INTO user (
        id, username, email, password_hash, role, display_name,
        is_verified, status, created_at, updated_at, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), NOW())`,
      [
        userId,
        adminUser.username,
        adminUser.email,
        passwordHash,
        adminUser.role,
        adminUser.display_name,
        1, // is_verified
        'active', // status
      ]
    );
    
    // Insert user statistics
    await executeQuery(
      connection,
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count,
        upvotes_received, downvotes_received, upvotes_given, downvotes_given,
        communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        userId,
        1000, // karma
        0, // posts_count
        0, // comments_count
        0, // upvotes_received
        0, // downvotes_received
        0, // upvotes_given
        0, // downvotes_given
        0, // communities_joined
      ]
    );
    
    // Insert user settings
    await executeQuery(
      connection,
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, theme,
        content_filter, allow_followers, display_online_status,
        language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        userId,
        1, // email_notifications
        1, // push_notifications
        'light', // theme
        'standard', // content_filter
        1, // allow_followers
        1, // display_online_status
        'en', // language
        'UTC', // timezone
      ]
    );
    
    console.log(`Admin user created successfully with ID: ${userId}`);
    console.log(`Username: ${adminUser.username}`);
    console.log(`Password: ${adminUser.password}`);
  } catch (error) {
    console.error('Error adding admin user:', error);
  } finally {
    // Close connection
    if (connection) await connection.end();
  }
}

// Run the function
addAdminUser();

================
File: backend/db/apply_auth_schema.js
================
// Script to apply the auth schema changes
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const pool = require('./connection');

async function applyAuthSchema() {
  console.log('Applying auth schema changes...');
  
  try {
    // 1. Create backup of original files
    console.log('Creating backups of original files...');
    
    const filesToBackup = [
      { src: '../api/auth.js', dest: '../api/auth.js.bak' },
      { src: '../api/auth.ts', dest: '../api/auth.ts.bak' },
      { src: '../routes/auth.js', dest: '../routes/auth.js.bak' }
    ];
    
    for (const file of filesToBackup) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Backed up ${file.src} to ${file.dest}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping backup`);
      }
    }
    
    // 2. Apply database schema changes
    console.log('Applying database schema changes...');
    
    const conn = await pool.getConnection();
    
    try {
      // Start transaction
      await conn.beginTransaction();
      
      // Check if the user table already exists
      const [userTableExists] = await conn.query(
        "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'user'"
      );
      
      if (userTableExists.count === 0) {
        console.log('Creating user table...');
        
        // Rename users table to user if it exists
        const [usersTableExists] = await conn.query(
          "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'users'"
        );
        
        if (usersTableExists.count > 0) {
          await conn.query("RENAME TABLE users TO user");
          console.log('Renamed users table to user');
          
          // Add new columns to user table
          const columnsToAdd = [
            "ADD COLUMN IF NOT EXISTS first_name VARCHAR(50) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS last_name VARCHAR(50) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS display_name VARCHAR(50) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS date_of_birth DATE DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS bio TEXT DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(255) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS profile_banner_url VARCHAR(255) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS website VARCHAR(255) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS location VARCHAR(100) DEFAULT NULL",
            "ADD COLUMN IF NOT EXISTS is_verified BOOLEAN DEFAULT FALSE",
            "ADD COLUMN IF NOT EXISTS status VARCHAR(50) DEFAULT 'active'",
            "ADD COLUMN IF NOT EXISTS cake_day DATETIME DEFAULT CURRENT_TIMESTAMP",
            "ADD COLUMN IF NOT EXISTS last_active DATETIME DEFAULT CURRENT_TIMESTAMP"
          ];
          
          for (const column of columnsToAdd) {
            try {
              await conn.query(`ALTER TABLE user ${column}`);
              console.log(`Added column: ${column}`);
            } catch (error) {
              console.warn(`Warning: Could not add column: ${column}`, error.message);
            }
          }
        } else {
          // Create user table from scratch
          await conn.query(`
            CREATE TABLE user (
              id VARCHAR(36) PRIMARY KEY,
              username VARCHAR(50) NOT NULL UNIQUE,
              email VARCHAR(100) NOT NULL UNIQUE,
              password_hash VARCHAR(255) NOT NULL,
              role VARCHAR(20) NOT NULL DEFAULT 'user',
              first_name VARCHAR(50) DEFAULT NULL,
              last_name VARCHAR(50) DEFAULT NULL,
              display_name VARCHAR(50) DEFAULT NULL,
              date_of_birth DATE DEFAULT NULL,
              bio TEXT DEFAULT NULL,
              avatar_url VARCHAR(255) DEFAULT NULL,
              profile_banner_url VARCHAR(255) DEFAULT NULL,
              website VARCHAR(255) DEFAULT NULL,
              location VARCHAR(100) DEFAULT NULL,
              is_verified BOOLEAN DEFAULT FALSE,
              status VARCHAR(50) DEFAULT 'active',
              cake_day DATETIME DEFAULT CURRENT_TIMESTAMP,
              created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
              updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
              last_active DATETIME DEFAULT CURRENT_TIMESTAMP,
              INDEX idx_username (username),
              INDEX idx_email (email),
              INDEX idx_role (role)
            )
          `);
          console.log('Created user table');
        }
      } else {
        console.log('User table already exists, skipping creation');
      }
      
      // Create user_statistic table if it doesn't exist
      const [userStatisticTableExists] = await conn.query(
        "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'user_statistic'"
      );
      
      if (userStatisticTableExists.count === 0) {
        console.log('Creating user_statistic table...');
        
        await conn.query(`
          CREATE TABLE user_statistic (
            user_id VARCHAR(36) PRIMARY KEY,
            karma INT DEFAULT 0,
            posts_count INT DEFAULT 0,
            comments_count INT DEFAULT 0,
            upvotes_received INT DEFAULT 0,
            downvotes_received INT DEFAULT 0,
            upvotes_given INT DEFAULT 0,
            downvotes_given INT DEFAULT 0,
            communities_joined INT DEFAULT 0,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
          )
        `);
        console.log('Created user_statistic table');
        
        // Populate user_statistic table with existing users
        await conn.query(`
          INSERT INTO user_statistic (user_id, created_at, updated_at)
          SELECT id, created_at, updated_at FROM user
          WHERE id NOT IN (SELECT user_id FROM user_statistic)
        `);
        console.log('Populated user_statistic table with existing users');
      } else {
        console.log('User_statistic table already exists, skipping creation');
      }
      
      // Create user_setting table if it doesn't exist
      const [userSettingTableExists] = await conn.query(
        "SELECT COUNT(*) as count FROM information_schema.tables WHERE table_schema = DATABASE() AND table_name = 'user_setting'"
      );
      
      if (userSettingTableExists.count === 0) {
        console.log('Creating user_setting table...');
        
        await conn.query(`
          CREATE TABLE user_setting (
            user_id VARCHAR(36) PRIMARY KEY,
            email_notifications BOOLEAN DEFAULT TRUE,
            push_notifications BOOLEAN DEFAULT TRUE,
            theme VARCHAR(20) DEFAULT 'light',
            content_filter VARCHAR(20) DEFAULT 'standard',
            allow_followers BOOLEAN DEFAULT TRUE,
            display_online_status BOOLEAN DEFAULT TRUE,
            language VARCHAR(10) DEFAULT 'en',
            timezone VARCHAR(50) DEFAULT 'UTC',
            updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
          )
        `);
        console.log('Created user_setting table');
        
        // Populate user_setting table with existing users
        await conn.query(`
          INSERT INTO user_setting (user_id, updated_at)
          SELECT id, updated_at FROM user
          WHERE id NOT IN (SELECT user_id FROM user_setting)
        `);
        console.log('Populated user_setting table with existing users');
      } else {
        console.log('User_setting table already exists, skipping creation');
      }
      
      // Commit transaction
      await conn.commit();
      console.log('Database schema changes applied successfully');
      
    } catch (error) {
      // Rollback transaction on error
      await conn.rollback();
      console.error('Error applying database schema changes:', error);
      throw error;
    } finally {
      conn.release();
    }
    
    // 3. Replace the auth files with the new versions
    console.log('Replacing auth files with new versions...');
    
    const filesToReplace = [
      { src: '../api/auth.js.new', dest: '../api/auth.js' },
      { src: '../api/auth.ts.new', dest: '../api/auth.ts' },
      { src: '../routes/auth.js.new', dest: '../routes/auth.js' }
    ];
    
    for (const file of filesToReplace) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Replaced ${file.dest} with ${file.src}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping replacement`);
      }
    }
    
    console.log('Auth schema changes applied successfully!');
    
  } catch (error) {
    console.error('Error applying auth schema changes:', error);
    process.exit(1);
  }
}

// Run the function
applyAuthSchema().then(() => {
  console.log('Auth schema update completed');
  process.exit(0);
}).catch(error => {
  console.error('Auth schema update failed:', error);
  process.exit(1);
});

================
File: backend/db/apply_comments_schema.js
================
// Apply comments schema updates to the database
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function applyCommentsSchema() {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log('Connected to the database');

    // Read the SQL file
    const sqlFilePath = path.join(__dirname, 'comments_schema_updates.sql');
    const sql = fs.readFileSync(sqlFilePath, 'utf8');

    // Split the SQL file into individual statements
    const statements = sql
      .split(';')
      .filter(statement => statement.trim() !== '');

    // Execute each statement
    for (const statement of statements) {
      try {
        await conn.query(statement);
        console.log('Executed statement:', statement.trim().substring(0, 50) + '...');
      } catch (err) {
        console.error('Error executing statement:', statement.trim());
        console.error('Error details:', err);
      }
    }

    console.log('Comments schema updates applied successfully');
  } catch (err) {
    console.error('Error applying comments schema updates:', err);
  } finally {
    if (conn) {
      conn.end();
    }
    process.exit(0);
  }
}

// Run the function
applyCommentsSchema();

================
File: backend/db/apply_community_updates.js
================
// backend/db/apply_community_updates.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

const pool = mariadb.createPool({
    host: '192.168.0.139',
    port: 3306,
    user: 'root',
    password: 'Oswald1986!',
    database: 'rumfor1',
    connectionLimit: 15
});

async function applySchemaUpdates() {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log('Connected to database!');

        // Read the SQL file
        const sqlFilePath = path.join(__dirname, 'community_schema_updates.sql');
        const sql = fs.readFileSync(sqlFilePath, 'utf8');

        // Split the SQL file into individual statements
        const statements = sql.split(';').filter(statement => statement.trim() !== '');

        // Execute each statement
        for (const statement of statements) {
            await conn.query(statement);
        }

        console.log('Schema updates applied successfully!');
    } catch (err) {
        console.error('Error applying schema updates:', err);
    } finally {
        if (conn) {
            conn.end();
        }
    }
}

applySchemaUpdates();

================
File: backend/db/apply_moderator_schema.js
================
// apply_moderator_schema.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
const dotenv = require('dotenv');

dotenv.config({ path: path.resolve(__dirname, '../.env') });

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 10, // Increased connection limit
    connectTimeout: 30000 // Added connection timeout (30 seconds)
});

async function applySchemaUpdates() {
    let conn;
    console.log(`Attempting to connect to database: ${process.env.DB_NAME}`); // Log the database name
    try {
        conn = await pool.getConnection();
        console.log('Connected to database. Applying moderator schema updates...');

        const schemaFilePath = path.join(__dirname, 'moderator_schema_updates.sql');
        const schemaSQL = fs.readFileSync(schemaFilePath, 'utf8');

        // Split by semicolon to execute each statement separately
        const statements = schemaSQL.split(';').filter(stmt => stmt.trim());

        for (const statement of statements) {
            if (statement.trim()) {
                await conn.query(statement);
                console.log('Executed SQL statement.');
            }
        }

        console.log('Moderator schema updates applied successfully!');
    } catch (error) {
        console.error('Error applying moderator schema updates:', error);
    } finally {
        if (conn) conn.end();
    }
}

applySchemaUpdates();

================
File: backend/db/apply_new_schema.js
================
// Script to apply the new database schema to rumfornew2
const mysql = require('mysql2/promise');
const fs = require('fs');
const path = require('path');

// Database connection configuration
const dbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  multipleStatements: true // Required for executing multiple SQL statements
};

async function createDatabase() {
  // First connect to MySQL without specifying a database
  const rootConnection = await mysql.createConnection({
    host: dbConfig.host,
    port: dbConfig.port,
    user: 'root', // Need root privileges to create database and user
    password: 'Oswald1986!' // Root password
  });

  try {
    console.log('Creating database and user...');
    
    // Drop the database if it exists
    await rootConnection.query(`DROP DATABASE IF EXISTS rumfornew2`);
    
    // Create the database
    await rootConnection.query(`CREATE DATABASE rumfornew2`);
    
    // Check if user exists and create if not
    try {
      await rootConnection.query(`
        CREATE USER 'rumfornew2'@'%' IDENTIFIED BY 'Oswald1986!';
      `);
      
      // Grant privileges
      await rootConnection.query(`GRANT ALL PRIVILEGES ON rumfornew2.* TO 'rumfornew2'@'%'`);
      await rootConnection.query(`FLUSH PRIVILEGES`);
      
      console.log('User created and privileges granted.');
    } catch (error) {
      // User might already exist
      console.log('User already exists or error creating user:', error.message);
      
      // Make sure privileges are granted
      await rootConnection.query(`GRANT ALL PRIVILEGES ON rumfornew2.* TO 'rumfornew2'@'%'`);
      await rootConnection.query(`FLUSH PRIVILEGES`);
      
      console.log('Privileges granted.');
    }
  } finally {
    await rootConnection.end();
  }
}

async function applySchema() {
  // Read the schema file
  const schemaPath = path.join(__dirname, 'simple_schema.sql');
  const schema = fs.readFileSync(schemaPath, 'utf8');
  
  // Connect to the new database
  const connection = await mysql.createConnection({
    ...dbConfig,
    database: 'rumfornew2',
    multipleStatements: true
  });
  
  try {
    console.log('Applying schema...');
    
    // Execute the entire schema as a single statement
    await connection.query(schema);
    
    console.log('Schema applied successfully!');
  } catch (error) {
    console.error('Error applying schema:', error);
    throw error;
  } finally {
    await connection.end();
  }
}

async function main() {
  try {
    await createDatabase();
    await applySchema();
    console.log('Database setup completed successfully!');
  } catch (error) {
    console.error('Error setting up database:', error);
    process.exit(1);
  }
}

main();

================
File: backend/db/apply_user_auth_schema.js
================
// backend/db/apply_user_auth_schema.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

async function applyUserAuthSchema() {
    let conn;
    try {
        console.log('Connecting to MariaDB...');
        console.log('Connection details:', {
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            user: process.env.DB_USER,
            database: process.env.DB_NAME
        });
        
        conn = await pool.getConnection();
        console.log('Connected to MariaDB!');
        
        // Read the SQL file
        const sqlFilePath = path.join(__dirname, 'user_auth_schema.sql');
        console.log('Reading SQL file from:', sqlFilePath);
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        
        // Split the SQL file into individual statements
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
        console.log(`Found ${statements.length} SQL statements to execute`);
        
        // Execute each statement
        for (const statement of statements) {
            console.log(`Executing: ${statement}`);
            try {
                const result = await conn.query(statement);
                console.log('Statement executed successfully');
            } catch (err) {
                console.error('Error executing statement:', err.message);
                // Continue with the next statement
            }
        }
        
        // Create admin user if it doesn't exist
        const adminId = uuidv4();
        const adminUsername = 'admin';
        const adminEmail = 'admin@example.com';
        const adminPassword = 'Admin123!'; // This should be changed after first login
        
        // Check if admin user already exists
        const [existingAdmin] = await conn.query(
            "SELECT * FROM users WHERE username = ? OR email = ?",
            [adminUsername, adminEmail]
        );
        
        if (!existingAdmin) {
            console.log('Creating admin user...');
            // Hash the password
            const saltRounds = 10;
            const hashedPassword = await bcrypt.hash(adminPassword, saltRounds);
            
            // Insert admin user
            await conn.query(
                "INSERT INTO users (id, username, email, password_hash, role) VALUES (?, ?, ?, ?, ?)",
                [adminId, adminUsername, adminEmail, hashedPassword, 'admin']
            );
            
            console.log('Admin user created successfully!');
            console.log('Admin credentials:');
            console.log('Username:', adminUsername);
            console.log('Password:', adminPassword);
            console.log('Please change this password after first login!');
        } else {
            console.log('Admin user already exists, skipping creation.');
        }
        
        console.log('User authentication schema updates applied successfully!');
    } catch (err) {
        console.error('Error applying user authentication schema:', err);
    } finally {
        if (conn) {
            console.log('Closing database connection');
            conn.end();
        }
    }
}

applyUserAuthSchema();

================
File: backend/db/apply_user_statistics_schema.js
================
const fs = require('fs');
const path = require('path');
const mysql = require('mysql2/promise');
require('dotenv').config();

async function applyUserStatisticsSchema() {
  // Read the SQL file
  const sqlFilePath = path.join(__dirname, 'user_statistics_schema.sql');
  const sql = fs.readFileSync(sqlFilePath, 'utf8');

  // Split the SQL file into individual statements
  // This is a simple approach and might not work for all SQL files
  const statements = sql
    .replace(/DELIMITER \/\//g, '') // Remove DELIMITER statements
    .replace(/END \/\//g, 'END;')   // Replace END // with END;
    .replace(/DELIMITER ;/g, '')    // Remove DELIMITER ; statements
    .split(';')
    .filter(statement => statement.trim() !== '');

  // Create a connection to the database
  const connection = await mysql.createConnection({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'rumfor',
    multipleStatements: true
  });

  try {
    console.log('Applying user statistics schema...');

    // Execute each statement
    for (const statement of statements) {
      try {
        await connection.query(statement);
        console.log('Executed statement successfully');
      } catch (err) {
        console.error('Error executing statement:', err);
        console.error('Statement:', statement);
      }
    }

    console.log('User statistics schema applied successfully');
  } catch (err) {
    console.error('Error applying user statistics schema:', err);
  } finally {
    await connection.end();
  }
}

// Run the function
applyUserStatisticsSchema().catch(console.error);

================
File: backend/db/apply_votes_schema.js
================
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

async function applyVotesSchema() {
  require('dotenv').config({ path: path.resolve(__dirname, '../.env') });
  console.log('Connecting to database with:', {
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
  });
  let conn;
  try {
    conn = await mariadb.createConnection({
      host: process.env.DB_HOST,
      port: Number(process.env.DB_PORT),
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      multipleStatements: true
    });

    const sqlPath = path.join(__dirname, 'votes_schema_update.sql');
    const sql = fs.readFileSync(sqlPath, 'utf8');

    console.log('Applying votes schema updates...');
    const result = await conn.query(sql);
    console.log('Votes schema updated successfully!');
    return result;
  } catch (err) {
    console.error('Error updating votes schema:', err);
    throw err;
  } finally {
    if (conn) {
      conn.end();
    }
  }
}

// Run the function directly if this script is executed directly
if (require.main === module) {
  applyVotesSchema()
    .then(() => {
      console.log('Schema update completed.');
      process.exit(0);
    })
    .catch(err => {
      console.error('Failed to update schema:', err);
      process.exit(1);
    });
}

module.exports = { applyVotesSchema };

================
File: backend/db/comments_schema_updates.sql
================
-- Add parent_comment_id column to comments table for threaded replies
ALTER TABLE comments ADD COLUMN IF NOT EXISTS parent_comment_id VARCHAR(36) DEFAULT NULL;

-- Add foreign key constraint for parent_comment_id
ALTER TABLE comments ADD CONSTRAINT IF NOT EXISTS fk_parent_comment
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id)
    ON DELETE SET NULL;

-- Add profile_post column to posts table to distinguish between community posts and profile posts
ALTER TABLE posts ADD COLUMN IF NOT EXISTS profile_post BOOLEAN DEFAULT FALSE;

-- Add user_profile_id column to posts table for posts on user profiles
ALTER TABLE posts ADD COLUMN IF NOT EXISTS user_profile_id VARCHAR(36) DEFAULT NULL;

-- Add foreign key constraint for user_profile_id
ALTER TABLE posts ADD CONSTRAINT IF NOT EXISTS fk_user_profile
    FOREIGN KEY (user_profile_id) REFERENCES users(id)
    ON DELETE CASCADE;

-- Create index for faster comment retrieval by post_id
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id);

-- Create index for faster comment retrieval by parent_comment_id
CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments(parent_comment_id);

-- Create index for faster post retrieval by user_profile_id
CREATE INDEX IF NOT EXISTS idx_posts_user_profile ON posts(user_profile_id);

================
File: backend/db/community_schema_updates.sql
================
-- Add privacy column to communities table
ALTER TABLE communities ADD COLUMN IF NOT EXISTS privacy VARCHAR(10) DEFAULT 'public';

-- Create community_members table for tracking membership
CREATE TABLE IF NOT EXISTS community_members (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create community_rules table
CREATE TABLE IF NOT EXISTS community_rules (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

-- Create community_settings table
CREATE TABLE IF NOT EXISTS community_settings (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

-- Create join requests table for tracking pending membership requests
CREATE TABLE IF NOT EXISTS community_join_requests (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

================
File: backend/db/connection.d.ts
================
import { Pool } from 'mysql2/promise';

/**
 * MySQL connection pool for database operations
 */
declare const pool: Pool;

export = pool;

================
File: backend/db/connection.js
================
const mysql = require('mysql2/promise');
require('dotenv').config();

/**
 * Creates a database connection pool with error handling and retry capabilities
 * @returns {Object} MySQL connection pool
 */
function createConnectionPool() {
  // Default database configuration
  const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306', 10),
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'rumfornew2',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
  };

  // Create the pool
  const pool = mysql.createPool(dbConfig);

  // Test the connection
  pool.getConnection()
    .then(conn => {
      console.log(`Connected to MySQL database: ${dbConfig.database} on ${dbConfig.host}:${dbConfig.port}`);
      conn.release();
    })
    .catch(err => {
      console.error('Error connecting to database:', err.message);
      console.error('Please check your database connection settings in the .env file.');
      
      // Provide more detailed error messages for common issues
      if (err.code === 'ECONNREFUSED') {
        console.error('Connection refused. Make sure the database server is running and accessible.');
      } else if (err.code === 'ER_ACCESS_DENIED_ERROR') {
        console.error('Access denied. Check your database username and password.');
      } else if (err.code === 'ER_BAD_DB_ERROR') {
        console.error(`Database '${dbConfig.database}' does not exist. Run the database setup scripts first.`);
      }
    });

  return pool;
}

// Create the connection pool for the new database schema
const pool = createConnectionPool();

// Export the connection pool
module.exports = pool;

================
File: backend/db/connection.ts
================
import mysql from 'mysql2/promise';
import dotenv from 'dotenv';
dotenv.config();

/**
 * Creates a database connection pool with error handling and retry capabilities
 * @returns MySQL connection pool
 */
function createConnectionPool() {
  // Default database configuration
  const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306', 10),
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'rumfornew2',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
  };

  // Create the pool
  const pool = mysql.createPool(dbConfig);

  // Test the connection
  pool.getConnection()
    .then(conn => {
      console.log(`Connected to MySQL database: ${dbConfig.database} on ${dbConfig.host}:${dbConfig.port}`);
      conn.release();
    })
    .catch(err => {
      console.error('Error connecting to database:', err.message);
      console.error('Please check your database connection settings in the .env file.');
      
      // Provide more detailed error messages for common issues
      if (err.code === 'ECONNREFUSED') {
        console.error('Connection refused. Make sure the database server is running and accessible.');
      } else if (err.code === 'ER_ACCESS_DENIED_ERROR') {
        console.error('Access denied. Check your database username and password.');
      } else if (err.code === 'ER_BAD_DB_ERROR') {
        console.error(`Database '${dbConfig.database}' does not exist. Run the database setup scripts first.`);
      }
    });

  return pool;
}

// Create the connection pool
const pool = createConnectionPool();

// Export the connection pool
export default pool;

================
File: backend/db/fetch_usernames.js
================
// Helper script to update community_members with usernames
const mariadb = require('mariadb');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function updateMembersWithUsernames() {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Get all users
    const users = await conn.query("SELECT id, username FROM users");
    
    if (users.length === 0) {
      console.log("No users found in the database");
      return;
    }
    
    console.log(`Found ${users.length} users`);
    
    // Create a map of user IDs to usernames
    const userMap = new Map();
    users.forEach(user => {
      userMap.set(user.id, user.username);
    });
    
    // Get all community members
    const members = await conn.query("SELECT * FROM community_members");
    
    if (members.length === 0) {
      console.log("No community members found in the database");
      return;
    }
    
    console.log(`Found ${members.length} community members`);
    
    // Create a test query that retrieves members with usernames
    try {
      const testQuery = `
        SELECT cm.*, u.username 
        FROM community_members cm 
        LEFT JOIN users u ON cm.user_id = u.id 
        LIMIT 10
      `;
      
      const testResult = await conn.query(testQuery);
      console.log("Test query result:", testResult);
      
      // If we got here, the query worked!
      console.log("LEFT JOIN to users table works correctly");
    } catch (error) {
      console.error("LEFT JOIN test failed:", error.message);
      console.log("User IDs in community_members might not match users table IDs");
    }
    
    // Report on moderation status
    const moderators = members.filter(m => m.role === 'moderator' || m.role === 'admin');
    console.log(`Found ${moderators.length} moderators/admins`);
    
    for (const mod of moderators) {
      const username = userMap.get(mod.user_id) || 'Unknown User';
      console.log(`Community ${mod.community_id}: Moderator ${username} (${mod.user_id}), role: ${mod.role}`);
    }
    
    console.log("Database check complete");
  } catch (error) {
    console.error("Error updating members with usernames:", error);
  } finally {
    if (conn) conn.release();
    process.exit(0);
  }
}

updateMembersWithUsernames();

================
File: backend/db/fix_community_api.js
================
// Fix the community API issues by adding proper tables and data
const mariadb = require('mariadb');
const dotenv = require('dotenv');
const path = require('path');

// Load environment variables
dotenv.config({ path: path.resolve(__dirname, '../.env') });

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function fixCommunityApi() {
  let conn;

  try {
    conn = await pool.getConnection();

    // 1. Add privacy column to communities table if it doesn't exist
    try {
      await conn.query(`
        ALTER TABLE communities 
        ADD COLUMN IF NOT EXISTS privacy ENUM('public', 'private') DEFAULT 'public'
      `);
      console.log('Added privacy column to communities table');
    } catch (error) {
      console.log('Skipping adding privacy column - may already exist or table structure is different');
    }

    // 2. Create community_members table if it doesn't exist
    try {
      await conn.query(`
        CREATE TABLE IF NOT EXISTS community_members (
          community_id VARCHAR(36) NOT NULL,
          user_id VARCHAR(36) NOT NULL,
          role ENUM('member', 'moderator', 'admin') DEFAULT 'member',
          joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          PRIMARY KEY (community_id, user_id),
          FOREIGN KEY (community_id) REFERENCES communities(id) ON DELETE CASCADE,
          FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
        )
      `);
      console.log('Created or verified community_members table');
    } catch (error) {
      console.error('Error creating community_members table:', error);
    }

    // 3. Create community_rules table if it doesn't exist
    try {
      await conn.query(`
        CREATE TABLE IF NOT EXISTS community_rules (
          id VARCHAR(36) PRIMARY KEY,
          community_id VARCHAR(36) NOT NULL,
          title VARCHAR(255) NOT NULL,
          description TEXT,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
          FOREIGN KEY (community_id) REFERENCES communities(id) ON DELETE CASCADE
        )
      `);
      console.log('Created or verified community_rules table');
    } catch (error) {
      console.error('Error creating community_rules table:', error);
    }

    // 4. Create community_settings table if it doesn't exist
    try {
      await conn.query(`
        CREATE TABLE IF NOT EXISTS community_settings (
          community_id VARCHAR(36) PRIMARY KEY,
          allow_post_images BOOLEAN DEFAULT TRUE,
          allow_post_links BOOLEAN DEFAULT TRUE,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
          FOREIGN KEY (community_id) REFERENCES communities(id) ON DELETE CASCADE
        )
      `);
      console.log('Created or verified community_settings table');
    } catch (error) {
      console.error('Error creating community_settings table:', error);
    }

    // 5. Add default settings for communities that don't have them
    try {
      // Get all communities
      const communities = await conn.query('SELECT id FROM communities');
      
      // For each community, check if it has settings and add if not
      for (const community of communities) {
        const [setting] = await conn.query(
          'SELECT community_id FROM community_settings WHERE community_id = ?',
          [community.id]
        );
        
        if (!setting) {
          await conn.query(
            'INSERT INTO community_settings (community_id, allow_post_images, allow_post_links) VALUES (?, ?, ?)',
            [community.id, true, true]
          );
          console.log(`Added default settings for community ${community.id}`);
        }
      }
    } catch (error) {
      console.error('Error setting up default community settings:', error);
    }

    console.log('Database fixes complete');
  } catch (error) {
    console.error('Error fixing community API:', error);
  } finally {
    if (conn) conn.release();
  }
}

fixCommunityApi()
  .then(() => console.log('Fix script completed'))
  .catch(err => console.error('Fix script failed:', err))
  .finally(() => process.exit());

================
File: backend/db/fix_community_join_request.js
================
// Script to fix the community_join_request table issue
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

// Get database connection info from environment or use defaults
const DB_HOST = process.env.DB_HOST || '192.168.0.139';
const DB_PORT = process.env.DB_PORT || 3306;
const DB_USER = process.env.DB_USER || 'rumfornew2';
const DB_PASSWORD = process.env.DB_PASSWORD || 'Oswald1986!';
const DB_DATABASE = process.env.DB_DATABASE || 'rumfornew2';

const pool = mariadb.createPool({
    host: DB_HOST,
    port: DB_PORT,
    user: DB_USER,
    password: DB_PASSWORD,
    database: DB_DATABASE,
    connectionLimit: 5
});

async function applyFix() {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log(`Connected to database ${DB_DATABASE}!`);

        // Check if community_join_request exists
        console.log('Checking for community_join_request table...');
        const singularTableExists = await checkTableExists(conn, 'community_join_request');
        
        // Check if community_join_requests exists
        console.log('Checking for community_join_requests table...');
        const pluralTableExists = await checkTableExists(conn, 'community_join_requests');

        if (singularTableExists && !pluralTableExists) {
            // The singular form exists but not the plural - rename it
            console.log('Renaming community_join_request to community_join_requests...');
            await conn.query('RENAME TABLE community_join_request TO community_join_requests');
            console.log('Table renamed successfully!');
        } else if (!singularTableExists && !pluralTableExists) {
            // Neither exists - create the plural form
            console.log('Creating community_join_requests table...');
            await createJoinRequestsTable(conn);
            console.log('Table created successfully!');
        } else if (pluralTableExists) {
            console.log('community_join_requests table already exists, no changes needed.');
        }

        console.log('Fix applied successfully!');
    } catch (err) {
        console.error('Error applying fix:', err);
    } finally {
        if (conn) {
            conn.end();
        }
    }
}

async function checkTableExists(conn, tableName) {
    try {
        const rows = await conn.query(`
            SELECT COUNT(*) as count
            FROM information_schema.tables
            WHERE table_schema = DATABASE()
            AND table_name = ?
        `, [tableName]);
        
        return rows[0].count > 0;
    } catch (err) {
        console.error(`Error checking if table ${tableName} exists:`, err);
        return false;
    }
}

async function createJoinRequestsTable(conn) {
    const sql = `
    CREATE TABLE community_join_requests (
        id VARCHAR(36) PRIMARY KEY,
        community_id VARCHAR(36) NOT NULL,
        user_id VARCHAR(36) NOT NULL,
        status VARCHAR(20) DEFAULT 'pending',
        requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
        UNIQUE KEY (community_id, user_id),
        FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
    )`;
    
    await conn.query(sql);
}

// Run the fix
applyFix();

================
File: backend/db/fix_community_join_request.sql
================
-- Create community_join_requests table (plural name) to match what the code is expecting
CREATE TABLE IF NOT EXISTS community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Rename the table if it exists but with wrong name
-- This is the key fix - it renames the table to match what the code is expecting
ALTER TABLE community_join_request RENAME TO community_join_requests;

-- Make sure the auto-renaming worked, if not, create the new table directly
CREATE TABLE IF NOT EXISTS community_join_requests (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

================
File: backend/db/fix_community_join_table.bat
================
@echo off
echo ===================================================
echo Fixing Community Join Request Table Issue
echo ===================================================
echo.

cd %~dp0
node fix_community_join_request.js

pause

================
File: backend/db/fix_join_request_name.js
================
// Script to fix the community_join_request table issue
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');

// Database connection configuration (adjust as needed)
const pool = mariadb.createPool({
    host: process.env.DB_HOST || '192.168.0.139',
    port: Number(process.env.DB_PORT) || 3306,
    user: process.env.DB_USER || 'rumfornew2',
    password: process.env.DB_PASSWORD || 'Oswald1986!',
    database: process.env.DB_NAME || 'rumfornew2',
    connectionLimit: 5
});

async function fixJoinRequestTable() {
    let conn;
    try {
        conn = await pool.getConnection();
        console.log('Connected to database!');

        // Check if the table exists
        const [tableExists] = await conn.query(`
            SELECT COUNT(*) as count 
            FROM information_schema.tables 
            WHERE table_schema = DATABASE() 
            AND table_name = 'community_join_request'
        `);

        if (tableExists.count === 0) {
            console.log('Table community_join_request does not exist, creating it...');
            
            // Create the table with the correct name
            await conn.query(`
                CREATE TABLE community_join_request (
                    id VARCHAR(36) PRIMARY KEY,
                    community_id VARCHAR(36) NOT NULL,
                    user_id VARCHAR(36) NOT NULL,
                    status VARCHAR(20) DEFAULT 'pending', 
                    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
                    UNIQUE KEY (community_id, user_id),
                    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
                    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
                )
            `);
            
            console.log('Table created successfully!');
        } else {
            console.log('Table community_join_request already exists.');
        }

        console.log('Database fix completed successfully!');
    } catch (error) {
        console.error('Error fixing join request table:', error);
    } finally {
        if (conn) {
            await conn.end();
        }
    }
}

// Run the fix
fixJoinRequestTable();

================
File: backend/db/fix_join_request.bat
================
@echo off
echo ===================================================
echo Fixing Community Join Request Table Issue
echo ===================================================
echo.

cd %~dp0
node fix_join_request_name.js

pause

================
File: backend/db/fixed_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL, -- 'home', 'work', etc.
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User relationships
CREATE TABLE user_relationship (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    related_user_id VARCHAR(36) NOT NULL,
    relationship_type VARCHAR(20) NOT NULL, -- 'friend', 'follow', 'block'
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (related_user_id) REFERENCES user(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, related_user_id, relationship_type)
);

-- User achievements
CREATE TABLE user_achievement (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community join requests
CREATE TABLE community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User flair for communities
CREATE TABLE user_flair (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    text VARCHAR(50) NOT NULL,
    background_color VARCHAR(20) DEFAULT '#e0e0e0',
    text_color VARCHAR(20) DEFAULT '#000000',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, community_id)
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Vote table with support for both post and comment votes
CREATE TABLE vote (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, IFNULL(post_id, ''), IFNULL(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE,
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Saved items
CREATE TABLE saved_item (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    item_id VARCHAR(36) NOT NULL,
    item_type VARCHAR(20) NOT NULL, -- 'post', 'comment'
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    collection_name VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post moderation
CREATE TABLE post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE SET NULL
);

-- Banned users
CREATE TABLE banned_user (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (banned_by) REFERENCES user(id) ON DELETE CASCADE
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, community, etc.)
    entity_type VARCHAR(50), -- Type of the related entity (post, comment, community, etc.)
    metadata JSON, -- Additional data related to the activity
    ip_address VARCHAR(45), -- IPv4 or IPv6 address
    user_agent TEXT, -- Browser/client information
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Moderation logs
CREATE TABLE moderation_log (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Create indexes for faster queries
CREATE INDEX idx_post_user_id ON post(user_id);
CREATE INDEX idx_post_community_id ON post(community_id);
CREATE INDEX idx_comment_post_id ON comment(post_id);
CREATE INDEX idx_comment_user_id ON comment(user_id);
CREATE INDEX idx_comment_parent_id ON comment(parent_comment_id);
CREATE INDEX idx_vote_post_id ON vote(post_id);
CREATE INDEX idx_vote_comment_id ON vote(comment_id);
CREATE INDEX idx_activity_user_id ON activity(user_id);
CREATE INDEX idx_activity_type_id ON activity(activity_type_id);
CREATE INDEX idx_activity_action_id ON activity(action_id);
CREATE INDEX idx_activity_entity ON activity(entity_id, entity_type);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

================
File: backend/db/generate_sample_data.js
================
// Script to generate sample data for the new database
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');

// Database connection configuration
const dbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  database: 'rumfornew2',
  multipleStatements: true
};

// Helper function to execute a query and log the result
async function executeQuery(connection, query, params = []) {
  try {
    const [result] = await connection.execute(query, params);
    return result;
  } catch (error) {
    console.error(`Error executing query: ${query}`);
    console.error(error);
    throw error;
  }
}

// Generate sample users
async function generateUsers(connection, count = 10) {
  console.log(`Generating ${count} sample users...`);
  
  const users = [];
  
  for (let i = 0; i < count; i++) {
    const userId = uuidv4();
    const username = `user${i + 1}`;
    const email = `user${i + 1}@example.com`;
    
    // Insert user
    await executeQuery(
      connection,
      `INSERT INTO user (
        id, username, email, password_hash, role, bio, avatar_url,
        profile_banner_url, website, location, is_verified, status,
        cake_day, created_at, updated_at, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW(), NOW())`,
      [
        userId,
        username,
        email,
        '$2a$10$XQxBtEwPP1SXkQfdXMYgJeP4tELOWJKVJKxXpWlmJBcMjwFrVyeJC', // hashed 'password123'
        i === 0 ? 'admin' : 'user',
        `Bio for ${username}`,
        `https://example.com/avatars/${username}.jpg`,
        `https://example.com/banners/${username}.jpg`,
        `https://example.com/${username}`,
        `City ${i + 1}`,
        i < 3 ? 1 : 0, // First 3 users are verified
        'active',
        new Date(2020, 0, i + 1) // Different cake days
      ]
    );
    
    // Insert user statistics
    await executeQuery(
      connection,
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count,
        upvotes_received, downvotes_received, upvotes_given, downvotes_given,
        communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        userId,
        Math.floor(Math.random() * 1000), // Random karma
        Math.floor(Math.random() * 20), // Random posts count
        Math.floor(Math.random() * 50), // Random comments count
        Math.floor(Math.random() * 100), // Random upvotes received
        Math.floor(Math.random() * 20), // Random downvotes received
        Math.floor(Math.random() * 200), // Random upvotes given
        Math.floor(Math.random() * 50), // Random downvotes given
        Math.floor(Math.random() * 5) // Random communities joined
      ]
    );
    
    // Insert user settings
    await executeQuery(
      connection,
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, theme,
        content_filter, allow_followers, display_online_status,
        language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        userId,
        Math.random() > 0.3 ? 1 : 0, // 70% chance of email notifications enabled
        Math.random() > 0.5 ? 1 : 0, // 50% chance of push notifications enabled
        Math.random() > 0.7 ? 'dark' : 'light', // 30% chance of dark theme
        'standard',
        1, // Allow followers
        1, // Display online status
        'en',
        'UTC'
      ]
    );
    
    users.push({
      id: userId,
      username,
      email
    });
  }
  
  console.log(`Generated ${users.length} users`);
  return users;
}

// Generate sample communities
async function generateCommunities(connection, users, count = 5) {
  console.log(`Generating ${count} sample communities...`);
  
  const communities = [];
  
  for (let i = 0; i < count; i++) {
    const communityId = uuidv4();
    const name = `community${i + 1}`;
    
    // Insert community
    await executeQuery(
      connection,
      `INSERT INTO community (
        id, name, description, privacy, created_at, updated_at
      ) VALUES (?, ?, ?, ?, NOW(), NOW())`,
      [
        communityId,
        name,
        `Description for ${name}`,
        i === 0 ? 'private' : 'public' // First community is private
      ]
    );
    
    // Insert community settings
    await executeQuery(
      connection,
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, join_method,
        require_post_approval, restricted_words, custom_theme_color,
        custom_banner_url, minimum_account_age_days, minimum_karma_required,
        updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        communityId,
        1, // Allow post images
        1, // Allow post links
        i === 0 ? 'requires_approval' : 'auto_approve', // First community requires approval
        i === 0 ? 1 : 0, // First community requires post approval
        null, // No restricted words
        `#${Math.floor(Math.random() * 16777215).toString(16)}`, // Random color
        `https://example.com/community_banners/${name}.jpg`,
        i === 0 ? 30 : 0, // First community requires 30 days account age
        i === 0 ? 100 : 0 // First community requires 100 karma
      ]
    );
    
    // Add users as members
    for (let j = 0; j < users.length; j++) {
      // Skip some users for some communities to make it more realistic
      if (i > 0 && j > 0 && Math.random() < 0.3) continue;
      
      const role = j === 0 ? 'admin' : (j < 3 ? 'moderator' : 'member');
      
      await executeQuery(
        connection,
        `INSERT INTO community_member (
          community_id, user_id, role, joined_at
        ) VALUES (?, ?, ?, DATE_SUB(NOW(), INTERVAL ? DAY))`,
        [
          communityId,
          users[j].id,
          role,
          Math.floor(Math.random() * 365) // Joined 0-365 days ago
        ]
      );
      
      // Add moderator permissions for admins and moderators
      if (role === 'admin' || role === 'moderator') {
        await executeQuery(
          connection,
          `INSERT INTO moderator_permission (
            community_id, user_id, can_manage_settings, can_manage_members,
            can_manage_posts, can_manage_comments, created_at, updated_at
          ) VALUES (?, ?, ?, ?, ?, ?, NOW(), NOW())`,
          [
            communityId,
            users[j].id,
            role === 'admin' ? 1 : 0, // Only admins can manage settings
            1, // Both can manage members
            1, // Both can manage posts
            1  // Both can manage comments
          ]
        );
      }
    }
    
    // Add some community rules
    const ruleCount = Math.floor(Math.random() * 5) + 1; // 1-5 rules
    for (let j = 0; j < ruleCount; j++) {
      await executeQuery(
        connection,
        `INSERT INTO community_rule (
          id, community_id, title, description, created_at, updated_at
        ) VALUES (?, ?, ?, ?, NOW(), NOW())`,
        [
          uuidv4(),
          communityId,
          `Rule ${j + 1} for ${name}`,
          `Description for rule ${j + 1} in ${name}`
        ]
      );
    }
    
    communities.push({
      id: communityId,
      name
    });
  }
  
  console.log(`Generated ${communities.length} communities`);
  return communities;
}

// Generate sample posts
async function generatePosts(connection, users, communities, count = 20) {
  console.log(`Generating ${count} sample posts...`);
  
  const posts = [];
  
  for (let i = 0; i < count; i++) {
    const postId = uuidv4();
    const userIndex = Math.floor(Math.random() * users.length);
    const communityIndex = Math.floor(Math.random() * communities.length);
    
    // Insert post
    await executeQuery(
      connection,
      `INSERT INTO post (
        id, title, content, user_id, community_id, profile_post,
        user_profile_id, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? HOUR), DATE_SUB(NOW(), INTERVAL ? HOUR))`,
      [
        postId,
        `Post ${i + 1} Title`,
        `Content for post ${i + 1}. This is a sample post generated for testing purposes.`,
        users[userIndex].id,
        communities[communityIndex].id,
        0, // Not a profile post
        null, // No user profile
        Math.floor(Math.random() * 720), // 0-30 days ago
        Math.floor(Math.random() * 720) // 0-30 days ago
      ]
    );
    
    posts.push({
      id: postId,
      title: `Post ${i + 1} Title`,
      userId: users[userIndex].id,
      communityId: communities[communityIndex].id
    });
  }
  
  console.log(`Generated ${posts.length} posts`);
  return posts;
}

// Generate sample comments
async function generateComments(connection, users, posts, count = 50) {
  console.log(`Generating ${count} sample comments...`);
  
  const comments = [];
  
  for (let i = 0; i < count; i++) {
    const commentId = uuidv4();
    const userIndex = Math.floor(Math.random() * users.length);
    const postIndex = Math.floor(Math.random() * posts.length);
    
    // Determine if this is a reply to another comment
    const isReply = i > 10 && Math.random() < 0.3; // 30% chance of being a reply after the first 10 comments
    const parentCommentId = isReply ? comments[Math.floor(Math.random() * comments.length)].id : null;
    
    // Insert comment
    await executeQuery(
      connection,
      `INSERT INTO comment (
        id, content, user_id, post_id, parent_comment_id, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? MINUTE), DATE_SUB(NOW(), INTERVAL ? MINUTE))`,
      [
        commentId,
        `This is comment ${i + 1}. ${isReply ? 'This is a reply to another comment.' : 'This is a top-level comment.'}`,
        users[userIndex].id,
        posts[postIndex].id,
        parentCommentId,
        Math.floor(Math.random() * 43200), // 0-30 days ago
        Math.floor(Math.random() * 43200) // 0-30 days ago
      ]
    );
    
    comments.push({
      id: commentId,
      userId: users[userIndex].id,
      postId: posts[postIndex].id,
      parentCommentId
    });
  }
  
  console.log(`Generated ${comments.length} comments`);
  return comments;
}

// Generate sample activities
async function generateActivities(connection, users, posts, comments) {
  console.log('Generating sample activities...');
  
  // Get activity types and actions
  const activityTypes = await executeQuery(connection, 'SELECT * FROM activity_type');
  const actions = await executeQuery(connection, 'SELECT * FROM action');
  
  // Map for easier lookup
  const activityTypeMap = {};
  activityTypes.forEach(type => {
    activityTypeMap[type.name] = type.id;
  });
  
  const actionMap = {};
  actions.forEach(action => {
    actionMap[action.name] = action.id;
  });
  
  // Generate post creation activities
  for (const post of posts) {
    await executeQuery(
      connection,
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type,
        metadata, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? HOUR))`,
      [
        uuidv4(),
        post.userId,
        activityTypeMap['POST'],
        actionMap['CREATE'],
        post.id,
        'post',
        JSON.stringify({ title: post.title, community_id: post.communityId }),
        '127.0.0.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        Math.floor(Math.random() * 720) // 0-30 days ago
      ]
    );
  }
  
  // Generate comment creation activities
  for (const comment of comments) {
    await executeQuery(
      connection,
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type,
        metadata, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? MINUTE))`,
      [
        uuidv4(),
        comment.userId,
        activityTypeMap['COMMENT'],
        actionMap['CREATE'],
        comment.id,
        'comment',
        JSON.stringify({ post_id: comment.postId, parent_comment_id: comment.parentCommentId }),
        '127.0.0.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        Math.floor(Math.random() * 43200) // 0-30 days ago
      ]
    );
  }
  
  // Generate some vote activities
  const voteCount = 100; // Number of votes to generate
  for (let i = 0; i < voteCount; i++) {
    const userIndex = Math.floor(Math.random() * users.length);
    const isUpvote = Math.random() > 0.3; // 70% chance of upvote
    const isPostVote = Math.random() > 0.4; // 60% chance of post vote
    
    const entityId = isPostVote 
      ? posts[Math.floor(Math.random() * posts.length)].id
      : comments[Math.floor(Math.random() * comments.length)].id;
    
    const entityType = isPostVote ? 'post' : 'comment';
    
    await executeQuery(
      connection,
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type,
        metadata, ip_address, user_agent, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, DATE_SUB(NOW(), INTERVAL ? MINUTE))`,
      [
        uuidv4(),
        users[userIndex].id,
        activityTypeMap['VOTE'],
        isUpvote ? actionMap['UPVOTE'] : actionMap['DOWNVOTE'],
        entityId,
        entityType,
        JSON.stringify({ value: isUpvote ? 1 : -1 }),
        '127.0.0.1',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
        Math.floor(Math.random() * 43200) // 0-30 days ago
      ]
    );
  }
  
  console.log('Generated activities');
}

// Main function to generate all sample data
async function generateSampleData() {
  let connection;
  
  try {
    // Connect to the database
    connection = await mysql.createConnection(dbConfig);
    console.log('Connected to database');
    
    // Disable foreign key checks during data generation
    await executeQuery(connection, 'SET FOREIGN_KEY_CHECKS = 0');
    
    // Generate data in the correct order to maintain relationships
    const users = await generateUsers(connection);
    const communities = await generateCommunities(connection, users);
    const posts = await generatePosts(connection, users, communities);
    const comments = await generateComments(connection, users, posts);
    await generateActivities(connection, users, posts, comments);
    
    // Re-enable foreign key checks
    await executeQuery(connection, 'SET FOREIGN_KEY_CHECKS = 1');
    
    console.log('Sample data generation completed successfully!');
  } catch (error) {
    console.error('Error generating sample data:', error);
  } finally {
    // Close connection
    if (connection) await connection.end();
  }
}

// Run the sample data generation
generateSampleData();

================
File: backend/db/init_schema.js
================
// backend/db/init_schema.js
const fs = require('fs');
const path = require('path');
const mariadb = require('mariadb');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

async function initSchema() {
    let conn;
    try {
        console.log('Connecting to MariaDB...');
        console.log('Connection details:', {
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            user: process.env.DB_USER,
            database: process.env.DB_NAME
        });
        
        conn = await pool.getConnection();
        console.log('Connected to MariaDB!');
        
        // Read the SQL file
        const sqlFilePath = path.join(__dirname, 'schema.sql');
        console.log('Reading SQL file from:', sqlFilePath);
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        
        // Split the SQL file into individual statements
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
        console.log(`Found ${statements.length} SQL statements to execute`);
        
        // Execute each statement
        for (const statement of statements) {
            console.log(`Executing: ${statement}`);
            try {
                const result = await conn.query(statement);
                console.log('Statement executed successfully');
            } catch (err) {
                console.error('Error executing statement:', err.message);
                // Continue with the next statement
            }
        }
        
        console.log('Schema initialization completed!');
    } catch (err) {
        console.error('Error initializing schema:', err);
    } finally {
        if (conn) {
            console.log('Closing database connection');
            conn.end();
        }
    }
}

initSchema();

================
File: backend/db/init.js
================
import mariadb from 'mariadb';
import fs from 'fs';
import path from 'path';

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

async function initializeDatabase() {
    let conn;
    try {
        // Read schema file
        const schemaPath = path.join(__dirname, 'schema.sql');
        const schema = fs.readFileSync(schemaPath, 'utf8');

        // Get connection from pool
        conn = await pool.getConnection();
        
        // Execute schema
        await conn.query(schema);
        console.log('Database schema initialized successfully');
    } catch (error) {
        console.error('Error initializing database:', error);
    } finally {
        if (conn) conn.end();
    }
}

initializeDatabase();

================
File: backend/db/migrate_data.js
================
// Script to migrate data from the old database to the new one
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');

// Old database connection configuration
const oldDbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'root',
  password: 'Oswald1986!',
  database: 'rumfor1', // Correct old database name
  multipleStatements: true
};

// New database connection configuration
const newDbConfig = {
  host: '192.168.0.139',
  port: 3306,
  user: 'rumfornew2',
  password: 'Oswald1986!',
  database: 'rumfornew2',
  multipleStatements: true
};

// Helper function to execute a query and log the result
async function executeQuery(connection, query, params = []) {
  try {
    const [result] = await connection.execute(query, params);
    return result;
  } catch (error) {
    console.error(`Error executing query: ${query}`);
    console.error(error);
    throw error;
  }
}

// Migrate users
async function migrateUsers(oldConn, newConn) {
  console.log('Migrating users...');
  
  // Get all users from the old database
  const users = await executeQuery(oldConn, 'SELECT * FROM users');
  console.log(`Found ${users.length} users to migrate`);
  
  // Get user settings if the table exists
  let settingsMap = {};
  try {
    const userSettings = await executeQuery(oldConn, 'SELECT * FROM user_settings');
    userSettings.forEach(setting => {
      settingsMap[setting.user_id] = setting;
    });
    console.log(`Found ${userSettings.length} user settings to migrate`);
  } catch (error) {
    console.log('No user_settings table found, skipping');
  }
  
  // Get user statistics if the table exists
  let statsMap = {};
  try {
    const userStats = await executeQuery(oldConn, 'SELECT * FROM user_statistics');
    userStats.forEach(stat => {
      statsMap[stat.user_id] = stat;
    });
    console.log(`Found ${userStats.length} user statistics to migrate`);
  } catch (error) {
    console.log('No user_statistics table found, skipping');
  }
  
  // Migrate each user
  for (const user of users) {
    // Insert into user table
    await executeQuery(
      newConn,
      `INSERT INTO user (
        id, username, email, password_hash, role, bio, avatar_url,
        profile_banner_url, website, location, is_verified, status,
        cake_day, created_at, updated_at, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        user.id,
        user.username,
        user.email,
        user.password_hash,
        user.role || 'user',
        user.bio,
        user.avatar_url,
        user.profile_banner_url,
        user.website,
        user.location,
        user.is_verified ? 1 : 0,
        user.status || 'active',
        user.cake_day,
        user.created_at,
        user.updated_at,
        user.last_active
      ]
    );
    
    // Insert user statistics
    const stats = statsMap[user.id] || {};
    await executeQuery(
      newConn,
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count,
        upvotes_received, downvotes_received, upvotes_given, downvotes_given,
        communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())`,
      [
        user.id,
        stats.karma || user.karma || 0,
        stats.posts_count || user.post_count || 0,
        stats.comments_count || user.comment_count || 0,
        user.upvotes_received || 0,
        user.downvotes_received || 0,
        user.upvotes_given || 0,
        user.downvotes_given || 0,
        user.communities_joined || 0
      ]
    );
    
    // Insert user settings
    const settings = settingsMap[user.id] || {};
    await executeQuery(
      newConn,
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, theme,
        content_filter, allow_followers, display_online_status,
        language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
      [
        user.id,
        settings.email_notifications ? 1 : 0,
        settings.push_notifications ? 1 : 0,
        settings.theme || 'light',
        settings.content_filter || 'standard',
        settings.allow_followers ? 1 : 0,
        settings.display_online_status ? 1 : 0,
        settings.language || 'en',
        settings.timezone || 'UTC'
      ]
    );
  }
  
  console.log('Users migration completed');
}

// Migrate communities
async function migrateCommunities(oldConn, newConn) {
  console.log('Migrating communities...');
  
  // Get all communities from the old database
  try {
    const communities = await executeQuery(oldConn, 'SELECT * FROM communities');
    console.log(`Found ${communities.length} communities to migrate`);
    
    // Get community settings if the table exists
    let settingsMap = {};
    try {
      const communitySettings = await executeQuery(oldConn, 'SELECT * FROM community_settings');
      communitySettings.forEach(setting => {
        settingsMap[setting.community_id] = setting;
      });
      console.log(`Found ${communitySettings.length} community settings to migrate`);
    } catch (error) {
      console.log('No community_settings table found, skipping');
    }
    
    // Migrate each community
    for (const community of communities) {
      // Insert into community table
      await executeQuery(
        newConn,
        `INSERT INTO community (
          id, name, description, privacy, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?)`,
        [
          community.id,
          community.name,
          community.description,
          community.privacy || 'public',
          community.created_at,
          community.updated_at
        ]
      );
      
      // Insert community settings
      const settings = settingsMap[community.id] || {};
      await executeQuery(
        newConn,
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, join_method,
          require_post_approval, restricted_words, custom_theme_color,
          custom_banner_url, minimum_account_age_days, minimum_karma_required,
          updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,
        [
          community.id,
          settings.allow_post_images ? 1 : 0,
          settings.allow_post_links ? 1 : 0,
          settings.join_method || 'auto_approve',
          settings.require_post_approval ? 1 : 0,
          settings.restricted_words,
          settings.custom_theme_color,
          settings.custom_banner_url,
          settings.minimum_account_age_days || 0,
          settings.minimum_karma_required || 0
        ]
      );
    }
    
    console.log('Communities migration completed');
  } catch (error) {
    console.log('No communities table found, skipping');
  }
}

// Migrate community members
async function migrateCommunityMembers(oldConn, newConn) {
  console.log('Migrating community members...');
  
  try {
    // Get all community members from the old database
    const members = await executeQuery(oldConn, 'SELECT * FROM community_members');
    console.log(`Found ${members.length} community members to migrate`);
    
    // Migrate each member
    for (const member of members) {
      await executeQuery(
        newConn,
        `INSERT INTO community_member (
          community_id, user_id, role, joined_at
        ) VALUES (?, ?, ?, ?)`,
        [
          member.community_id,
          member.user_id,
          member.role || 'member',
          member.joined_at
        ]
      );
    }
    
    console.log('Community members migration completed');
  } catch (error) {
    console.log('No community_members table found, skipping');
  }
}

// Migrate community rules
async function migrateCommunityRules(oldConn, newConn) {
  console.log('Migrating community rules...');
  
  try {
    // Get all community rules from the old database
    const rules = await executeQuery(oldConn, 'SELECT * FROM community_rules');
    console.log(`Found ${rules.length} community rules to migrate`);
    
    // Migrate each rule
    for (const rule of rules) {
      await executeQuery(
        newConn,
        `INSERT INTO community_rule (
          id, community_id, title, description, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?)`,
        [
          rule.id,
          rule.community_id,
          rule.title,
          rule.description,
          rule.created_at,
          rule.updated_at
        ]
      );
    }
    
    console.log('Community rules migration completed');
  } catch (error) {
    console.log('No community_rules table found, skipping');
  }
}

// Migrate posts
async function migratePosts(oldConn, newConn) {
  console.log('Migrating posts...');
  
  try {
    // Get all posts from the old database
    const posts = await executeQuery(oldConn, 'SELECT * FROM posts');
    console.log(`Found ${posts.length} posts to migrate`);
    
    // Migrate each post
    for (const post of posts) {
      await executeQuery(
        newConn,
        `INSERT INTO post (
          id, title, content, user_id, community_id, profile_post,
          user_profile_id, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          post.id,
          post.title,
          post.content,
          post.user_id,
          post.community_id,
          post.profile_post ? 1 : 0,
          post.user_profile_id,
          post.created_at,
          post.updated_at
        ]
      );
    }
    
    console.log('Posts migration completed');
  } catch (error) {
    console.log('No posts table found, skipping');
  }
}

// Migrate comments
async function migrateComments(oldConn, newConn) {
  console.log('Migrating comments...');
  
  try {
    // Get all comments from the old database
    const comments = await executeQuery(oldConn, 'SELECT * FROM comments');
    console.log(`Found ${comments.length} comments to migrate`);
    
    // Migrate each comment
    for (const comment of comments) {
      await executeQuery(
        newConn,
        `INSERT INTO comment (
          id, content, user_id, post_id, parent_comment_id, created_at, updated_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          comment.id,
          comment.content,
          comment.user_id,
          comment.post_id,
          comment.parent_comment_id,
          comment.created_at,
          comment.updated_at
        ]
      );
    }
    
    console.log('Comments migration completed');
  } catch (error) {
    console.log('No comments table found, skipping');
  }
}

// Migrate votes
async function migrateVotes(oldConn, newConn) {
  console.log('Migrating votes...');
  
  // Get all post votes from the old database
  const postVotes = await executeQuery(oldConn, 'SELECT * FROM votes WHERE post_id IS NOT NULL');
  console.log(`Found ${postVotes.length} post votes to migrate`);
  
  // Migrate each post vote
  for (const vote of postVotes) {
    await executeQuery(
      newConn,
      `INSERT INTO vote (
        user_id, post_id, comment_id, value, created_at, updated_at
      ) VALUES (?, ?, NULL, ?, ?, ?)`,
      [
        vote.user_id,
        vote.post_id,
        vote.value,
        vote.created_at,
        vote.updated_at || vote.created_at
      ]
    );
  }
  
  // Get all comment votes from the old database
  const commentVotes = await executeQuery(oldConn, 'SELECT * FROM votes WHERE comment_id IS NOT NULL');
  console.log(`Found ${commentVotes.length} comment votes to migrate`);
  
  // Migrate each comment vote
  for (const vote of commentVotes) {
    await executeQuery(
      newConn,
      `INSERT INTO vote (
        user_id, post_id, comment_id, value, created_at, updated_at
      ) VALUES (?, NULL, ?, ?, ?, ?)`,
      [
        vote.user_id,
        vote.comment_id,
        vote.value,
        vote.created_at,
        vote.updated_at || vote.created_at
      ]
    );
  }
  
  console.log('Votes migration completed');
}

// Migrate moderator permissions
async function migrateModeratorPermissions(oldConn, newConn) {
  console.log('Migrating moderator permissions...');
  
  // Get all moderator permissions from the old database
  const permissions = await executeQuery(oldConn, 'SELECT * FROM moderator_permissions');
  console.log(`Found ${permissions.length} moderator permissions to migrate`);
  
  // Migrate each permission
  for (const permission of permissions) {
    await executeQuery(
      newConn,
      `INSERT INTO moderator_permission (
        community_id, user_id, can_manage_settings, can_manage_members,
        can_manage_posts, can_manage_comments, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        permission.community_id,
        permission.user_id,
        permission.can_manage_settings ? 1 : 0,
        permission.can_manage_members ? 1 : 0,
        permission.can_manage_posts ? 1 : 0,
        permission.can_manage_comments ? 1 : 0,
        permission.created_at,
        permission.updated_at
      ]
    );
  }
  
  console.log('Moderator permissions migration completed');
}

// Migrate banned users
async function migrateBannedUsers(oldConn, newConn) {
  console.log('Migrating banned users...');
  
  // Get all banned users from the old database
  const bannedUsers = await executeQuery(oldConn, 'SELECT * FROM banned_users');
  console.log(`Found ${bannedUsers.length} banned users to migrate`);
  
  // Migrate each banned user
  for (const banned of bannedUsers) {
    await executeQuery(
      newConn,
      `INSERT INTO banned_user (
        community_id, user_id, reason, banned_by, ban_expires_at, created_at
      ) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        banned.community_id,
        banned.user_id,
        banned.reason,
        banned.banned_by,
        banned.ban_expires_at,
        banned.created_at
      ]
    );
  }
  
  console.log('Banned users migration completed');
}

// Migrate saved items
async function migrateSavedItems(oldConn, newConn) {
  console.log('Migrating saved items...');
  
  // Get all saved items from the old database
  const savedItems = await executeQuery(oldConn, 'SELECT * FROM saved_items');
  console.log(`Found ${savedItems.length} saved items to migrate`);
  
  // Migrate each saved item
  for (const item of savedItems) {
    await executeQuery(
      newConn,
      `INSERT INTO saved_item (
        id, user_id, item_id, item_type, saved_at, collection_name
      ) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        item.id,
        item.user_id,
        item.item_id,
        item.item_type,
        item.saved_at,
        item.collection_name
      ]
    );
  }
  
  console.log('Saved items migration completed');
}

// Migrate user relationships (friends, follows, blocks)
async function migrateUserRelationships(oldConn, newConn) {
  console.log('Migrating user relationships...');
  
  // Migrate friends
  const friends = await executeQuery(oldConn, 'SELECT * FROM user_friends');
  console.log(`Found ${friends.length} friendships to migrate`);
  
  for (const friend of friends) {
    await executeQuery(
      newConn,
      `INSERT INTO user_relationship (
        id, user_id, related_user_id, relationship_type, status, created_at, updated_at
      ) VALUES (?, ?, ?, 'friend', ?, ?, ?)`,
      [
        uuidv4(),
        friend.user_id,
        friend.friend_id,
        friend.status,
        friend.created_at,
        friend.updated_at
      ]
    );
  }
  
  // Migrate followers if they exist
  try {
    const followers = await executeQuery(oldConn, 'SELECT * FROM user_followers');
    console.log(`Found ${followers.length} followers to migrate`);
    
    for (const follower of followers) {
      await executeQuery(
        newConn,
        `INSERT INTO user_relationship (
          id, user_id, related_user_id, relationship_type, status, created_at, updated_at
        ) VALUES (?, ?, ?, 'follow', 'accepted', ?, ?)`,
        [
          uuidv4(),
          follower.follower_id,
          follower.followed_id,
          follower.created_at,
          follower.created_at
        ]
      );
    }
  } catch (error) {
    console.log('No followers table found, skipping');
  }
  
  // Migrate blocks if they exist
  try {
    const blocks = await executeQuery(oldConn, 'SELECT * FROM user_blocked');
    console.log(`Found ${blocks.length} blocks to migrate`);
    
    for (const block of blocks) {
      await executeQuery(
        newConn,
        `INSERT INTO user_relationship (
          id, user_id, related_user_id, relationship_type, status, created_at, updated_at
        ) VALUES (?, ?, ?, 'block', 'accepted', ?, ?)`,
        [
          uuidv4(),
          block.blocker_id,
          block.blocked_id,
          block.created_at,
          block.created_at
        ]
      );
    }
  } catch (error) {
    console.log('No blocks table found, skipping');
  }
  
  console.log('User relationships migration completed');
}

// Migrate user achievements
async function migrateUserAchievements(oldConn, newConn) {
  console.log('Migrating user achievements...');
  
  // Get all user achievements from the old database
  const achievements = await executeQuery(oldConn, 'SELECT * FROM user_achievements');
  console.log(`Found ${achievements.length} user achievements to migrate`);
  
  // Migrate each achievement
  for (const achievement of achievements) {
    await executeQuery(
      newConn,
      `INSERT INTO user_achievement (
        id, user_id, achievement_type, achievement_name, description, earned_at
      ) VALUES (?, ?, ?, ?, ?, ?)`,
      [
        achievement.id,
        achievement.user_id,
        achievement.achievement_type,
        achievement.achievement_name,
        achievement.description,
        achievement.earned_at
      ]
    );
  }
  
  console.log('User achievements migration completed');
}

// Migrate user flairs
async function migrateUserFlairs(oldConn, newConn) {
  console.log('Migrating user flairs...');
  
  // Get all user flairs from the old database
  const flairs = await executeQuery(oldConn, 'SELECT * FROM user_flair');
  console.log(`Found ${flairs.length} user flairs to migrate`);
  
  // Migrate each flair
  for (const flair of flairs) {
    await executeQuery(
      newConn,
      `INSERT INTO user_flair (
        id, user_id, community_id, text, background_color, text_color, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        flair.id,
        flair.user_id,
        flair.community_id,
        flair.text,
        flair.background_color,
        flair.text_color,
        flair.created_at,
        flair.updated_at
      ]
    );
  }
  
  console.log('User flairs migration completed');
}

// Main migration function
async function migrateData() {
  let oldConn, newConn;
  
  try {
    // Connect to both databases
    oldConn = await mysql.createConnection(oldDbConfig);
    newConn = await mysql.createConnection(newDbConfig);
    
    console.log('Connected to both databases');
    
    // Disable foreign key checks during migration
    await executeQuery(newConn, 'SET FOREIGN_KEY_CHECKS = 0');
    
    // Perform migrations in the correct order to maintain relationships
    await migrateUsers(oldConn, newConn);
    await migrateCommunities(oldConn, newConn);
    await migrateCommunityMembers(oldConn, newConn);
    await migrateCommunityRules(oldConn, newConn);
    await migratePosts(oldConn, newConn);
    await migrateComments(oldConn, newConn);
    await migrateVotes(oldConn, newConn);
    await migrateModeratorPermissions(oldConn, newConn);
    await migrateBannedUsers(oldConn, newConn);
    await migrateSavedItems(oldConn, newConn);
    await migrateUserRelationships(oldConn, newConn);
    await migrateUserAchievements(oldConn, newConn);
    await migrateUserFlairs(oldConn, newConn);
    
    // Re-enable foreign key checks
    await executeQuery(newConn, 'SET FOREIGN_KEY_CHECKS = 1');
    
    console.log('Migration completed successfully!');
  } catch (error) {
    console.error('Error during migration:', error);
  } finally {
    // Close connections
    if (oldConn) await oldConn.end();
    if (newConn) await newConn.end();
  }
}

// Run the migration
migrateData();

================
File: backend/db/migrate_database.bat
================
@echo off
echo ===================================================
echo Database Migration Utility for Windows
echo ===================================================
echo.

:menu
echo Choose an option:
echo 1. Create new database and apply schema
echo 2. Migrate data from old database to new database
echo 3. Generate sample data for new database
echo 4. Add admin user to new database
echo 5. Switch application to use new database
echo 6. Switch application to use old database
echo 7. Restore original .env file
echo 8. Run complete migration with existing data (steps 1-2-5)
echo 9. Run complete migration with sample data (steps 1-3-5)
echo 10. Run complete migration with sample data and admin user (steps 1-3-4-5)
echo 11. Exit
echo.

set /p choice="Enter your choice (1-11): "

if "%choice%"=="1" goto create_db
if "%choice%"=="2" goto migrate_data
if "%choice%"=="3" goto generate_data
if "%choice%"=="4" goto add_admin
if "%choice%"=="5" goto use_new_db
if "%choice%"=="6" goto use_old_db
if "%choice%"=="7" goto restore_env
if "%choice%"=="8" goto complete_migration_existing
if "%choice%"=="9" goto complete_migration_sample
if "%choice%"=="10" goto complete_migration_sample_admin
if "%choice%"=="11" goto end
goto invalid_choice

:create_db
echo.
echo Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
pause
goto menu

:migrate_data
echo.
echo Migrating data from old database to new database...
cd %~dp0
node migrate_data.js
echo.
pause
goto menu

:use_new_db
echo.
echo Switching application to use new database...
cd %~dp0
node update_connection.js
echo.
pause
goto menu

:use_old_db
echo.
echo Switching application to use old database...
cd %~dp0
node update_connection.js --old
echo.
pause
goto menu

:restore_env
echo.
echo Restoring original .env file...
cd %~dp0
node update_connection.js --restore
echo.
pause
goto menu

:generate_data
echo.
echo Generating sample data for new database...
cd %~dp0
node generate_sample_data.js
echo.
pause
goto menu

:add_admin
echo.
echo Adding admin user to new database...
cd %~dp0
node add_admin_user.js
echo.
pause
goto menu

:complete_migration_existing
echo.
echo Running complete migration process with existing data...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Migrating data from old database to new database...
node migrate_data.js
echo.
echo Step 3: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:complete_migration_sample
echo.
echo Running complete migration process with sample data...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Generating sample data for new database...
node generate_sample_data.js
echo.
echo Step 3: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:complete_migration_sample_admin
echo.
echo Running complete migration process with sample data and admin user...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Generating sample data for new database...
node generate_sample_data.js
echo.
echo Step 3: Adding admin user to new database...
node add_admin_user.js
echo.
echo Step 4: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:invalid_choice
echo.
echo Invalid choice. Please try again.
echo.
pause
goto menu

:end
echo.
echo Exiting Database Migration Utility.
echo.

================
File: backend/db/moderator_schema_updates.sql
================
-- Enhance community_settings table with additional moderation settings
ALTER TABLE community_settings 
ADD COLUMN IF NOT EXISTS require_post_approval BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS restricted_words TEXT,
ADD COLUMN IF NOT EXISTS custom_theme_color VARCHAR(20),
ADD COLUMN IF NOT EXISTS custom_banner_url TEXT,
ADD COLUMN IF NOT EXISTS minimum_account_age_days INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS minimum_karma_required INT DEFAULT 0;

-- Create moderator_permissions table for granular control
CREATE TABLE IF NOT EXISTS moderator_permissions (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create post_moderation table for post approval workflow
CREATE TABLE IF NOT EXISTS post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (moderator_id) REFERENCES users(id)
);

-- Create moderation_logs table for tracking all moderator actions
CREATE TABLE IF NOT EXISTS moderation_logs (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (moderator_id) REFERENCES users(id)
);

-- Create banned_users table for community-specific bans
CREATE TABLE IF NOT EXISTS banned_users (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (banned_by) REFERENCES users(id)
);

================
File: backend/db/new_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL, -- 'home', 'work', etc.
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User relationships
CREATE TABLE user_relationship (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    related_user_id VARCHAR(36) NOT NULL,
    relationship_type VARCHAR(20) NOT NULL, -- 'friend', 'follow', 'block'
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (related_user_id) REFERENCES user(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, related_user_id, relationship_type)
);

-- User achievements
CREATE TABLE user_achievement (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community join requests
CREATE TABLE community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User flair for communities
CREATE TABLE user_flair (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    text VARCHAR(50) NOT NULL,
    background_color VARCHAR(20) DEFAULT '#e0e0e0',
    text_color VARCHAR(20) DEFAULT '#000000',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, community_id)
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Vote table with support for both post and comment votes
CREATE TABLE vote (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, COALESCE(post_id, ''), COALESCE(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE,
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Saved items
CREATE TABLE saved_item (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    item_id VARCHAR(36) NOT NULL,
    item_type VARCHAR(20) NOT NULL, -- 'post', 'comment'
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    collection_name VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post moderation
CREATE TABLE post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE SET NULL
);

-- Banned users
CREATE TABLE banned_user (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (banned_by) REFERENCES user(id) ON DELETE CASCADE
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, community, etc.)
    entity_type VARCHAR(50), -- Type of the related entity (post, comment, community, etc.)
    metadata JSON, -- Additional data related to the activity
    ip_address VARCHAR(45), -- IPv4 or IPv6 address
    user_agent TEXT, -- Browser/client information
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Moderation logs
CREATE TABLE moderation_log (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Create indexes for faster queries
CREATE INDEX idx_post_user_id ON post(user_id);
CREATE INDEX idx_post_community_id ON post(community_id);
CREATE INDEX idx_comment_post_id ON comment(post_id);
CREATE INDEX idx_comment_user_id ON comment(user_id);
CREATE INDEX idx_comment_parent_id ON comment(parent_comment_id);
CREATE INDEX idx_vote_post_id ON vote(post_id);
CREATE INDEX idx_vote_comment_id ON vote(comment_id);
CREATE INDEX idx_activity_user_id ON activity(user_id);
CREATE INDEX idx_activity_type_id ON activity(activity_type_id);
CREATE INDEX idx_activity_action_id ON activity(action_id);
CREATE INDEX idx_activity_entity ON activity(entity_id, entity_type);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

-- Create triggers to automatically update user statistics

-- Update posts_count when a post is created
DELIMITER //
CREATE TRIGGER after_post_insert
AFTER INSERT ON post
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        posts_count = posts_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'POST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        NEW.id,
        'post',
        JSON_OBJECT(
            'title', NEW.title,
            'community_id', NEW.community_id
        )
    );
END //
DELIMITER ;

-- Update posts_count when a post is deleted
DELIMITER //
CREATE TRIGGER after_post_delete
AFTER DELETE ON post
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        posts_count = GREATEST(0, posts_count - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'POST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        OLD.id,
        'post'
    );
END //
DELIMITER ;

-- Update comments_count when a comment is created
DELIMITER //
CREATE TRIGGER after_comment_insert
AFTER INSERT ON comment
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        comments_count = comments_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMENT'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        NEW.id,
        'comment',
        JSON_OBJECT(
            'post_id', NEW.post_id,
            'parent_comment_id', NEW.parent_comment_id
        )
    );
END //
DELIMITER ;

-- Update comments_count when a comment is deleted
DELIMITER //
CREATE TRIGGER after_comment_delete
AFTER DELETE ON comment
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        comments_count = GREATEST(0, comments_count - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMENT'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        OLD.id,
        'comment'
    );
END //
DELIMITER ;

-- Update upvotes/downvotes when a vote is created or updated
DELIMITER //
CREATE TRIGGER after_vote_insert_update
AFTER INSERT ON vote
FOR EACH ROW
BEGIN
    DECLARE content_author_id VARCHAR(36);
    DECLARE content_type VARCHAR(20);
    
    -- Determine the content type and get the author
    IF NEW.post_id IS NOT NULL THEN
        SELECT user_id INTO content_author_id FROM post WHERE id = NEW.post_id;
        SET content_type = 'post';
    ELSE
        SELECT user_id INTO content_author_id FROM comment WHERE id = NEW.comment_id;
        SET content_type = 'comment';
    END IF;
    
    -- Update the voter's stats
    IF NEW.value = 1 THEN
        UPDATE user_statistic SET 
            upvotes_given = upvotes_given + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.user_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE user_statistic SET 
            downvotes_given = downvotes_given + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.user_id;
    END IF;
    
    -- Update the content author's stats
    IF NEW.value = 1 THEN
        UPDATE user_statistic SET 
            upvotes_received = upvotes_received + 1,
            karma = karma + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = content_author_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE user_statistic SET 
            downvotes_received = downvotes_received + 1,
            karma = GREATEST(0, karma - 1),
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = content_author_id;
    END IF;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'VOTE'),
        (SELECT id FROM action WHERE name = IF(NEW.value = 1, 'UPVOTE', 'DOWNVOTE')),
        IF(NEW.post_id IS NOT NULL, NEW.post_id, NEW.comment_id),
        content_type
    );
END //
DELIMITER ;

-- Update communities_joined when a user joins a community
DELIMITER //
CREATE TRIGGER after_community_member_insert
AFTER INSERT ON community_member
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        communities_joined = communities_joined + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        NEW.community_id,
        'community',
        JSON_OBJECT('role', NEW.role)
    );
END //
DELIMITER ;

-- Update communities_joined when a user leaves a community
DELIMITER //
CREATE TRIGGER after_community_member_delete
AFTER DELETE ON community_member
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        communities_joined = GREATEST(0, communities_joined - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        OLD.community_id,
        'community'
    );
END //
DELIMITER ;

-- Log moderation actions
DELIMITER //
CREATE TRIGGER after_moderation_log_insert
AFTER INSERT ON moderation_log
FOR EACH ROW
BEGIN
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.moderator_id,
        (SELECT id FROM activity_type WHERE name = 'MODERATION'),
        (SELECT id FROM action WHERE name = 'MODERATE'),
        NEW.target_id,
        NEW.target_type,
        JSON_OBJECT(
            'action_type', NEW.action_type,
            'community_id', NEW.community_id,
            'reason', NEW.reason
        )
    );
END //
DELIMITER ;

================
File: backend/db/README_DATABASE_REFACTORING.md
================
# Database Refactoring Guide

This guide explains the database refactoring process and how to use the scripts provided to migrate from the old database structure to the new one.

## Overview

The database refactoring addresses several issues with the current database:

1. **Data Duplication**: Eliminated duplicate data across tables
2. **Missing Activity Tracking**: Added comprehensive activity tracking system
3. **Inconsistent Naming Conventions**: Standardized naming conventions
4. **Missing Personal Information**: Added support for more user information

## New Database Structure

The new database structure includes:

- Improved user tables with support for personal information and addresses
- Consolidated user statistics in a single table
- Comprehensive activity tracking system
- Standardized naming conventions
- Better relationship handling

## Scripts

The following scripts are provided to help with the migration:

### 1. `new_schema.sql`

This file contains the complete SQL schema for the new database. It defines all tables, indexes, triggers, and default data.

### 2. `apply_new_schema.js`

This script creates the new database and applies the schema. It:

- Creates the `rumfornew2` database if it doesn't exist
- Creates the `rumfornew2` user with the password `Oswald1986!`
- Grants necessary privileges
- Applies the schema from `new_schema.sql`

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\apply_new_schema.js
```

For Bash/Linux:
```bash
node backend/db/apply_new_schema.js
```

### 3. `migrate_data.js`

This script migrates data from the old database to the new one. It:

- Connects to both the old and new databases
- Reads data from the old database tables
- Transforms the data to fit the new schema
- Inserts the transformed data into the new database tables

### 3a. `generate_sample_data.js`

This script generates sample data for the new database. It:

- Connects to the new database
- Generates sample users, communities, posts, comments, and activities
- Inserts the sample data into the new database tables

This script is useful when you don't have an existing database to migrate from, or when you want to test the new database with sample data.

### 3b. `add_admin_user.js`

This script adds an admin user to the new database. It:

- Connects to the new database
- Creates an admin user with username 'admin' and password 'Oswald1986!'
- Sets up the necessary user statistics and settings for the admin user

This script is useful for quickly setting up an admin account to access the system.

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\add_admin_user.js
```

For Bash/Linux:
```bash
node backend/db/add_admin_user.js
```

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\migrate_data.js
```

For Bash/Linux:
```bash
node backend/db/migrate_data.js
```

### 4. `update_connection.js`

This script updates the application's database connection to use either the old or new database. It:

- Creates a backup of the original `.env` file
- Updates the database connection parameters in the `.env` file
- Provides options to switch between the old and new databases

Usage:

For Windows PowerShell:
```powershell
# Switch to the new database (default)
node .\backend\db\update_connection.js

# Switch to the old database
node .\backend\db\update_connection.js --old

# Restore the original .env file
node .\backend\db\update_connection.js --restore

# Show help
node .\backend\db\update_connection.js --help
```

For Bash/Linux:
```bash
# Switch to the new database (default)
node backend/db/update_connection.js

# Switch to the old database
node backend/db/update_connection.js --old

# Restore the original .env file
node backend/db/update_connection.js --restore

# Show help
node backend/db/update_connection.js --help
```

## Migration Process

Follow these steps to migrate to the new database:

1. **Backup your data**: Ensure you have a backup of your current database before proceeding.

2. **Create the new database and apply the schema**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\apply_new_schema.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/apply_new_schema.js
   ```

3. **Migrate the data from the old database to the new one**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\migrate_data.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/migrate_data.js
   ```

4. **Update the application to use the new database**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\update_connection.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/update_connection.js
   ```

5. **Test the application with the new database**:
   Start your application and verify that everything works as expected.

6. **If needed, switch back to the old database**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\update_connection.js --old
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/update_connection.js --old
   ```

## Key Improvements

### 1. User Data Structure

- Added support for first name, last name, date of birth, and secondary email
- Added support for user addresses
- Consolidated user statistics in a single table

### 2. Activity Tracking

- Added activity types and actions tables
- Added comprehensive activity tracking
- Automatic activity logging through triggers

### 3. Naming Conventions

- Standardized table names to singular form
- Consistent field naming across related tables
- Consistent use of snake_case for all field names

### 4. Relationships

- Improved handling of user relationships (friends, follows, blocks)
- Better community membership and moderation tracking
- Enhanced post and comment relationships

## Database Diagram

The new database structure follows this general organization:

```
User-related tables:
  - user
  - user_address
  - user_statistic
  - user_setting
  - user_relationship
  - user_achievement
  - user_flair

Community-related tables:
  - community
  - community_member
  - community_rule
  - community_setting
  - community_join_request
  - moderator_permission
  - banned_user

Content-related tables:
  - post
  - comment
  - vote
  - saved_item
  - post_moderation

Activity tracking:
  - activity_type
  - action
  - activity
  - moderation_log
```

## Troubleshooting

If you encounter issues during the migration process:

1. **Database connection errors**: Verify the connection parameters in the scripts match your environment.

2. **Permission issues**: Ensure the database user has the necessary privileges.

3. **Schema errors**: Check the MySQL error logs for details about any schema errors.

4. **Data migration errors**: The migration script will log errors for specific tables. You can modify the script to skip problematic tables or fix the data issues.

5. **Application errors**: If the application doesn't work with the new database, you can switch back to the old one using `update_connection.js --old` while you troubleshoot.

## Windows-Specific Notes

### Batch File for Windows Users

For Windows users, we've provided a batch file that makes it easier to run the migration scripts. You can run the batch file by double-clicking on it or by running it from PowerShell/Command Prompt:

```powershell
# From the project root
.\backend\db\migrate_database.bat

# Or navigate to the backend/db directory first
cd .\backend\db
.\migrate_database.bat
```

This will display a menu with options to:
1. Create new database and apply schema
2. Migrate data from old database to new database
3. Generate sample data for new database
4. Switch application to use new database
5. Switch application to use old database
6. Restore original .env file
7. Run complete migration with existing data (steps 1-2-4)
8. Run complete migration with sample data (steps 1-3-4)
9. Exit

Simply choose the option you want by entering the corresponding number.

### Additional Windows Notes

When running these scripts on Windows:

1. Make sure you're using the correct path separator (`\` instead of `/`) when running commands in PowerShell or Command Prompt.

2. If you encounter permission issues, you might need to run PowerShell as Administrator.

3. If you have issues with MySQL connections, ensure that the MySQL service is running:
   ```powershell
   # Check MySQL service status
   Get-Service MySQL*
   
   # Start MySQL service if it's not running
   Start-Service MySQL*
   ```

4. For database root access, you might need to specify the password in the scripts if your MySQL installation requires it.

================
File: backend/db/schema.sql
================
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS communities (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS posts (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

CREATE TABLE IF NOT EXISTS comments (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id)
);

CREATE TABLE IF NOT EXISTS votes (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, post_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id)
);

================
File: backend/db/seed_communities.js
================
// Seed script to create sample communities and related data
const mariadb = require('mariadb');
const dotenv = require('dotenv');
const { v4: uuidv4 } = require('uuid');
const path = require('path');

// Load environment variables
dotenv.config({ path: path.resolve(__dirname, '../.env') });

// Create a connection pool
const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

async function seedCommunities() {
  let conn;

  try {
    conn = await pool.getConnection();
    
    // Sample communities data
    const communities = [
      {
        id: uuidv4(),
        name: 'technology',
        description: 'Discussion about the latest in technology, gadgets, and software.',
        privacy: 'public'
      },
      {
        id: uuidv4(),
        name: 'programming',
        description: 'Share tips, ask questions, and discuss all aspects of programming.',
        privacy: 'public'
      },
      {
        id: uuidv4(),
        name: 'fitness',
        description: 'A community for fitness enthusiasts to share advice and progress.',
        privacy: 'public'
      }
    ];
    
    // Create the communities
    for (const community of communities) {
      try {
        // Check if the community already exists
        const [existingCommunity] = await conn.query('SELECT * FROM communities WHERE name = ?', [community.name]);
        
        if (!existingCommunity) {
          // Insert the community
          await conn.query(
            'INSERT INTO communities (id, name, description, privacy) VALUES (?, ?, ?, ?)',
            [community.id, community.name, community.description, community.privacy]
          );
          
          // Add default settings
          await conn.query(
            'INSERT INTO community_settings (community_id, allow_post_images, allow_post_links) VALUES (?, ?, ?)',
            [community.id, true, true]
          );
          
          console.log(`Created community: ${community.name}`);
          
          // Create sample rules for each community
          const rules = [
            {
              id: uuidv4(),
              title: 'Be respectful',
              description: 'Treat others with respect. No personal attacks or harassment.'
            },
            {
              id: uuidv4(),
              title: 'No spam',
              description: 'Don\'t spam posts or comments.'
            },
            {
              id: uuidv4(),
              title: 'Stay on topic',
              description: 'Posts should be relevant to the community topic.'
            }
          ];
          
          for (const rule of rules) {
            await conn.query(
              'INSERT INTO community_rules (id, community_id, title, description) VALUES (?, ?, ?, ?)',
              [rule.id, community.id, rule.title, rule.description]
            );
          }
          
          console.log(`Added rules for community: ${community.name}`);
          
          // Get a sample user to be moderator (if users table exists and has data)
          try {
            const users = await conn.query('SELECT id FROM users LIMIT 1');
            
            if (users && users.length > 0) {
              const userId = users[0].id;
              
              // Add the user as a moderator
              await conn.query(
                'INSERT INTO community_members (community_id, user_id, role) VALUES (?, ?, ?)',
                [community.id, userId, 'moderator']
              );
              
              console.log(`Added moderator for community: ${community.name}`);
            }
          } catch (error) {
            console.log(`No users available to add as moderators for ${community.name}`);
          }
        } else {
          console.log(`Community ${community.name} already exists`);
        }
      } catch (error) {
        console.error(`Error creating community ${community.name}:`, error);
      }
    }
    
    console.log('Seeding completed');
  } catch (error) {
    console.error('Error seeding communities:', error);
  } finally {
    if (conn) conn.release();
  }
}

seedCommunities()
  .then(() => console.log('Seed script completed'))
  .catch(err => console.error('Seed script failed:', err))
  .finally(() => process.exit());

================
File: backend/db/simple_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL,
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve',
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE,
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36),
    entity_type VARCHAR(50),
    metadata JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

================
File: backend/db/update_auth_files.js
================
// Script to update the auth-related files without modifying the database schema
const fs = require('fs');
const path = require('path');

async function updateAuthFiles() {
  console.log('Updating auth-related files...');
  
  try {
    // 1. Create backup of original files
    console.log('Creating backups of original files...');
    
    const filesToBackup = [
      { src: '../api/auth.js', dest: '../api/auth.js.bak' },
      { src: '../api/auth.ts', dest: '../api/auth.ts.bak' },
      { src: '../routes/auth.js', dest: '../routes/auth.js.bak' }
    ];
    
    for (const file of filesToBackup) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Backed up ${file.src} to ${file.dest}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping backup`);
      }
    }
    
    // 2. Replace the auth files with the new versions
    console.log('Replacing auth files with new versions...');
    
    const filesToReplace = [
      { src: '../api/auth.js.new', dest: '../api/auth.js' },
      { src: '../api/auth.ts.new', dest: '../api/auth.ts' },
      { src: '../routes/auth.js.new', dest: '../routes/auth.js' }
    ];
    
    for (const file of filesToReplace) {
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Replaced ${file.dest} with ${file.src}`);
      } else {
        console.log(`Warning: ${file.src} does not exist, skipping replacement`);
      }
    }
    
    console.log('Auth files updated successfully!');
    
  } catch (error) {
    console.error('Error updating auth files:', error);
    process.exit(1);
  }
}

// Run the function
updateAuthFiles().then(() => {
  console.log('Auth files update completed');
  process.exit(0);
}).catch(error => {
  console.error('Auth files update failed:', error);
  process.exit(1);
});

================
File: backend/db/update_connection.js
================
// Script to update the database connection to use the new database
const fs = require('fs');
const path = require('path');

// Function to update the .env file
function updateEnvFile(useNewDb = true) {
  const envPath = path.join(__dirname, '..', '.env');
  
  // Read the current .env file
  let envContent = '';
  try {
    envContent = fs.readFileSync(envPath, 'utf8');
  } catch (error) {
    console.error('Error reading .env file:', error);
    return false;
  }
  
  // Define the old and new database configurations
  const oldDbConfig = {
    DB_HOST: '192.168.0.139',
    DB_PORT: '3306',
    DB_USER: 'root', // Replace with your actual user
    DB_PASSWORD: '', // Replace with your actual password
    DB_NAME: 'rumfor' // Replace with your actual database name
  };
  
  const newDbConfig = {
    DB_HOST: '192.168.0.139',
    DB_PORT: '3306',
    DB_USER: 'rumfornew2',
    DB_PASSWORD: 'Oswald1986!',
    DB_NAME: 'rumfornew2'
  };
  
  // Choose which configuration to use
  const dbConfig = useNewDb ? newDbConfig : oldDbConfig;
  
  // Update the .env content
  let updatedContent = envContent;
  
  // Update or add each database configuration variable
  for (const [key, value] of Object.entries(dbConfig)) {
    const regex = new RegExp(`^${key}=.*$`, 'm');
    
    if (updatedContent.match(regex)) {
      // Update existing variable
      updatedContent = updatedContent.replace(regex, `${key}=${value}`);
    } else {
      // Add new variable
      updatedContent += `\n${key}=${value}`;
    }
  }
  
  // Write the updated content back to the .env file
  try {
    fs.writeFileSync(envPath, updatedContent);
    console.log(`Successfully updated .env file to use ${useNewDb ? 'new' : 'old'} database`);
    return true;
  } catch (error) {
    console.error('Error writing .env file:', error);
    return false;
  }
}

// Create a backup of the original .env file
function backupEnvFile() {
  const envPath = path.join(__dirname, '..', '.env');
  const backupPath = path.join(__dirname, '..', '.env.backup');
  
  try {
    // Check if a backup already exists
    if (!fs.existsSync(backupPath)) {
      // Create a backup
      fs.copyFileSync(envPath, backupPath);
      console.log('Created backup of .env file at .env.backup');
    } else {
      console.log('Backup of .env file already exists at .env.backup');
    }
    return true;
  } catch (error) {
    console.error('Error creating backup of .env file:', error);
    return false;
  }
}

// Restore the original .env file from backup
function restoreEnvFile() {
  const envPath = path.join(__dirname, '..', '.env');
  const backupPath = path.join(__dirname, '..', '.env.backup');
  
  try {
    // Check if a backup exists
    if (fs.existsSync(backupPath)) {
      // Restore from backup
      fs.copyFileSync(backupPath, envPath);
      console.log('Restored .env file from backup');
      return true;
    } else {
      console.error('No backup of .env file found at .env.backup');
      return false;
    }
  } catch (error) {
    console.error('Error restoring .env file from backup:', error);
    return false;
  }
}

// Parse command line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    // Default to using the new database
    return { useNewDb: true, backup: true };
  }
  
  const options = {
    useNewDb: true,
    backup: true
  };
  
  for (const arg of args) {
    if (arg === '--old') {
      options.useNewDb = false;
    } else if (arg === '--new') {
      options.useNewDb = true;
    } else if (arg === '--no-backup') {
      options.backup = false;
    } else if (arg === '--restore') {
      options.restore = true;
    } else if (arg === '--help') {
      console.log(`
Usage: node update_connection.js [options]

Options:
  --new          Use the new database (default)
  --old          Use the old database
  --no-backup    Don't create a backup of the .env file
  --restore      Restore the .env file from backup
  --help         Show this help message
      `);
      process.exit(0);
    }
  }
  
  return options;
}

// Main function
function main() {
  const options = parseArgs();
  
  if (options.restore) {
    // Restore the .env file from backup
    if (restoreEnvFile()) {
      console.log('Successfully restored .env file from backup');
    } else {
      console.error('Failed to restore .env file from backup');
      process.exit(1);
    }
    return;
  }
  
  if (options.backup) {
    // Create a backup of the .env file
    if (!backupEnvFile()) {
      console.error('Failed to create backup of .env file');
      process.exit(1);
    }
  }
  
  // Update the .env file
  if (updateEnvFile(options.useNewDb)) {
    console.log(`Successfully updated .env file to use ${options.useNewDb ? 'new' : 'old'} database`);
  } else {
    console.error(`Failed to update .env file to use ${options.useNewDb ? 'new' : 'old'} database`);
    process.exit(1);
  }
}

// Run the main function
main();

================
File: backend/db/user_auth_schema.sql
================
-- Add role column to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS role VARCHAR(20) DEFAULT 'user';

-- Ensure community_members table has role column
ALTER TABLE community_members ADD COLUMN IF NOT EXISTS role VARCHAR(20) DEFAULT 'member';

-- Create initial admin user (will be executed via a separate script)
-- INSERT INTO users (id, username, email, password_hash, role) 
-- VALUES ('admin-uuid', 'admin', 'admin@example.com', 'hashed-password', 'admin');

================
File: backend/db/user_statistics_schema.sql
================
-- Add user statistics columns to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS bio TEXT DEFAULT NULL;
ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(255) DEFAULT NULL;
ALTER TABLE users ADD COLUMN IF NOT EXISTS post_count INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS comment_count INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS upvotes_received INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS downvotes_received INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS upvotes_given INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS downvotes_given INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS communities_joined INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Create user_friends table for tracking friendships
CREATE TABLE IF NOT EXISTS user_friends (
    user_id VARCHAR(36) NOT NULL,
    friend_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, friend_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (friend_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create user_achievements table for tracking achievements and badges
CREATE TABLE IF NOT EXISTS user_achievements (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create user_activity_log for tracking user activity (optional, for analytics)
CREATE TABLE IF NOT EXISTS user_activity_log (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, etc.)
    entity_type VARCHAR(50), -- Type of the related entity
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create triggers to automatically update user statistics

-- Update post_count when a post is created
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_post_insert
AFTER INSERT ON posts
FOR EACH ROW
BEGIN
    UPDATE users SET post_count = post_count + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update post_count when a post is deleted
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_post_delete
AFTER DELETE ON posts
FOR EACH ROW
BEGIN
    UPDATE users SET post_count = GREATEST(0, post_count - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

-- Update comment_count when a comment is created
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_comment_insert
AFTER INSERT ON comments
FOR EACH ROW
BEGIN
    UPDATE users SET comment_count = comment_count + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update comment_count when a comment is deleted
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_comment_delete
AFTER DELETE ON comments
FOR EACH ROW
BEGIN
    UPDATE users SET comment_count = GREATEST(0, comment_count - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

-- Update upvotes/downvotes when a vote is created or updated
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_vote_insert_update
AFTER INSERT ON votes
FOR EACH ROW
BEGIN
    DECLARE post_author_id VARCHAR(36);
    
    -- Get the post author
    SELECT user_id INTO post_author_id FROM posts WHERE id = NEW.post_id;
    
    -- Update the voter's stats
    IF NEW.value = 1 THEN
        UPDATE users SET upvotes_given = upvotes_given + 1, last_active = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE users SET downvotes_given = downvotes_given + 1, last_active = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    END IF;
    
    -- Update the post author's stats
    IF NEW.value = 1 THEN
        UPDATE users SET upvotes_received = upvotes_received + 1
        WHERE id = post_author_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE users SET downvotes_received = downvotes_received + 1
        WHERE id = post_author_id;
    END IF;
END //
DELIMITER ;

-- Update communities_joined when a user joins a community
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_community_member_insert
AFTER INSERT ON community_members
FOR EACH ROW
BEGIN
    UPDATE users SET communities_joined = communities_joined + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update communities_joined when a user leaves a community
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_community_member_delete
AFTER DELETE ON community_members
FOR EACH ROW
BEGIN
    UPDATE users SET communities_joined = GREATEST(0, communities_joined - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

================
File: backend/db/votes_schema_update.sql
================
-- Rename the old votes table
RENAME TABLE votes TO votes_old;

-- Create the new votes table with support for both post and comment votes
CREATE TABLE votes (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, COALESCE(post_id, ''), COALESCE(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (comment_id) REFERENCES comments(id),
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Migrate data from the old votes table
INSERT INTO votes (user_id, post_id, comment_id, value, created_at)
SELECT user_id, post_id, NULL, value, created_at FROM votes_old;

-- Drop the old votes table
DROP TABLE votes_old;

================
File: backend/fix_moderator_usernames.js
================
// Script to ensure moderators have usernames
const mariadb = require('mariadb');

// Create a connection pool with hardcoded values
const pool = mariadb.createPool({
  host: '192.168.0.139',
  port: 3306,
  user: 'root',
  password: 'Oswald1986!',
  database: 'rumfor1',
  connectionLimit: 15
});

async function fixModeratorUsernames() {
  let conn;

  try {
    conn = await pool.getConnection();

    // First check if the users table exists
    try {
      await conn.query('SELECT 1 FROM users LIMIT 1');
      console.log(' Users table exists');
    } catch (error) {
      console.error(' Users table does not exist or cannot be accessed');
      return;
    }

    // Now check if the community_members table exists
    try {
      await conn.query('SELECT 1 FROM community_members LIMIT 1');
      console.log(' Community_members table exists');
    } catch (error) {
      console.error(' Community_members table does not exist or cannot be accessed');
      return;
    }

    // Try to get all members with roles
    try {
      const members = await conn.query(`
        SELECT cm.*, u.username 
        FROM community_members cm 
        LEFT JOIN users u ON cm.user_id = u.id
        WHERE cm.role IN ('moderator', 'admin')
        LIMIT 20
      `);

      console.log(`Found ${members.length} moderators/admins`);

      if (members.length > 0) {
        console.log('\nSample moderator data:');
        members.forEach((mod, i) => {
          console.log(`[${i+1}] User ID: ${mod.user_id}, Username: ${mod.username || 'NULL'}, Role: ${mod.role}`);
        });

        // Check if any moderators are missing usernames
        const missingUsernames = members.filter(m => !m.username);
        if (missingUsernames.length > 0) {
          console.log(`\n ${missingUsernames.length} moderators are missing usernames`);
        } else {
          console.log('\n All moderators have usernames');
        }
      }
    } catch (error) {
      console.error(' Failed to query moderators:', error.message);
    }

    // Check direct join usage to verify it works
    try {
      const testQuery = `
        SELECT cm.community_id, cm.user_id, cm.role, u.username
        FROM community_members cm
        JOIN users u ON cm.user_id = u.id
        WHERE cm.role IN ('moderator', 'admin')
        LIMIT 5
      `;

      const testResult = await conn.query(testQuery);
      console.log('\nTest JOIN query result:');
      console.log(testResult);

      if (testResult.length > 0) {
        console.log('\n JOIN works correctly and returns usernames');
      } else {
        console.log('\n JOIN works but found no results');
      }
    } catch (error) {
      console.error('\n JOIN query failed:', error.message);
    }
  } catch (error) {
    console.error('Error:', error);
  } finally {
    if (conn) conn.release();
  }
}

// Run the script
fixModeratorUsernames()
  .then(() => console.log('\nScript completed'))
  .catch(err => console.error('\nScript failed:', err))
  .finally(() => process.exit());

================
File: backend/fix-table-names.js
================
const fs = require('fs');
const path = require('path');

// Read the index.ts file
const indexPath = path.join(__dirname, 'index.ts');
let content = fs.readFileSync(indexPath, 'utf8');

// Replace plural table names with singular ones
content = content.replace(/FROM communities WHERE/g, 'FROM community WHERE');
content = content.replace(/FROM community_members WHERE/g, 'FROM community_member WHERE');
content = content.replace(/FROM posts WHERE/g, 'FROM post WHERE');
content = content.replace(/FROM comments WHERE/g, 'FROM comment WHERE');
content = content.replace(/FROM users WHERE/g, 'FROM user WHERE');
content = content.replace(/FROM votes WHERE/g, 'FROM vote WHERE');

// Check for more plural table names
content = content.replace(/INSERT INTO communities/g, 'INSERT INTO community');
content = content.replace(/INSERT INTO community_members/g, 'INSERT INTO community_member');
content = content.replace(/INSERT INTO posts/g, 'INSERT INTO post');
content = content.replace(/INSERT INTO comments/g, 'INSERT INTO comment');
content = content.replace(/INSERT INTO users/g, 'INSERT INTO user');
content = content.replace(/INSERT INTO votes/g, 'INSERT INTO vote');

content = content.replace(/UPDATE communities/g, 'UPDATE community');
content = content.replace(/UPDATE community_members/g, 'UPDATE community_member');
content = content.replace(/UPDATE posts/g, 'UPDATE post');
content = content.replace(/UPDATE comments/g, 'UPDATE comment');
content = content.replace(/UPDATE users/g, 'UPDATE user');
content = content.replace(/UPDATE votes/g, 'UPDATE vote');

content = content.replace(/DELETE FROM communities/g, 'DELETE FROM community');
content = content.replace(/DELETE FROM community_members/g, 'DELETE FROM community_member');
content = content.replace(/DELETE FROM posts/g, 'DELETE FROM post');
content = content.replace(/DELETE FROM comments/g, 'DELETE FROM comment');
content = content.replace(/DELETE FROM users/g, 'DELETE FROM user');
content = content.replace(/DELETE FROM votes/g, 'DELETE FROM vote');

// Write the updated content back
fs.writeFileSync(indexPath, content, 'utf8');

console.log('Updated table names from plural to singular in index.ts');

// Now check the routes files
const routesDir = path.join(__dirname, 'routes');
const routeFiles = fs.readdirSync(routesDir);

routeFiles.forEach(file => {
  if (file.endsWith('.js')) {
    const filePath = path.join(routesDir, file);
    let routeContent = fs.readFileSync(filePath, 'utf8');
    
    // Replace plural table names with singular ones
    routeContent = routeContent.replace(/FROM communities/g, 'FROM community');
    routeContent = routeContent.replace(/FROM community_members/g, 'FROM community_member');
    routeContent = routeContent.replace(/FROM posts/g, 'FROM post');
    routeContent = routeContent.replace(/FROM comments/g, 'FROM comment');
    routeContent = routeContent.replace(/FROM users/g, 'FROM user');
    routeContent = routeContent.replace(/FROM votes/g, 'FROM vote');
    
    routeContent = routeContent.replace(/INSERT INTO communities/g, 'INSERT INTO community');
    routeContent = routeContent.replace(/INSERT INTO community_members/g, 'INSERT INTO community_member');
    routeContent = routeContent.replace(/INSERT INTO posts/g, 'INSERT INTO post');
    routeContent = routeContent.replace(/INSERT INTO comments/g, 'INSERT INTO comment');
    routeContent = routeContent.replace(/INSERT INTO users/g, 'INSERT INTO user');
    routeContent = routeContent.replace(/INSERT INTO votes/g, 'INSERT INTO vote');
    
    routeContent = routeContent.replace(/UPDATE communities/g, 'UPDATE community');
    routeContent = routeContent.replace(/UPDATE community_members/g, 'UPDATE community_member');
    routeContent = routeContent.replace(/UPDATE posts/g, 'UPDATE post');
    routeContent = routeContent.replace(/UPDATE comments/g, 'UPDATE comment');
    routeContent = routeContent.replace(/UPDATE users/g, 'UPDATE user');
    routeContent = routeContent.replace(/UPDATE votes/g, 'UPDATE vote');
    
    routeContent = routeContent.replace(/DELETE FROM communities/g, 'DELETE FROM community');
    routeContent = routeContent.replace(/DELETE FROM community_members/g, 'DELETE FROM community_member');
    routeContent = routeContent.replace(/DELETE FROM posts/g, 'DELETE FROM post');
    routeContent = routeContent.replace(/DELETE FROM comments/g, 'DELETE FROM comment');
    routeContent = routeContent.replace(/DELETE FROM users/g, 'DELETE FROM user');
    routeContent = routeContent.replace(/DELETE FROM votes/g, 'DELETE FROM vote');
    
    fs.writeFileSync(filePath, routeContent, 'utf8');
    console.log(`Updated table names in routes/${file}`);
  }
});

console.log('Database table name corrections completed');

================
File: backend/index.js
================
const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const { v4: uuidv4 } = require('uuid');

// Import route modules
const authRoutes = require('./routes/auth');
const communitiesRoutes = require('./routes/communities');
const postsRoutes = require('./routes/posts');
const commentsRoutes = require('./routes/comments');
const usersRoutes = require('./routes/users');
const votesRoutes = require('./routes/votes');
const activityRoutes = require('./routes/activity');

// Import activity logging middleware
const { 
  logUserLogin, 
  logUserRegistration, 
  logUserLogout 
} = require('./middleware/activity');

dotenv.config();

const app = express();
const port = process.env.PORT || 3001; // Use a different port from the frontend

// Global middleware
app.use(express.json());
app.use(cors()); // Enable CORS for all routes

// Fix for BigInt serialization
BigInt.prototype.toJSON = function() {
    return this.toString();
};

// Get the authenticateToken middleware from auth routes
const { authenticateToken } = authRoutes;
const { canViewCommunity, isCommunityModerator } = communitiesRoutes;
const { canPostInCommunity } = postsRoutes;

// Authentication middleware for protected routes that allows anonymous access
const authenticateOptional = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    // Continue without authentication
    req.user = null;
    next();
    return;
  }
  
  try {
    const user = require('./api/auth').verifyToken(token);
    req.user = user;
    next();
  } catch (error) {
    // Log token error for debugging (but don't expose details to client)
    console.error('Token validation error:', error.message);
    
    // Clear any partial authentication data
    req.user = null;
    
    // Continue without authentication
    next();
  }
};

// Error handling middleware
const errorHandler = (err, req, res, next) => {
  console.error('Unhandled error:', err);
  
  // Don't expose internal server error details in production
  const statusCode = err.statusCode || 500;
  const message = statusCode === 500 ? 'Internal Server Error' : err.message;
  
  res.status(statusCode).json({
    error: {
      message,
      status: statusCode
    }
  });
};

// Mount the routes
// Add activity logging middleware to auth routes
app.use('/api/auth/login', logUserLogin);
app.use('/api/auth/register', logUserRegistration);
app.use('/api/auth/logout', authenticateOptional, logUserLogout);
app.use('/api/auth', authRoutes.router);

// For communities routes, use optional authentication
app.use('/api/communities', authenticateOptional, communitiesRoutes.router);

// For posts routes, use optional authentication
app.use('/api/posts', authenticateOptional, postsRoutes.router);

// For comments routes, use optional authentication
app.use('/api/comments', authenticateOptional, commentsRoutes);

// For users routes, use optional authentication
app.use('/api/users', authenticateOptional, usersRoutes);

// For votes routes, use optional authentication
app.use('/api/votes', authenticateOptional, votesRoutes);

// For activity routes, use authenticated routes only
app.use('/api/activity', authenticateToken, activityRoutes);

// Root route
app.get('/', (req, res) => {
  res.send('Hello from Express backend!');
});

// Add error handling middleware
app.use(errorHandler);

// Handle 404s
app.use((req, res) => {
  res.status(404).json({
    error: {
      message: 'Not Found',
      status: 404
    }
  });
});

// Start the server
app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);
});

================
File: backend/index.ts
================
import express, { Request, Response, NextFunction } from 'express';
import mariadb from 'mariadb';
import cors from 'cors';
// Temporary imports to force tsc to compile api files
import * as posts from './api/posts';
import * as communities from './api/communities';
import * as users from './api/users';
import * as auth from './api/auth';
import * as commentsApi from './api/comments';

const app = express();
const port = 3001; // Use a different port from the frontend

import dotenv from 'dotenv';
dotenv.config();

const pool = mariadb.createPool({
     host: process.env.DB_HOST,
     port: Number(process.env.DB_PORT),
     user: process.env.DB_USER,
     password: process.env.DB_PASSWORD,
     database: process.env.DB_NAME,
     connectionLimit: 5
});

// Import API functions
import {
    getCommunities,
    getCommunity,
    createCommunity,
    updateCommunity,
    deleteCommunity,
    getCommunityRules,
    addCommunityRule,
    updateCommunityRule,
    deleteCommunityRule,
    getCommunitySettings,
    updateCommunitySettings,
    getCommunityMembers,
    addCommunityMember,
    updateCommunityMemberRole,
    removeCommunityMember,
    getCommunityAbout,
    getUserCommunities,
    searchCommunities
} from './api/communities';

import {
    register,
    login,
    getCurrentUser,
    verifyToken
} from './api/auth';

// Route Handlers
app.use(express.json());
app.use(cors()); // Enable CORS for all routes

// Authentication middleware
interface AuthRequest extends Request {
    user?: any;
}

const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction): void => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        res.status(401).json({ error: 'Authentication required' });
        return;
    }
    
    try {
        const user = verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        res.status(403).json({ error: 'Invalid or expired token' });
        return;
    }
};

// Check if user is a community moderator
const isCommunityModerator = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role = 'moderator'",
            [communityId, userId]
        );
        
        if (!membership) {
            res.status(403).json({ error: 'Moderator access required' });
            return;
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        res.status(500).json({ error: 'Failed to check moderator status' });
        return;
    } finally {
        if (conn) conn.end();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            next();
            return;
        }
        
        // Private communities require membership
        if (!userId) {
            res.status(401).json({ error: 'Authentication required' });
            return;
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            res.status(403).json({ error: 'Membership required' });
            return;
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        res.status(500).json({ error: 'Failed to check community access' });
        return;
    } finally {
        if (conn) conn.end();
    }
};

// Check if user can post in a community (must be a member)
const canPostInCommunity = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
    const communityId = req.body.communityId;
    const userId = req.user.id;
    
    if (!communityId) {
        next(); // Profile post, no community check needed
        return;
    }
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            res.status(403).json({ error: 'You must be a member of this community to post' });
            return;
        }
        
        next();
    } catch (error) {
        console.error("Error checking community membership:", error);
        res.status(500).json({ error: 'Failed to check community membership' });
        return;
    } finally {
        if (conn) conn.end();
    }
};

// Authentication routes
app.post('/api/auth/register', async (req: Request, res: Response): Promise<void> => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        res.status(400).json({ error: 'Username, email, and password are required' });
        return;
    }
    
    try {
        const user = await register({ username, email, password });
        res.status(201).json(user);
    } catch (error: any) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

app.post('/api/auth/login', async (req: Request, res: Response): Promise<void> => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        res.status(400).json({ error: 'Username and password are required' });
        return;
    }
    
    try {
        const result = await login({ username, password });
        res.json(result);
    } catch (error: any) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

app.get('/api/auth/me', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    try {
        const user = await getCurrentUser(req.user.id);
        res.json(user);
    } catch (error: any) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

// Communities API
app.get('/api/communities', async (req: Request, res: Response): Promise<void> => {
    try {
        const searchTerm = req.query.search as string;
        
        if (searchTerm) {
            const communities = await searchCommunities(searchTerm);
            res.json(communities);
        } else {
            const communities = await getCommunities();
            res.json(communities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

app.get('/api/communities/:id', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const community = await getCommunity(id);
        if (!community) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

app.post('/api/communities', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await addCommunityMember(newCommunity.id, userId, 'moderator');
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

app.put('/api/communities/:id', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    try {
        const updatedCommunity = await updateCommunity(id, { name, description, privacy }, userId);
        if (!updatedCommunity) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

app.delete('/api/communities/:id', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user.id;
    try {
        const success = await deleteCommunity(id, userId);
        if (!success) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
app.get('/api/communities/:id/rules', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const rules = await getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

app.post('/api/communities/:id/rules', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const { title, description } = req.body;
    const userId = req.user.id;
    try {
        const newRule = await addCommunityRule(id, { title, description }, userId);
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

app.put('/api/communities/:id/rules/:ruleId', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    const userId = req.user.id;
    try {
        const updatedRule = await updateCommunityRule(ruleId, { title, description }, userId);
        if (!updatedRule) {
            res.status(404).json({ error: 'Rule not found' });
            return;
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

app.delete('/api/communities/:id/rules/:ruleId', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
    const { ruleId } = req.params;
    const userId = req.user.id;
    try {
        const success = await deleteCommunityRule(ruleId, userId);
        if (!success) {
            res.status(404).json({ error: 'Rule not found' });
            return;
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
app.get('/api/communities/:id/settings', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const settings = await getCommunitySettings(id);
        if (!settings) {
            res.status(404).json({ error: 'Settings not found' });
            return;
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

app.put('/api/communities/:id/settings', authenticateToken, isCommunityModerator, async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    const { id } = req.params;
    const { allow_post_images, allow_post_links } = req.body;
    try {
        const userId = (req as any).user.id;
        const updatedSettings = await updateCommunitySettings(id, { allow_post_images, allow_post_links }, userId);
        if (!updatedSettings) {
            res.status(404).json({ error: 'Settings not found' });
            return;
        }
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
app.get('/api/communities/:id/members', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const members = await getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

app.post('/api/communities/:id/members', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    try {
        const newMember = await addCommunityMember(id, userId, 'member');
        res.status(201).json(newMember);
    } catch (error) {
        console.error("Error adding community member:", error);
        res.status(500).json({ error: 'Failed to add community member' });
    }
});

app.put('/api/communities/:id/members/:userId', authenticateToken, isCommunityModerator, async (req: Request, res: Response): Promise<void> => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedBy = (req as any).user.id;
        const updatedMember = await updateCommunityMemberRole(id, userId, role, updatedBy);
        if (!updatedMember) {
            res.status(404).json({ error: 'Member not found' });
            return;
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

app.delete('/api/communities/:id/members/:userId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role = 'moderator'",
                [id, currentUserId]
            );
            
            if (!membership) {
                res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
                return;
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            res.status(500).json({ error: 'Failed to check moderator status' });
            return;
        } finally {
            if (conn) conn.end();
        }
    }
    
    try {
        const success = await removeCommunityMember(id, userId);
        if (!success) {
            res.status(404).json({ error: 'Member not found' });
            return;
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Community About API
app.get('/api/communities/:id/about', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const about = await getCommunityAbout(id);
        if (!about) {
            res.status(404).json({ error: 'Community not found' });
            return;
        }
        res.json(about);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
app.get('/api/users/:id/communities', async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    try {
        const communities = await getUserCommunities(id);
        res.json(communities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Posts API
app.get('/api/posts', async (req: Request, res: Response): Promise<void> => {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if we need to filter by community or user profile
        const communityId = req.query.communityId as string;
        const userProfileId = req.query.userProfileId as string;
        
        let query = "SELECT p.*, u.username FROM post p JOIN user u ON p.user_id = u.id";
        const params = [];
        
        if (communityId) {
            query += " WHERE p.community_id = ?";
            params.push(communityId);
        } else if (userProfileId) {
            query += " WHERE p.user_profile_id = ? OR p.user_id = ?";
            params.push(userProfileId, userProfileId);
        }
        
        query += " ORDER BY p.created_at DESC";
        
        const posts = await conn.query(query, params);
        res.json(posts);
    } catch (error) {
        console.error("Error fetching posts:", error);
        res.status(500).json({ error: 'Failed to fetch posts' });
    } finally {
        if (conn) conn.end();
    }
});

app.get('/api/posts/:id', async (req: Request, res: Response): Promise<void> => {
    const { id } = req.params;
    let conn;
    try {
        conn = await pool.getConnection();
        const [post] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        if (!post) {
            res.status(404).json({ error: 'Post not found' });
            return;
        }
        res.json(post);
    } catch (error) {
        console.error("Error fetching post:", error);
        res.status(500).json({ error: 'Failed to fetch post' });
    } finally {
        if (conn) conn.end();
    }
});

app.post('/api/posts', authenticateToken, canPostInCommunity, async (req: AuthRequest, res: Response): Promise<void> => {
    const { title, content, communityId, userProfileId, isProfilePost } = req.body;
    const authorId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Determine if this is a profile post
        const profilePost = isProfilePost || !!userProfileId;
        
        // Build the query based on whether this is a community post or profile post
        let query = "INSERT INTO post (title, content, user_id";
        const params = [title, content, authorId];
        
        if (communityId) {
            query += ", community_id, profile_post) VALUES (?, ?, ?, ?, ?)";
            params.push(communityId, profilePost);
        } else if (userProfileId) {
            query += ", user_profile_id, profile_post) VALUES (?, ?, ?, ?, ?)";
            params.push(userProfileId, profilePost);
        } else {
            query += ", profile_post) VALUES (?, ?, ?, ?)";
            params.push(profilePost);
        }
        
        const result = await conn.query(query, params);
        
        const [newPost] = await conn.query("SELECT * FROM post WHERE id = ?", [result.insertId]);
        res.status(201).json(newPost);
    } catch (error) {
        console.error("Error creating post:", error);
        res.status(500).json({ error: 'Failed to create post' });
    } finally {
        if (conn) conn.end();
    }
});

app.put('/api/posts/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const { title, content } = req.body;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is the author of the post
        const [post] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        
        if (!post) {
            res.status(404).json({ error: 'Post not found' });
            return;
        }
        
        if (post.user_id !== userId) {
            res.status(403).json({ error: 'You can only edit your own posts' });
            return;
        }
        
        await conn.query(
            "UPDATE post SET title = ?, content = ?, updated_at = NOW() WHERE id = ?",
            [title, content, id]
        );
        
        const [updatedPost] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        res.json(updatedPost);
    } catch (error) {
        console.error("Error updating post:", error);
        res.status(500).json({ error: 'Failed to update post' });
    } finally {
        if (conn) conn.end();
    }
});

app.delete('/api/posts/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { id } = req.params;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is the author of the post or a community moderator
        const [post] = await conn.query("SELECT * FROM post WHERE id = ?", [id]);
        
        if (!post) {
            res.status(404).json({ error: 'Post not found' });
            return;
        }
        
        if (post.user_id !== userId) {
            // Check if user is a moderator of the community
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role = 'moderator'",
                [post.community_id, userId]
            );
            
            if (!membership) {
                res.status(403).json({ error: 'You can only delete your own posts or posts in communities you moderate' });
                return;
            }
        }
        
        await conn.query("DELETE FROM post WHERE id = ?", [id]);
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting post:", error);
        res.status(500).json({ error: 'Failed to delete post' });
    } finally {
        if (conn) conn.end();
    }
});

app.get('/', (req: Request, res: Response): void => {
  res.send('Hello from Express backend!');
});

// Comments API
app.get('/api/posts/:postId/comments', async (req: Request, res: Response): Promise<void> => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const commentsList = await commentsApi.getThreadedComments(postId);
            res.json(commentsList);
        } else {
            const allComments = await commentsApi.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

app.get('/api/comments/:commentId', async (req: Request, res: Response): Promise<void> => {
    const { commentId } = req.params;
    try {
        const comment = await commentsApi.getComment(commentId);
        if (!comment) {
            res.status(404).json({ error: 'Comment not found' });
            return;
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

app.post('/api/posts/:postId/comments', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await commentsApi.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

app.put('/api/comments/:commentId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await commentsApi.updateComment(commentId, userId, content);
        if (!updatedComment) {
            res.status(404).json({ error: 'Comment not found' });
            return;
        }
        res.json(updatedComment);
    } catch (error: any) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            res.status(403).json({ error: error.message });
            return;
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

app.delete('/api/comments/:commentId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await commentsApi.deleteComment(commentId, userId);
        if (!success) {
            res.status(404).json({ error: 'Comment not found' });
            return;
        }
        res.status(204).end();
    } catch (error: any) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments') {
            res.status(403).json({ error: error.message });
            return;
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

app.get('/api/comments/:commentId/replies', async (req: Request, res: Response): Promise<void> => {
    const { commentId } = req.params;
    try {
        const replies = await commentsApi.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);
});

================
File: backend/middleware/activity.js
================
const { logActivity } = require('../api/activity');

/**
 * Middleware to log user activities
 * @param {string} activityType - The type of activity (e.g., 'POST', 'COMMENT', 'VOTE')
 * @param {string} actionType - The type of action (e.g., 'CREATE', 'UPDATE', 'DELETE')
 * @param {Function} getEntityInfo - Function to extract entity info from request (returns { entityId, entityType, metadata })
 * @returns {Function} Express middleware function
 */
function logActivityMiddleware(activityType, actionType, getEntityInfo) {
  return async (req, res, next) => {
    // Store the original end function
    const originalEnd = res.end;
    let activityLogged = false;
    
    // Override the end function
    res.end = async function(chunk, encoding) {
      // Only log activities once to prevent duplicate logging
      if (activityLogged) {
        return originalEnd.call(this, chunk, encoding);
      }
      
      // Mark as logged to prevent double logging if there's an error
      activityLogged = true;
      
      // Only log activities for successful responses (2xx status codes)
      if (res.statusCode >= 200 && res.statusCode < 300) {
        try {
          // Get user ID from authenticated user
          const userId = req.user ? req.user.id : null;
          
          if (userId) {
            // Get entity info from the provided function
            let entityInfo = { entityId: null, entityType: null, metadata: null };
            
            try {
              entityInfo = getEntityInfo(req, res) || entityInfo;
            } catch (entityError) {
              console.error('Error extracting entity info:', entityError);
            }
            
            const { entityId, entityType, metadata } = entityInfo;
            
            // Get IP address and user agent
            const ipAddress = req.ip || req.connection.remoteAddress;
            const userAgent = req.headers['user-agent'];
            
            // Log the activity without waiting for it to complete
            logActivity({
              userId,
              activityType,
              actionType,
              entityId,
              entityType,
              metadata,
              ipAddress,
              userAgent
            }).catch(error => {
              console.error('Error logging activity:', error);
            });
          }
        } catch (error) {
          // Just log the error, don't affect the response
          console.error('Error in activity middleware:', error);
        }
      }
      
      // Call the original end function
      return originalEnd.call(this, chunk, encoding);
    };
    
    next();
  };
}

/**
 * Helper function to log user login activity
 */
function logUserLogin(req, res, next) {
  // Store the original end function
  const originalEnd = res.end;
  let activityLogged = false;
  
  // Override the end function
  res.end = async function(chunk, encoding) {
    // Only log activities once to prevent duplicate logging
    if (activityLogged) {
      return originalEnd.call(this, chunk, encoding);
    }
    
    // Mark as logged to prevent double logging if there's an error
    activityLogged = true;
    
    // Only log activities for successful responses (2xx status codes)
    if (res.statusCode >= 200 && res.statusCode < 300) {
      try {
        // Get user ID from response body
        let userId = null;
        
        if (chunk) {
          try {
            const responseBody = JSON.parse(chunk.toString());
            userId = responseBody && responseBody.user ? responseBody.user.id : null;
          } catch (parseError) {
            console.error('Error parsing response body:', parseError);
          }
        }
        
        if (userId) {
          // Get IP address and user agent
          const ipAddress = req.ip || req.connection.remoteAddress;
          const userAgent = req.headers['user-agent'];
          
          // Log the activity without waiting for it to complete
          logActivity({
            userId,
            activityType: 'USER',
            actionType: 'LOGIN',
            entityId: userId,
            entityType: 'user',
            metadata: null,
            ipAddress,
            userAgent
          }).catch(error => {
            console.error('Error logging login activity:', error);
          });
        }
      } catch (error) {
        // Just log the error, don't affect the response
        console.error('Error in login activity middleware:', error);
      }
    }
    
    // Call the original end function
    return originalEnd.call(this, chunk, encoding);
  };
  
  next();
}

/**
 * Helper function to log user registration activity
 */
function logUserRegistration(req, res, next) {
  // Store the original end function
  const originalEnd = res.end;
  let activityLogged = false;
  
  // Override the end function
  res.end = async function(chunk, encoding) {
    // Only log activities once to prevent duplicate logging
    if (activityLogged) {
      return originalEnd.call(this, chunk, encoding);
    }
    
    // Mark as logged to prevent double logging if there's an error
    activityLogged = true;
    
    // Only log activities for successful responses (2xx status codes)
    if (res.statusCode >= 200 && res.statusCode < 300) {
      try {
        // Get user ID from response body
        let userId = null;
        let username = null;
        
        if (chunk) {
          try {
            const responseBody = JSON.parse(chunk.toString());
            if (responseBody && responseBody.user) {
              userId = responseBody.user.id;
              username = responseBody.user.username;
            }
          } catch (parseError) {
            console.error('Error parsing response body:', parseError);
          }
        }
        
        if (userId) {
          // Get IP address and user agent
          const ipAddress = req.ip || req.connection.remoteAddress;
          const userAgent = req.headers['user-agent'];
          
          // Log the activity without waiting for it to complete
          logActivity({
            userId,
            activityType: 'USER',
            actionType: 'REGISTER',
            entityId: userId,
            entityType: 'user',
            metadata: { username },
            ipAddress,
            userAgent
          }).catch(error => {
            console.error('Error logging registration activity:', error);
          });
        }
      } catch (error) {
        // Just log the error, don't affect the response
        console.error('Error in registration activity middleware:', error);
      }
    }
    
    // Call the original end function
    return originalEnd.call(this, chunk, encoding);
  };
  
  next();
}

/**
 * Helper function to log user logout activity
 */
function logUserLogout(req, res, next) {
  // Get user ID from authenticated user
  const userId = req.user ? req.user.id : null;
  
  if (userId) {
    // Get IP address and user agent
    const ipAddress = req.ip || req.connection.remoteAddress;
    const userAgent = req.headers['user-agent'];
    
    // Log the activity without waiting for the middleware to complete
    logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress,
      userAgent
    }).catch(error => {
      console.error('Error logging logout activity:', error);
    });
  }
  
  next();
}

// Common entity info extractors
const entityInfoExtractors = {
  // Post entity info extractors
  post: {
    create: (req) => ({
      entityId: req.body.id || null, // For new posts, the ID might be in the response
      entityType: 'post',
      metadata: {
        title: req.body.title,
        community_id: req.body.communityId || req.body.community_id
      }
    }),
    update: (req) => ({
      entityId: req.params.id || req.params.postId,
      entityType: 'post',
      metadata: {
        title: req.body.title
      }
    }),
    delete: (req) => ({
      entityId: req.params.id || req.params.postId,
      entityType: 'post',
      metadata: null
    })
  },
  
  // Comment entity info extractors
  comment: {
    create: (req) => ({
      entityId: req.body.id || null, // For new comments, the ID might be in the response
      entityType: 'comment',
      metadata: {
        post_id: req.params.postId || req.body.post_id || req.body.postId,
        parent_comment_id: req.body.parentCommentId || req.body.parent_comment_id
      }
    }),
    update: (req) => ({
      entityId: req.params.id || req.params.commentId,
      entityType: 'comment',
      metadata: null
    }),
    delete: (req) => ({
      entityId: req.params.id || req.params.commentId,
      entityType: 'comment',
      metadata: null
    })
  },
  
  // Vote entity info extractors
  vote: {
    create: (req) => {
      if (req.params.postId || req.body.postId || req.body.post_id) {
        return {
          entityId: req.params.postId || req.body.postId || req.body.post_id,
          entityType: 'post',
          metadata: {
            value: req.body.value
          }
        };
      } else if (req.params.commentId || req.body.commentId || req.body.comment_id) {
        return {
          entityId: req.params.commentId || req.body.commentId || req.body.comment_id,
          entityType: 'comment',
          metadata: {
            value: req.body.value
          }
        };
      }
      return { entityId: null, entityType: null, metadata: null };
    }
  },
  
  // Community entity info extractors
  community: {
    create: (req) => ({
      entityId: req.body.id || null, // For new communities, the ID might be in the response
      entityType: 'community',
      metadata: {
        name: req.body.name
      }
    }),
    update: (req) => ({
      entityId: req.params.id || req.params.communityId,
      entityType: 'community',
      metadata: {
        name: req.body.name
      }
    }),
    join: (req) => ({
      entityId: req.params.id || req.params.communityId,
      entityType: 'community',
      metadata: null
    }),
    leave: (req) => ({
      entityId: req.params.id || req.params.communityId,
      entityType: 'community',
      metadata: null
    })
  }
};

module.exports = {
  logActivityMiddleware,
  logUserLogin,
  logUserRegistration,
  logUserLogout,
  entityInfoExtractors
};

================
File: backend/middleware/auth.js
================
const jwt = require('jsonwebtoken');

// Middleware to authenticate JWT token
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'Access denied. No token provided.' });
  }
  
  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    req.user = user;
    next();
  } catch (error) {
    return res.status(403).json({ error: 'Invalid token.' });
  }
};

module.exports = { authenticateToken };

================
File: backend/middleware/moderation.js
================
// backend/middleware/moderation.js
const { isUserModerator, hasModeratorPermission, isUserBanned } = require('../api/moderation.ts.new');

// Middleware to check if a user is a moderator for a community
const isCommunityModerator = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isModerator = await isUserModerator(communityId, userId);
    
    if (!isModerator) {
      return res.status(403).json({ error: 'Only moderators can perform this action' });
    }
    
    next();
  } catch (error) {
    console.error('Error in moderator check middleware:', error);
    return res.status(500).json({ error: 'Server error checking moderator status' });
  }
};

// Middleware to check if a user has a specific moderator permission
const hasPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const { communityId } = req.params;
      const userId = req.user.id;
      
      if (!communityId) {
        return res.status(400).json({ error: 'Community ID is required' });
      }
      
      const hasPermission = await hasModeratorPermission(communityId, userId, permission);
      
      if (!hasPermission) {
        return res.status(403).json({ error: 'You do not have permission to perform this action' });
      }
      
      next();
    } catch (error) {
      console.error(`Error in permission check middleware (${permission}):`, error);
      return res.status(500).json({ error: 'Server error checking permissions' });
    }
  };
};

// Middleware to check if the user is banned from the community
const checkNotBanned = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isBanned = await isUserBanned(communityId, userId);
    
    if (isBanned) {
      return res.status(403).json({ error: 'You are banned from this community' });
    }
    
    next();
  } catch (error) {
    console.error('Error in ban check middleware:', error);
    return res.status(500).json({ error: 'Server error checking ban status' });
  }
};

module.exports = {
  isCommunityModerator,
  hasPermission,
  checkNotBanned
};

================
File: backend/middleware/moderation.js.new
================
// backend/middleware/moderation.js
const { isUserModerator, hasModeratorPermission, isUserBanned } = require('../api/moderation.ts.new');

// Middleware to check if a user is a moderator for a community
const isCommunityModerator = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isModerator = await isUserModerator(communityId, userId);
    
    if (!isModerator) {
      return res.status(403).json({ error: 'Only moderators can perform this action' });
    }
    
    next();
  } catch (error) {
    console.error('Error in moderator check middleware:', error);
    return res.status(500).json({ error: 'Server error checking moderator status' });
  }
};

// Middleware to check if a user has a specific moderator permission
const hasPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const { communityId } = req.params;
      const userId = req.user.id;
      
      if (!communityId) {
        return res.status(400).json({ error: 'Community ID is required' });
      }
      
      const hasPermission = await hasModeratorPermission(communityId, userId, permission);
      
      if (!hasPermission) {
        return res.status(403).json({ error: 'You do not have permission to perform this action' });
      }
      
      next();
    } catch (error) {
      console.error(`Error in permission check middleware (${permission}):`, error);
      return res.status(500).json({ error: 'Server error checking permissions' });
    }
  };
};

// Middleware to check if the user is banned from the community
const checkNotBanned = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isBanned = await isUserBanned(communityId, userId);
    
    if (isBanned) {
      return res.status(403).json({ error: 'You are banned from this community' });
    }
    
    next();
  } catch (error) {
    console.error('Error in ban check middleware:', error);
    return res.status(500).json({ error: 'Server error checking ban status' });
  }
};

module.exports = {
  isCommunityModerator,
  hasPermission,
  checkNotBanned
};

================
File: backend/package.json
================
{
  "name": "bolt-backend",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "node dist/index.js",
    "build": "tsc",
    "dev": "tsc --watch",
    "init-db": "node db/init.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/cors": "^2.8.17",
    "@types/uuid": "^10.0.0",
    "bcrypt": "^5.1.1",
    "bolt-backend": "file:",
    "cors": "^2.8.5",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "mariadb": "^3.2.4",
    "mysql2": "^3.12.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^20.12.8"
  }
}

================
File: backend/routes/activity.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const {
  getUserActivities,
  getCommunityActivities,
  getPostActivities,
  getActivityTypes,
  getActionTypes,
  logActivity
} = require('../api/activity');

// Middleware to ensure routes are protected
router.use(authenticateToken);

/**
 * @route GET /api/activity/types
 * @desc Get all activity types
 * @access Private
 */
router.get('/types', async (req, res) => {
  try {
    const activityTypes = await getActivityTypes();
    res.json(activityTypes);
  } catch (error) {
    console.error('Error fetching activity types:', error);
    res.status(500).json({ error: 'Failed to fetch activity types' });
  }
});

/**
 * @route GET /api/activity/actions
 * @desc Get all action types
 * @access Private
 */
router.get('/actions', async (req, res) => {
  try {
    const actionTypes = await getActionTypes();
    res.json(actionTypes);
  } catch (error) {
    console.error('Error fetching action types:', error);
    res.status(500).json({ error: 'Failed to fetch action types' });
  }
});

/**
 * @route GET /api/activity/user/:userId
 * @desc Get activities for a specific user
 * @access Private (only for the user themselves or admins)
 */
router.get('/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own activities or is an admin
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own activities' });
    }
    
    // Extract query parameters
    const {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    } = req.query;
    
    const options = {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    };
    
    const activities = await getUserActivities(userId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Failed to fetch user activities' });
  }
});

/**
 * @route GET /api/activity/me
 * @desc Get activities for the current user
 * @access Private
 */
router.get('/me', async (req, res) => {
  try {
    const userId = req.user.id;
    
    // Extract query parameters
    const {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    } = req.query;
    
    const options = {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    };
    
    const activities = await getUserActivities(userId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Failed to fetch user activities' });
  }
});

/**
 * @route GET /api/activity/community/:communityId
 * @desc Get activities for a specific community
 * @access Private (only for community members)
 */
router.get('/community/:communityId', async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Check if the user is a member of the community
    const conn = await pool.getConnection();
    try {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership && req.user.role !== 'admin') {
        return res.status(403).json({ error: 'You must be a member of this community to view its activities' });
      }
    } finally {
      conn.release();
    }
    
    // Extract query parameters
    const {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    } = req.query;
    
    const options = {
      limit,
      offset,
      activityType,
      actionType,
      entityType,
      startDate,
      endDate
    };
    
    const activities = await getCommunityActivities(communityId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching community activities:', error);
    res.status(500).json({ error: 'Failed to fetch community activities' });
  }
});

/**
 * @route GET /api/activity/post/:postId
 * @desc Get activities for a specific post
 * @access Private
 */
router.get('/post/:postId', async (req, res) => {
  try {
    const { postId } = req.params;
    
    // Extract query parameters
    const { limit, offset } = req.query;
    
    const options = { limit, offset };
    
    const activities = await getPostActivities(postId, options);
    res.json(activities);
  } catch (error) {
    console.error('Error fetching post activities:', error);
    res.status(500).json({ error: 'Failed to fetch post activities' });
  }
});

/**
 * @route POST /api/activity/log
 * @desc Log a new activity (for manual logging, most activities are logged automatically)
 * @access Private (admin only)
 */
router.post('/log', async (req, res) => {
  try {
    // Only admins can manually log activities
    if (req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Only admins can manually log activities' });
    }
    
    const {
      userId,
      activityType,
      actionType,
      entityId,
      entityType,
      metadata
    } = req.body;
    
    // Validate required fields
    if (!userId || !activityType || !actionType) {
      return res.status(400).json({ error: 'userId, activityType, and actionType are required' });
    }
    
    // Get IP address and user agent from request
    const ipAddress = req.ip;
    const userAgent = req.headers['user-agent'];
    
    const activityData = {
      userId,
      activityType,
      actionType,
      entityId,
      entityType,
      metadata,
      ipAddress,
      userAgent
    };
    
    const activity = await logActivity(activityData);
    res.status(201).json(activity);
  } catch (error) {
    console.error('Error logging activity:', error);
    res.status(500).json({ error: 'Failed to log activity' });
  }
});

module.exports = router;

================
File: backend/routes/auth.js
================
// Updated auth.js routes for the new database schema
const express = require('express');
const router = express.Router();
const auth = require('../api/auth.js');
const { logUserLogin, logUserRegistration, logUserLogout } = require('../middleware/activity');

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
        const user = auth.verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid or expired token' });
    }
};

// Authentication routes
router.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        return res.status(400).json({ error: 'Username, email, and password are required' });
    }
    
    try {
        const result = await auth.register({ username, email, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.status(201).json(result);
    } catch (error) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        return res.status(400).json({ error: 'Username and password are required' });
    }
    
    try {
        const result = await auth.login({ username, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.json(result);
    } catch (error) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

router.post('/logout', authenticateToken, async (req, res) => {
    try {
        await auth.logout(req.user.id);
        
        res.json({ success: true, message: 'Logged out successfully' });
    } catch (error) {
        console.error("Error logging out:", error);
        res.status(500).json({ error: error.message });
    }
});

router.get('/me', authenticateToken, async (req, res) => {
    try {
        const user = await auth.getCurrentUser(req.user.id);
        res.json(user);
    } catch (error) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

module.exports = {
    router,
    authenticateToken
};

================
File: backend/routes/auth.js.new
================
// Updated auth.js routes for the new database schema
const express = require('express');
const router = express.Router();
const auth = require('../api/auth.js');
const { logUserLogin, logUserRegistration, logUserLogout } = require('../middleware/activity');

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
        const user = auth.verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid or expired token' });
    }
};

// Authentication routes
router.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        return res.status(400).json({ error: 'Username, email, and password are required' });
    }
    
    try {
        const result = await auth.register({ username, email, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.status(201).json(result);
    } catch (error) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        return res.status(400).json({ error: 'Username and password are required' });
    }
    
    try {
        const result = await auth.login({ username, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.json(result);
    } catch (error) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

router.post('/logout', authenticateToken, async (req, res) => {
    try {
        await auth.logout(req.user.id);
        
        res.json({ success: true, message: 'Logged out successfully' });
    } catch (error) {
        console.error("Error logging out:", error);
        res.status(500).json({ error: error.message });
    }
});

router.get('/me', authenticateToken, async (req, res) => {
    try {
        const user = await auth.getCurrentUser(req.user.id);
        res.json(user);
    } catch (error) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

module.exports = {
    router,
    authenticateToken
};

================
File: backend/routes/comments.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const comments = require('../api/comments.js.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Get comments for a post (with optional threading)
router.get('/posts/:postId', async (req, res) => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const threadedComments = await comments.getThreadedComments(postId);
            res.json(threadedComments);
        } else {
            const allComments = await comments.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

// Get a specific comment
router.get('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    try {
        const comment = await comments.getComment(commentId);
        if (!comment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

// Create a new comment
router.post('/posts/:postId', checkNotBanned, async (req, res) => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await comments.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        if (error.message === 'Post not found' || error.message === 'Parent comment not found') {
            return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

// Update a comment
router.put('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await comments.updateComment(commentId, userId, content);
        if (!updatedComment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(updatedComment);
    } catch (error) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

// Delete a comment
router.delete('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await comments.deleteComment(commentId, userId);
        if (!success) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments or comments in communities you moderate') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

// Get replies to a comment
router.get('/:commentId/replies', async (req, res) => {
    const { commentId } = req.params;
    try {
        const replies = await comments.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

// Get comments for a specific user
router.get('/user/:userId', async (req, res) => {
    const { userId } = req.params;
    try {
        const userComments = await comments.getUserComments(userId);
        res.json(userComments);
    } catch (error) {
        console.error("Error fetching user comments:", error);
        res.status(500).json({ error: 'Failed to fetch user comments' });
    }
});

module.exports = router;

================
File: backend/routes/comments.js.new
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const comments = require('../api/comments.js.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Get comments for a post (with optional threading)
router.get('/posts/:postId', async (req, res) => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const threadedComments = await comments.getThreadedComments(postId);
            res.json(threadedComments);
        } else {
            const allComments = await comments.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

// Get a specific comment
router.get('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    try {
        const comment = await comments.getComment(commentId);
        if (!comment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

// Create a new comment
router.post('/posts/:postId', checkNotBanned, async (req, res) => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await comments.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        if (error.message === 'Post not found' || error.message === 'Parent comment not found') {
            return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

// Update a comment
router.put('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await comments.updateComment(commentId, userId, content);
        if (!updatedComment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(updatedComment);
    } catch (error) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

// Delete a comment
router.delete('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await comments.deleteComment(commentId, userId);
        if (!success) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments or comments in communities you moderate') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

// Get replies to a comment
router.get('/:commentId/replies', async (req, res) => {
    const { commentId } = req.params;
    try {
        const replies = await comments.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

// Get comments for a specific user
router.get('/user/:userId', async (req, res) => {
    const { userId } = req.params;
    try {
        const userComments = await comments.getUserComments(userId);
        res.json(userComments);
    } catch (error) {
        console.error("Error fetching user comments:", error);
        res.status(500).json({ error: 'Failed to fetch user comments' });
    }
});

module.exports = router;

================
File: backend/routes/communities.js
================
import express from 'express';
const router = express.Router();
import dotenv from 'dotenv';
import pool from '../db/connection.js';
import communityApi from '../api/community/index.js';

dotenv.config();

// Check if user is a community moderator
const isCommunityModerator = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Moderator access required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        return res.status(500).json({ error: 'Failed to check moderator status' });
    } finally {
        if (conn) conn.release();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            return next();
        }
        
        // Private communities require membership
        if (!userId) {
            return res.status(401).json({ error: 'Authentication required' });
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Membership required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        return res.status(500).json({ error: 'Failed to check community access' });
    } finally {
        if (conn) conn.release();
    }
};

// Communities API
router.get('/', async (req, res) => {
    try {
        const searchTerm = req.query.search;
        
        if (searchTerm) {
            const communitiesList = await communityApi.searchCommunities(searchTerm);
            res.json(communitiesList);
        } else {
            const allCommunities = await communityApi.getCommunities();
            res.json(allCommunities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

router.get('/:id', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const community = await communityApi.getCommunity(id);
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

router.post('/', async (req, res) => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await communityApi.createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await communityApi.addCommunityMember(newCommunity.id, userId, 'moderator');
        
        // Activity logging is now handled within the community API functions
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

router.put('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    try {
        const updatedCommunity = await communityApi.updateCommunity(id, { name, description, privacy });
        if (!updatedCommunity) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

router.delete('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const success = await communityApi.deleteCommunity(id);
        if (!success) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
router.get('/:id/rules', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const rules = await communityApi.getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

router.post('/:id/rules', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { title, description } = req.body;
    try {
        const newRule = await communityApi.addCommunityRule(id, { title, description });
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

router.put('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    try {
        const updatedRule = await communityApi.updateCommunityRule(ruleId, { title, description });
        if (!updatedRule) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

router.delete('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    try {
        const success = await communityApi.deleteCommunityRule(ruleId);
        if (!success) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
router.get('/:id/settings', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const settings = await communityApi.getCommunitySettings(id);
        if (!settings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

router.put('/:id/settings', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { 
        allow_post_images, 
        allow_post_links, 
        join_method,
        require_post_approval,
        restricted_words,
        custom_theme_color,
        custom_banner_url,
        minimum_account_age_days,
        minimum_karma_required
    } = req.body;
    
    try {
        const updatedSettings = await communityApi.updateCommunitySettings(id, { 
            allow_post_images, 
            allow_post_links,
            join_method,
            require_post_approval,
            restricted_words,
            custom_theme_color,
            custom_banner_url,
            minimum_account_age_days,
            minimum_karma_required
        });
        
        if (!updatedSettings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
router.get('/:id/members', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const members = await communityApi.getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

// Get a specific member
router.get('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    console.log(`GET request for member: community ${id}, user ${userId}`);
    
    try {
        const member = await communityApi.getCommunityMember(id, userId);
        console.log("Member result:", member);
        
        if (!member) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        res.json(member);
    } catch (error) {
        console.error("Error fetching community member:", error);
        res.status(500).json({ error: 'Failed to fetch community member' });
    }
});

router.post('/:id/members', async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    console.log(`POST request for member: community ${id}, user ${userId}`);
    
    try {
        // Get community settings to check join method
        const settings = await communityApi.getCommunitySettings(id);
        
        if (!settings) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        console.log("Community settings:", settings);
        
        // Handle based on join method
        switch (settings.join_method) {
            case 'auto_approve':
                console.log("Auto-approving join request");
                // Directly add as member
                const newMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(newMember);
                
            case 'requires_approval':
                console.log("Creating pending join request");
                // Create a join request
                const joinRequest = await communityApi.createJoinRequest(id, userId);
                return res.status(202).json({
                    message: 'Join request submitted for approval',
                    request: joinRequest
                });
                
            case 'invite_only':
                console.log("Rejecting invite-only join request");
                return res.status(403).json({ error: 'This community is invite-only' });
                
            default:
                console.log("Using fallback auto-approve method");
                // Fallback to auto-approve for any unexpected values
                const fallbackMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(fallbackMember);
        }
    } catch (error) {
        console.error("Error joining community:", error);
        res.status(500).json({ error: 'Failed to join community' });
    }
});

router.put('/:id/members/:userId', isCommunityModerator, async (req, res) => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedMember = await communityApi.updateCommunityMemberRole(id, userId, role);
        if (!updatedMember) {
            return res.status(404).json({ error: 'Member not found' });
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

router.delete('/:id/members', async (req, res) => {
    const { id } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for current user to leave: community ${id}, user ${currentUserId}`);
    
    try {
        console.log(`Removing member ${currentUserId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, currentUserId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${currentUserId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

router.delete('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for specific member: community ${id}, target user ${userId}, current user ${currentUserId}`);
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
                [id, currentUserId]
            );
            
            if (!membership) {
                return res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            return res.status(500).json({ error: 'Failed to check moderator status' });
        } finally {
            if (conn) conn.release();
        }
    }
    
    try {
        console.log(`Removing member ${userId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, userId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${userId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Join Requests API
router.get('/:id/join-requests', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const requests = await communityApi.getJoinRequests(id);
        res.json(requests);
    } catch (error) {
        console.error("Error fetching join requests:", error);
        res.status(500).json({ error: 'Failed to fetch join requests' });
    }
});

router.get('/:id/join-requests/:requestId', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const request = await communityApi.getJoinRequest(requestId);
        if (!request) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.json(request);
    } catch (error) {
        console.error("Error fetching join request:", error);
        res.status(500).json({ error: 'Failed to fetch join request' });
    }
});

router.post('/:id/join-requests/:requestId/approve', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'approved');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request approved' });
    } catch (error) {
        console.error("Error approving join request:", error);
        res.status(500).json({ error: 'Failed to approve join request' });
    }
});

router.post('/:id/join-requests/:requestId/reject', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'rejected');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request rejected' });
    } catch (error) {
        console.error("Error rejecting join request:", error);
        res.status(500).json({ error: 'Failed to reject join request' });
    }
});

// Community About API
router.get('/:id/about', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const about = await communityApi.getCommunity(id);
        if (!about) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Format the response to include only the about information
        const aboutInfo = {
            id: about.id,
            name: about.name,
            description: about.description,
            privacy: about.privacy,
            created_at: about.created_at,
            member_count: await communityApi.getCommunityMemberCount(id)
        };
        
        res.json(aboutInfo);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
router.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const userCommunities = await communityApi.getUserCommunities(id);
        res.json(userCommunities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Discover Communities API
router.get('/discover/trending', async (req, res) => {
    try {
        const trendingCommunities = await communityApi.getTrendingCommunities();
        res.json(trendingCommunities);
    } catch (error) {
        console.error("Error fetching trending communities:", error);
        res.status(500).json({ error: 'Failed to fetch trending communities' });
    }
});

router.get('/discover/recommended', async (req, res) => {
    const userId = req.user?.id;
    try {
        const recommendedCommunities = await communityApi.getRecommendedCommunities(userId);
        res.json(recommendedCommunities);
    } catch (error) {
        console.error("Error fetching recommended communities:", error);
        res.status(500).json({ error: 'Failed to fetch recommended communities' });
    }
});

export {
    router,
    canViewCommunity,
    isCommunityModerator
};

================
File: backend/routes/communities.js.new
================
import express from 'express';
const router = express.Router();
import dotenv from 'dotenv';
import pool from '../db/connection.js';
import communityApi from '../api/community/index.js';

dotenv.config();

// Check if user is a community moderator
const isCommunityModerator = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Moderator access required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        return res.status(500).json({ error: 'Failed to check moderator status' });
    } finally {
        if (conn) conn.release();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            return next();
        }
        
        // Private communities require membership
        if (!userId) {
            return res.status(401).json({ error: 'Authentication required' });
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Membership required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        return res.status(500).json({ error: 'Failed to check community access' });
    } finally {
        if (conn) conn.release();
    }
};

// Communities API
router.get('/', async (req, res) => {
    try {
        const searchTerm = req.query.search;
        
        if (searchTerm) {
            const communitiesList = await communityApi.searchCommunities(searchTerm);
            res.json(communitiesList);
        } else {
            const allCommunities = await communityApi.getCommunities();
            res.json(allCommunities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

router.get('/:id', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const community = await communityApi.getCommunity(id);
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

router.post('/', async (req, res) => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await communityApi.createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await communityApi.addCommunityMember(newCommunity.id, userId, 'moderator');
        
        // Activity logging is now handled within the community API functions
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

router.put('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    try {
        const updatedCommunity = await communityApi.updateCommunity(id, { name, description, privacy });
        if (!updatedCommunity) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

router.delete('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const success = await communityApi.deleteCommunity(id);
        if (!success) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
router.get('/:id/rules', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const rules = await communityApi.getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

router.post('/:id/rules', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { title, description } = req.body;
    try {
        const newRule = await communityApi.addCommunityRule(id, { title, description });
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

router.put('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    try {
        const updatedRule = await communityApi.updateCommunityRule(ruleId, { title, description });
        if (!updatedRule) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

router.delete('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    try {
        const success = await communityApi.deleteCommunityRule(ruleId);
        if (!success) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
router.get('/:id/settings', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const settings = await communityApi.getCommunitySettings(id);
        if (!settings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

router.put('/:id/settings', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { 
        allow_post_images, 
        allow_post_links, 
        join_method,
        require_post_approval,
        restricted_words,
        custom_theme_color,
        custom_banner_url,
        minimum_account_age_days,
        minimum_karma_required
    } = req.body;
    
    try {
        const updatedSettings = await communityApi.updateCommunitySettings(id, { 
            allow_post_images, 
            allow_post_links,
            join_method,
            require_post_approval,
            restricted_words,
            custom_theme_color,
            custom_banner_url,
            minimum_account_age_days,
            minimum_karma_required
        });
        
        if (!updatedSettings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
router.get('/:id/members', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const members = await communityApi.getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

// Get a specific member
router.get('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    console.log(`GET request for member: community ${id}, user ${userId}`);
    
    try {
        const member = await communityApi.getCommunityMember(id, userId);
        console.log("Member result:", member);
        
        if (!member) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        res.json(member);
    } catch (error) {
        console.error("Error fetching community member:", error);
        res.status(500).json({ error: 'Failed to fetch community member' });
    }
});

router.post('/:id/members', async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    console.log(`POST request for member: community ${id}, user ${userId}`);
    
    try {
        // Get community settings to check join method
        const settings = await communityApi.getCommunitySettings(id);
        
        if (!settings) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        console.log("Community settings:", settings);
        
        // Handle based on join method
        switch (settings.join_method) {
            case 'auto_approve':
                console.log("Auto-approving join request");
                // Directly add as member
                const newMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(newMember);
                
            case 'requires_approval':
                console.log("Creating pending join request");
                // Create a join request
                const joinRequest = await communityApi.createJoinRequest(id, userId);
                return res.status(202).json({
                    message: 'Join request submitted for approval',
                    request: joinRequest
                });
                
            case 'invite_only':
                console.log("Rejecting invite-only join request");
                return res.status(403).json({ error: 'This community is invite-only' });
                
            default:
                console.log("Using fallback auto-approve method");
                // Fallback to auto-approve for any unexpected values
                const fallbackMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(fallbackMember);
        }
    } catch (error) {
        console.error("Error joining community:", error);
        res.status(500).json({ error: 'Failed to join community' });
    }
});

router.put('/:id/members/:userId', isCommunityModerator, async (req, res) => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedMember = await communityApi.updateCommunityMemberRole(id, userId, role);
        if (!updatedMember) {
            return res.status(404).json({ error: 'Member not found' });
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

router.delete('/:id/members', async (req, res) => {
    const { id } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for current user to leave: community ${id}, user ${currentUserId}`);
    
    try {
        console.log(`Removing member ${currentUserId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, currentUserId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${currentUserId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

router.delete('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for specific member: community ${id}, target user ${userId}, current user ${currentUserId}`);
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
                [id, currentUserId]
            );
            
            if (!membership) {
                return res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            return res.status(500).json({ error: 'Failed to check moderator status' });
        } finally {
            if (conn) conn.release();
        }
    }
    
    try {
        console.log(`Removing member ${userId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, userId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${userId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Join Requests API
router.get('/:id/join-requests', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const requests = await communityApi.getJoinRequests(id);
        res.json(requests);
    } catch (error) {
        console.error("Error fetching join requests:", error);
        res.status(500).json({ error: 'Failed to fetch join requests' });
    }
});

router.get('/:id/join-requests/:requestId', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const request = await communityApi.getJoinRequest(requestId);
        if (!request) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.json(request);
    } catch (error) {
        console.error("Error fetching join request:", error);
        res.status(500).json({ error: 'Failed to fetch join request' });
    }
});

router.post('/:id/join-requests/:requestId/approve', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'approved');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request approved' });
    } catch (error) {
        console.error("Error approving join request:", error);
        res.status(500).json({ error: 'Failed to approve join request' });
    }
});

router.post('/:id/join-requests/:requestId/reject', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'rejected');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request rejected' });
    } catch (error) {
        console.error("Error rejecting join request:", error);
        res.status(500).json({ error: 'Failed to reject join request' });
    }
});

// Community About API
router.get('/:id/about', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const about = await communityApi.getCommunity(id);
        if (!about) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Format the response to include only the about information
        const aboutInfo = {
            id: about.id,
            name: about.name,
            description: about.description,
            privacy: about.privacy,
            created_at: about.created_at,
            member_count: await communityApi.getCommunityMemberCount(id)
        };
        
        res.json(aboutInfo);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
router.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const userCommunities = await communityApi.getUserCommunities(id);
        res.json(userCommunities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Discover Communities API
router.get('/discover/trending', async (req, res) => {
    try {
        const trendingCommunities = await communityApi.getTrendingCommunities();
        res.json(trendingCommunities);
    } catch (error) {
        console.error("Error fetching trending communities:", error);
        res.status(500).json({ error: 'Failed to fetch trending communities' });
    }
});

router.get('/discover/recommended', async (req, res) => {
    const userId = req.user?.id;
    try {
        const recommendedCommunities = await communityApi.getRecommendedCommunities(userId);
        res.json(recommendedCommunities);
    } catch (error) {
        console.error("Error fetching recommended communities:", error);
        res.status(500).json({ error: 'Failed to fetch recommended communities' });
    }
});

export {
    router,
    canViewCommunity,
    isCommunityModerator
};

================
File: backend/routes/community-members.js
================
// API route handler for community members
// This adds endpoints to check current user membership and handle joining communities

const express = require('express');
const router = express.Router();
const { getCommunityMember } = require('../api/communities.ts');
const { addCommunityMember } = require('../api/communities.js');
const auth = require('../middleware/auth');

// Route to check if the current user is a member of a community
router.get('/:communityId/current', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Check if the user is a member
    const member = await getCommunityMember(communityId, userId);
    
    if (member) {
      return res.status(200).json({ 
        is_member: true,
        role: member.role,
        member_since: member.joined_at
      });
    } else {
      return res.status(200).json({ is_member: false });
    }
  } catch (error) {
    console.error('Error checking member status:', error);
    res.status(500).json({ error: 'Failed to check membership status' });
  }
});

// Route to add a member to a community
router.post('/:communityId', auth, async (req, res) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    // Use our fixed version that handles table name issues
    const member = await addCommunityMember(communityId, userId);
    res.status(200).json(member);
  } catch (error) {
    console.error('Error in addMember:', error);
    res.status(500).json({ error: 'Failed to add community member' });
  }
});

module.exports = router;

================
File: backend/routes/moderation.js
================
// backend/routes/moderation.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { isCommunityModerator, hasPermission } = require('../middleware/moderation');
const {
  // Moderator permissions
  getModeratorPermissions,
  setModeratorPermissions,
  
  // Community settings
  getEnhancedCommunitySettings,
  updateEnhancedCommunitySettings,
  
  // Post moderation
  getPostModerationStatus,
  addPostToModQueue,
  moderatePost,
  getPendingModQueue,
  
  // Moderation logs
  getModerationLogs,
  
  // Banning
  banUserFromCommunity,
  unbanUserFromCommunity,
  getBannedUsers
} = require('../api/moderation.ts.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Moderator permissions routes
router.get('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = await getModeratorPermissions(communityId, userId);
      res.json(permissions || { message: 'No specific permissions found' });
    } catch (error) {
      console.error('Error fetching moderator permissions:', error);
      res.status(500).json({ error: 'Failed to fetch moderator permissions' });
    }
  }
);

router.post('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = req.body;
      
      const updatedPermissions = await setModeratorPermissions(communityId, userId, permissions);
      res.json(updatedPermissions);
    } catch (error) {
      console.error('Error setting moderator permissions:', error);
      res.status(500).json({ error: 'Failed to set moderator permissions' });
    }
  }
);

// Community settings routes
router.get('/communities/:communityId/settings', 
  authenticateToken,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = await getEnhancedCommunitySettings(communityId);
      res.json(settings);
    } catch (error) {
      console.error('Error fetching community settings:', error);
      res.status(500).json({ error: 'Failed to fetch community settings' });
    }
  }
);

router.put('/communities/:communityId/settings', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_settings'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = req.body;
      
      const updatedSettings = await updateEnhancedCommunitySettings(communityId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating community settings:', error);
      res.status(500).json({ error: 'Failed to update community settings' });
    }
  }
);

// Post moderation routes
router.get('/communities/:communityId/mod-queue', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_posts'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const pendingPosts = await getPendingModQueue(communityId);
      res.json(pendingPosts);
    } catch (error) {
      console.error('Error fetching moderation queue:', error);
      res.status(500).json({ error: 'Failed to fetch moderation queue' });
    }
  }
);

router.post('/posts/:postId/moderate', 
  authenticateToken,
  async (req, res) => {
    try {
      const { postId } = req.params;
      const { action, reason } = req.body;
      const userId = req.user.id;
      
      // Get community ID from the post to check permissions
      const { getCommunityIdFromPost } = require('../api/community/community-core');
      const communityId = await getCommunityIdFromPost(postId);
      
      if (!communityId) {
        return res.status(404).json({ error: 'Post not found' });
      }
      
      // Check if user is a moderator with post management permissions
      const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
      
      if (!canManagePosts) {
        return res.status(403).json({ error: 'You do not have permission to moderate posts' });
      }
      
      if (action !== 'approve' && action !== 'reject') {
        return res.status(400).json({ error: 'Invalid action. Must be "approve" or "reject"' });
      }
      
      const result = await moderatePost(postId, userId, action, reason);
      res.json(result);
    } catch (error) {
      console.error('Error moderating post:', error);
      res.status(500).json({ error: 'Failed to moderate post' });
    }
  }
);

// Moderation logs routes
router.get('/communities/:communityId/logs', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const { limit = 50, offset = 0 } = req.query;
      
      const logs = await getModerationLogs(communityId, parseInt(limit), parseInt(offset));
      res.json(logs);
    } catch (error) {
      console.error('Error fetching moderation logs:', error);
      res.status(500).json({ error: 'Failed to fetch moderation logs' });
    }
  }
);

// User ban routes
router.get('/communities/:communityId/banned-users', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const bannedUsers = await getBannedUsers(communityId);
      res.json(bannedUsers);
    } catch (error) {
      console.error('Error fetching banned users:', error);
      res.status(500).json({ error: 'Failed to fetch banned users' });
    }
  }
);

router.post('/communities/:communityId/ban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason, duration } = req.body; // duration in days
      const bannedBy = req.user.id;
      
      const ban = await banUserFromCommunity(communityId, userId, bannedBy, reason, duration);
      res.json(ban);
    } catch (error) {
      console.error('Error banning user:', error);
      res.status(500).json({ error: 'Failed to ban user' });
    }
  }
);

router.post('/communities/:communityId/unban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason } = req.body;
      const unbannedBy = req.user.id;
      
      const result = await unbanUserFromCommunity(communityId, userId, unbannedBy, reason);
      
      if (result) {
        res.json({ message: 'User has been unbanned' });
      } else {
        res.status(404).json({ message: 'User was not banned' });
      }
    } catch (error) {
      console.error('Error unbanning user:', error);
      res.status(500).json({ error: 'Failed to unban user' });
    }
  }
);

// Add community member route with role assignment
router.post('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { addCommunityMember } = require('../api/community/community-members');
      const member = await addCommunityMember(communityId, userId, role);
      
      // If setting as moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error adding community member:', error);
      res.status(500).json({ error: 'Failed to add community member' });
    }
  }
);

// Update community member role
router.put('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { updateCommunityMemberRole } = require('../api/community/community-members');
      const member = await updateCommunityMemberRole(communityId, userId, role);
      
      // If promoting to moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error updating community member role:', error);
      res.status(500).json({ error: 'Failed to update community member role' });
    }
  }
);

module.exports = router;

================
File: backend/routes/moderation.js.new
================
// backend/routes/moderation.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { isCommunityModerator, hasPermission } = require('../middleware/moderation');
const {
  // Moderator permissions
  getModeratorPermissions,
  setModeratorPermissions,
  
  // Community settings
  getEnhancedCommunitySettings,
  updateEnhancedCommunitySettings,
  
  // Post moderation
  getPostModerationStatus,
  addPostToModQueue,
  moderatePost,
  getPendingModQueue,
  
  // Moderation logs
  getModerationLogs,
  
  // Banning
  banUserFromCommunity,
  unbanUserFromCommunity,
  getBannedUsers
} = require('../api/moderation.ts.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Moderator permissions routes
router.get('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = await getModeratorPermissions(communityId, userId);
      res.json(permissions || { message: 'No specific permissions found' });
    } catch (error) {
      console.error('Error fetching moderator permissions:', error);
      res.status(500).json({ error: 'Failed to fetch moderator permissions' });
    }
  }
);

router.post('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = req.body;
      
      const updatedPermissions = await setModeratorPermissions(communityId, userId, permissions);
      res.json(updatedPermissions);
    } catch (error) {
      console.error('Error setting moderator permissions:', error);
      res.status(500).json({ error: 'Failed to set moderator permissions' });
    }
  }
);

// Community settings routes
router.get('/communities/:communityId/settings', 
  authenticateToken,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = await getEnhancedCommunitySettings(communityId);
      res.json(settings);
    } catch (error) {
      console.error('Error fetching community settings:', error);
      res.status(500).json({ error: 'Failed to fetch community settings' });
    }
  }
);

router.put('/communities/:communityId/settings', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_settings'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = req.body;
      
      const updatedSettings = await updateEnhancedCommunitySettings(communityId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating community settings:', error);
      res.status(500).json({ error: 'Failed to update community settings' });
    }
  }
);

// Post moderation routes
router.get('/communities/:communityId/mod-queue', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_posts'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const pendingPosts = await getPendingModQueue(communityId);
      res.json(pendingPosts);
    } catch (error) {
      console.error('Error fetching moderation queue:', error);
      res.status(500).json({ error: 'Failed to fetch moderation queue' });
    }
  }
);

router.post('/posts/:postId/moderate', 
  authenticateToken,
  async (req, res) => {
    try {
      const { postId } = req.params;
      const { action, reason } = req.body;
      const userId = req.user.id;
      
      // Get community ID from the post to check permissions
      const { getCommunityIdFromPost } = require('../api/community/community-core');
      const communityId = await getCommunityIdFromPost(postId);
      
      if (!communityId) {
        return res.status(404).json({ error: 'Post not found' });
      }
      
      // Check if user is a moderator with post management permissions
      const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
      
      if (!canManagePosts) {
        return res.status(403).json({ error: 'You do not have permission to moderate posts' });
      }
      
      if (action !== 'approve' && action !== 'reject') {
        return res.status(400).json({ error: 'Invalid action. Must be "approve" or "reject"' });
      }
      
      const result = await moderatePost(postId, userId, action, reason);
      res.json(result);
    } catch (error) {
      console.error('Error moderating post:', error);
      res.status(500).json({ error: 'Failed to moderate post' });
    }
  }
);

// Moderation logs routes
router.get('/communities/:communityId/logs', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const { limit = 50, offset = 0 } = req.query;
      
      const logs = await getModerationLogs(communityId, parseInt(limit), parseInt(offset));
      res.json(logs);
    } catch (error) {
      console.error('Error fetching moderation logs:', error);
      res.status(500).json({ error: 'Failed to fetch moderation logs' });
    }
  }
);

// User ban routes
router.get('/communities/:communityId/banned-users', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const bannedUsers = await getBannedUsers(communityId);
      res.json(bannedUsers);
    } catch (error) {
      console.error('Error fetching banned users:', error);
      res.status(500).json({ error: 'Failed to fetch banned users' });
    }
  }
);

router.post('/communities/:communityId/ban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason, duration } = req.body; // duration in days
      const bannedBy = req.user.id;
      
      const ban = await banUserFromCommunity(communityId, userId, bannedBy, reason, duration);
      res.json(ban);
    } catch (error) {
      console.error('Error banning user:', error);
      res.status(500).json({ error: 'Failed to ban user' });
    }
  }
);

router.post('/communities/:communityId/unban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason } = req.body;
      const unbannedBy = req.user.id;
      
      const result = await unbanUserFromCommunity(communityId, userId, unbannedBy, reason);
      
      if (result) {
        res.json({ message: 'User has been unbanned' });
      } else {
        res.status(404).json({ message: 'User was not banned' });
      }
    } catch (error) {
      console.error('Error unbanning user:', error);
      res.status(500).json({ error: 'Failed to unban user' });
    }
  }
);

// Add community member route with role assignment
router.post('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { addCommunityMember } = require('../api/community/community-members');
      const member = await addCommunityMember(communityId, userId, role);
      
      // If setting as moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error adding community member:', error);
      res.status(500).json({ error: 'Failed to add community member' });
    }
  }
);

// Update community member role
router.put('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { updateCommunityMemberRole } = require('../api/community/community-members');
      const member = await updateCommunityMemberRole(communityId, userId, role);
      
      // If promoting to moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error updating community member role:', error);
      res.status(500).json({ error: 'Failed to update community member role' });
    }
  }
);

module.exports = router;

================
File: backend/routes/posts.js
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const posts = require('../api/posts.js.new');

// Middleware to check if the user is authenticated for protected routes
router.use(authenticateToken);

// Get all posts (with optional filtering)
router.get('/', async (req, res) => {
  await posts.getPosts(req, res);
});

// Get a specific post by ID
router.get('/:id', async (req, res) => {
  await posts.getPost(req, res);
});

// Get posts for a specific community
router.get('/community/:communityId', checkNotBanned, async (req, res) => {
  req.params.communityId = req.params.communityId;
  await posts.getCommunityPosts(req, res);
});

// Get posts for a specific user
router.get('/user/:userId', async (req, res) => {
  await posts.getUserPosts(req, res);
});

// Create a new post
router.post('/', authenticateToken, posts.canPostInCommunity, async (req, res) => {
  await posts.createPost(req, res);
});

// Update a post
router.put('/:id', authenticateToken, async (req, res) => {
  await posts.updatePost(req, res);
});

// Delete a post
router.delete('/:id', authenticateToken, async (req, res) => {
  await posts.deletePost(req, res);
});

module.exports = router;

================
File: backend/routes/posts.js.new
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const posts = require('../api/posts.js.new');

// Middleware to check if the user is authenticated for protected routes
router.use(authenticateToken);

// Get all posts (with optional filtering)
router.get('/', async (req, res) => {
  await posts.getPosts(req, res);
});

// Get a specific post by ID
router.get('/:id', async (req, res) => {
  await posts.getPost(req, res);
});

// Get posts for a specific community
router.get('/community/:communityId', checkNotBanned, async (req, res) => {
  req.params.communityId = req.params.communityId;
  await posts.getCommunityPosts(req, res);
});

// Get posts for a specific user
router.get('/user/:userId', async (req, res) => {
  await posts.getUserPosts(req, res);
});

// Create a new post
router.post('/', authenticateToken, posts.canPostInCommunity, async (req, res) => {
  await posts.createPost(req, res);
});

// Update a post
router.put('/:id', authenticateToken, async (req, res) => {
  await posts.updatePost(req, res);
});

// Delete a post
router.delete('/:id', authenticateToken, async (req, res) => {
  await posts.deletePost(req, res);
});

module.exports = router;

================
File: backend/routes/users.js
================
const express = require('express');
const router = express.Router();
const mysql = require('mysql2/promise');
const { v4: uuidv4 } = require('uuid');
const { authenticateToken } = require('../middleware/auth');
const pool = require('../db/connection');

// Get all users
router.get('/', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.display_name,
         u.role, u.bio, u.avatar_url, u.profile_banner_url, u.website, u.location,
         u.is_verified, u.status, u.cake_day, u.last_active, u.created_at, u.updated_at,
         us.karma, us.posts_count, us.comments_count, us.upvotes_received, 
         us.downvotes_received, us.upvotes_given, us.downvotes_given, us.communities_joined
         FROM user u
         LEFT JOIN user_statistic us ON u.id = us.user_id`
      );
      
      // Remove sensitive information
      const users = rows.map(user => {
        const { password_hash, ...userWithoutPassword } = user;
        return userWithoutPassword;
      });
      
      res.json(users);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user profile by ID
router.get('/:userId', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.display_name,
         u.role, u.bio, u.avatar_url, u.profile_banner_url, u.website, u.location,
         u.is_verified, u.status, u.cake_day, u.last_active, u.created_at, u.updated_at,
         us.karma, us.posts_count, us.comments_count, us.upvotes_received, 
         us.downvotes_received, us.upvotes_given, us.downvotes_given, us.communities_joined
         FROM user u
         LEFT JOIN user_statistic us ON u.id = us.user_id
         WHERE u.id = ?`,
        [req.params.userId]
      );
      
      if (rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      // Remove sensitive information
      const user = rows[0];
      delete user.password_hash;
      
      res.json(user);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user profile
router.put('/profile', authenticateToken, async (req, res) => {
  try {
    const { 
      username, 
      email, 
      first_name, 
      last_name, 
      display_name, 
      bio, 
      avatar_url, 
      profile_banner_url, 
      website, 
      location 
    } = req.body;
    
    const userId = req.user.id;
    
    // Validate input
    if (!username || !email) {
      return res.status(400).json({ error: 'Username and email are required' });
    }
    
    const connection = await pool.getConnection();
    
    try {
      // Check if username is already taken by another user
      const [existingUsers] = await connection.execute(
        'SELECT id FROM user WHERE username = ? AND id != ?',
        [username, userId]
      );
      
      if (existingUsers.length > 0) {
        return res.status(400).json({ error: 'Username is already taken' });
      }
      
      // Update user profile
      await connection.execute(
        `UPDATE user SET 
         username = ?, 
         email = ?, 
         first_name = ?,
         last_name = ?,
         display_name = ?,
         bio = ?, 
         avatar_url = ?,
         profile_banner_url = ?,
         website = ?,
         location = ?,
         updated_at = CURRENT_TIMESTAMP
         WHERE id = ?`,
        [
          username, 
          email, 
          first_name || null, 
          last_name || null, 
          display_name || null, 
          bio || null, 
          avatar_url || null, 
          profile_banner_url || null, 
          website || null, 
          location || null, 
          userId
        ]
      );
      
      // Get updated user data
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.email, u.first_name, u.last_name, u.display_name,
         u.role, u.bio, u.avatar_url, u.profile_banner_url, u.website, u.location,
         u.is_verified, u.status, u.cake_day, u.last_active, u.created_at, u.updated_at,
         us.karma, us.posts_count, us.comments_count, us.upvotes_received, 
         us.downvotes_received, us.upvotes_given, us.downvotes_given, us.communities_joined
         FROM user u
         LEFT JOIN user_statistic us ON u.id = us.user_id
         WHERE u.id = ?`,
        [userId]
      );
      
      // Remove sensitive information
      const user = rows[0];
      delete user.password_hash;
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'UPDATE'),
          ?, 'user', NOW()
        )`,
        [uuidv4(), userId, userId]
      );
      
      res.json(user);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error updating user profile:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user statistics
router.get('/:userId/statistics', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT * FROM user_statistic WHERE user_id = ?`,
        [req.params.userId]
      );
      
      if (rows.length === 0) {
        return res.status(404).json({ error: 'User statistics not found' });
      }
      
      res.json(rows[0]);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user statistics:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user settings
router.get('/settings', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT * FROM user_setting WHERE user_id = ?`,
        [userId]
      );
      
      if (rows.length === 0) {
        // Create default settings if they don't exist
        const defaultSettings = {
          email_notifications: true,
          push_notifications: true,
          theme: 'light',
          content_filter: 'standard',
          allow_followers: true,
          display_online_status: true,
          language: 'en',
          timezone: 'UTC'
        };
        
        await connection.execute(
          `INSERT INTO user_setting (
            user_id, email_notifications, push_notifications, theme,
            content_filter, allow_followers, display_online_status,
            language, timezone
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            userId,
            defaultSettings.email_notifications ? 1 : 0,
            defaultSettings.push_notifications ? 1 : 0,
            defaultSettings.theme,
            defaultSettings.content_filter,
            defaultSettings.allow_followers ? 1 : 0,
            defaultSettings.display_online_status ? 1 : 0,
            defaultSettings.language,
            defaultSettings.timezone
          ]
        );
        
        return res.json(defaultSettings);
      }
      
      // Convert boolean fields from 0/1 to false/true
      const settings = rows[0];
      settings.email_notifications = !!settings.email_notifications;
      settings.push_notifications = !!settings.push_notifications;
      settings.allow_followers = !!settings.allow_followers;
      settings.display_online_status = !!settings.display_online_status;
      
      res.json(settings);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user settings:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user settings
router.put('/settings', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      email_notifications,
      push_notifications,
      theme,
      content_filter,
      allow_followers,
      display_online_status,
      language,
      timezone
    } = req.body;
    
    const connection = await pool.getConnection();
    
    try {
      // Check if settings exist
      const [existingSettings] = await connection.execute(
        `SELECT * FROM user_setting WHERE user_id = ?`,
        [userId]
      );
      
      if (existingSettings.length === 0) {
        // Create settings if they don't exist
        await connection.execute(
          `INSERT INTO user_setting (
            user_id, email_notifications, push_notifications, theme,
            content_filter, allow_followers, display_online_status,
            language, timezone
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
          [
            userId,
            email_notifications ? 1 : 0,
            push_notifications ? 1 : 0,
            theme || 'light',
            content_filter || 'standard',
            allow_followers ? 1 : 0,
            display_online_status ? 1 : 0,
            language || 'en',
            timezone || 'UTC'
          ]
        );
      } else {
        // Update existing settings
        await connection.execute(
          `UPDATE user_setting SET
            email_notifications = ?,
            push_notifications = ?,
            theme = ?,
            content_filter = ?,
            allow_followers = ?,
            display_online_status = ?,
            language = ?,
            timezone = ?,
            updated_at = CURRENT_TIMESTAMP
          WHERE user_id = ?`,
          [
            email_notifications ? 1 : 0,
            push_notifications ? 1 : 0,
            theme || 'light',
            content_filter || 'standard',
            allow_followers ? 1 : 0,
            display_online_status ? 1 : 0,
            language || 'en',
            timezone || 'UTC',
            userId
          ]
        );
      }
      
      // Get updated settings
      const [rows] = await connection.execute(
        `SELECT * FROM user_setting WHERE user_id = ?`,
        [userId]
      );
      
      // Convert boolean fields from 0/1 to false/true
      const settings = rows[0];
      settings.email_notifications = !!settings.email_notifications;
      settings.push_notifications = !!settings.push_notifications;
      settings.allow_followers = !!settings.allow_followers;
      settings.display_online_status = !!settings.display_online_status;
      
      res.json(settings);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error updating user settings:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user relationships (friends)
router.get('/:userId/friends', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      // Get accepted friends
      const [rows] = await connection.execute(
        `SELECT u.id, u.username, u.display_name, u.avatar_url, ur.created_at as friendship_date
         FROM user_relationship ur
         JOIN user u ON (ur.related_user_id = u.id)
         WHERE ur.user_id = ? AND ur.relationship_type = 'friend' AND ur.status = 'accepted'
         UNION
         SELECT u.id, u.username, u.display_name, u.avatar_url, ur.created_at as friendship_date
         FROM user_relationship ur
         JOIN user u ON (ur.user_id = u.id)
         WHERE ur.related_user_id = ? AND ur.relationship_type = 'friend' AND ur.status = 'accepted'
         ORDER BY friendship_date DESC`,
        [req.params.userId, req.params.userId]
      );
      
      res.json(rows);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user friends:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Add friend request
router.post('/friends/:targetUserId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const targetUserId = req.params.targetUserId;
    
    // Prevent self-friending
    if (userId === targetUserId) {
      return res.status(400).json({ error: 'Cannot add yourself as a friend' });
    }
    
    const connection = await pool.getConnection();
    
    try {
      // Check if relationship already exists
      const [existingRelationship] = await connection.execute(
        `SELECT * FROM user_relationship 
         WHERE (user_id = ? AND related_user_id = ?) 
         OR (user_id = ? AND related_user_id = ?)
         AND relationship_type = 'friend'`,
        [userId, targetUserId, targetUserId, userId]
      );
      
      if (existingRelationship.length > 0) {
        return res.status(400).json({ 
          error: 'Relationship already exists', 
          status: existingRelationship[0].status 
        });
      }
      
      // Create friend request
      const relationshipId = uuidv4();
      await connection.execute(
        `INSERT INTO user_relationship (
          id, user_id, related_user_id, relationship_type, status, created_at
        ) VALUES (?, ?, ?, 'friend', 'pending', NOW())`,
        [relationshipId, userId, targetUserId]
      );
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'user_relationship', NOW()
        )`,
        [uuidv4(), userId, relationshipId]
      );
      
      res.status(201).json({ message: 'Friend request sent' });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error sending friend request:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Accept/reject friend request
router.put('/friends/:relationshipId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const relationshipId = req.params.relationshipId;
    const { status } = req.body; // 'accepted' or 'rejected'
    
    if (status !== 'accepted' && status !== 'rejected') {
      return res.status(400).json({ error: 'Invalid status' });
    }
    
    const connection = await pool.getConnection();
    
    try {
      // Check if relationship exists and user is the target
      const [relationship] = await connection.execute(
        `SELECT * FROM user_relationship 
         WHERE id = ? AND related_user_id = ? AND relationship_type = 'friend' AND status = 'pending'`,
        [relationshipId, userId]
      );
      
      if (relationship.length === 0) {
        return res.status(404).json({ error: 'Friend request not found' });
      }
      
      // Update relationship status
      await connection.execute(
        `UPDATE user_relationship SET status = ?, updated_at = NOW() WHERE id = ?`,
        [status, relationshipId]
      );
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'UPDATE'),
          ?, 'user_relationship', NOW()
        )`,
        [uuidv4(), userId, relationshipId]
      );
      
      res.json({ message: `Friend request ${status}` });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error updating friend request:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Remove friend
router.delete('/friends/:targetUserId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    const targetUserId = req.params.targetUserId;
    
    const connection = await pool.getConnection();
    
    try {
      // Delete the relationship in both directions
      await connection.execute(
        `DELETE FROM user_relationship 
         WHERE ((user_id = ? AND related_user_id = ?) 
         OR (user_id = ? AND related_user_id = ?))
         AND relationship_type = 'friend'`,
        [userId, targetUserId, targetUserId, userId]
      );
      
      // Log activity
      await connection.execute(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'USER'),
          (SELECT id FROM action WHERE name = 'DELETE'),
          ?, 'user_relationship', NOW()
        )`,
        [uuidv4(), userId, targetUserId]
      );
      
      res.json({ message: 'Friend removed' });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error removing friend:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user ID by username
router.get('/lookup/:username', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        'SELECT id FROM user WHERE username = ?',
        [req.params.username]
      );
      
      if (rows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
      
      res.json({ id: rows[0].id });
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error looking up user:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user communities
router.get('/:userId/communities', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT c.id, c.name, c.description, cm.role, cm.joined_at
         FROM community_member cm
         JOIN community c ON cm.community_id = c.id
         WHERE cm.user_id = ?
         ORDER BY cm.joined_at DESC`,
        [req.params.userId]
      );
      
      res.json(rows);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user communities:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user activities
router.get('/:userId/activities', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    
    try {
      const [rows] = await connection.execute(
        `SELECT a.id, a.created_at, at.name as activity_type, ac.name as action,
         a.entity_id, a.entity_type, a.metadata
         FROM activity a
         JOIN activity_type at ON a.activity_type_id = at.id
         JOIN action ac ON a.action_id = ac.id
         WHERE a.user_id = ?
         ORDER BY a.created_at DESC
         LIMIT 50`,
        [req.params.userId]
      );
      
      res.json(rows);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

module.exports = router;

================
File: backend/routes/votes.js
================
const express = require('express');
const router = express.Router();
const { 
  voteOnPost, 
  voteOnComment, 
  getUserPostVote, 
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes
} = require('../api/votes.js.new');

// Middleware for authentication and ban checking
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');

// Vote on a post
router.post('/posts/:postId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { postId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnPost(userId, postId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on post:', error);
    res.status(400).json({ error: error.message });
  }
});

// Vote on a comment
router.post('/comments/:commentId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { commentId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnComment(userId, commentId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on comment:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a post
router.get('/posts/:postId/user', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserPostVote(userId, postId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user post vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a comment
router.get('/comments/:commentId/user', authenticateToken, async (req, res) => {
  try {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserCommentVote(userId, commentId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a post
router.get('/posts/:postId/counts', async (req, res) => {
  try {
    const { postId } = req.params;
    
    const counts = await getPostVoteCounts(postId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a comment
router.get('/comments/:commentId/counts', async (req, res) => {
  try {
    const { commentId } = req.params;
    
    const counts = await getCommentVoteCounts(commentId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get all votes for a user
router.get('/user/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own votes
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own votes' });
    }
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get current user's votes
router.get('/user', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;

================
File: backend/routes/votes.js.new
================
const express = require('express');
const router = express.Router();
const { 
  voteOnPost, 
  voteOnComment, 
  getUserPostVote, 
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes
} = require('../api/votes.js.new');

// Middleware for authentication and ban checking
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');

// Vote on a post
router.post('/posts/:postId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { postId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnPost(userId, postId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on post:', error);
    res.status(400).json({ error: error.message });
  }
});

// Vote on a comment
router.post('/comments/:commentId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { commentId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnComment(userId, commentId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on comment:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a post
router.get('/posts/:postId/user', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserPostVote(userId, postId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user post vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a comment
router.get('/comments/:commentId/user', authenticateToken, async (req, res) => {
  try {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserCommentVote(userId, commentId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a post
router.get('/posts/:postId/counts', async (req, res) => {
  try {
    const { postId } = req.params;
    
    const counts = await getPostVoteCounts(postId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a comment
router.get('/comments/:commentId/counts', async (req, res) => {
  try {
    const { commentId } = req.params;
    
    const counts = await getCommentVoteCounts(commentId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get all votes for a user
router.get('/user/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own votes
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own votes' });
    }
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get current user's votes
router.get('/user', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;

================
File: backend/test-api.js
================
const express = require('express');
const cors = require('cors');
const mysql = require('mysql2/promise');
require('dotenv').config();

const app = express();
const PORT = 3001;

// Middleware
app.use(express.json());
app.use(cors());

// Database connection
const createConnection = async () => {
  return mysql.createConnection({
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME
  });
};

// Simple health check endpoint
app.get('/', (req, res) => {
  res.json({ status: 'API is running' });
});

// Get all communities
app.get('/api/communities', async (req, res) => {
  try {
    const conn = await createConnection();
    const [communities] = await conn.query('SELECT * FROM community');
    await conn.end();
    res.json(communities);
  } catch (error) {
    console.error('Error fetching communities:', error);
    res.status(500).json({ error: 'Failed to fetch communities' });
  }
});

// Get a single community
app.get('/api/communities/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [communities] = await conn.query('SELECT * FROM community WHERE id = ?', [id]);
    await conn.end();
    
    if (communities.length === 0) {
      return res.status(404).json({ error: 'Community not found' });
    }
    
    res.json(communities[0]);
  } catch (error) {
    console.error('Error fetching community:', error);
    res.status(500).json({ error: 'Failed to fetch community' });
  }
});

// Get community members
app.get('/api/communities/:id/members', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [members] = await conn.query(
      `SELECT cm.*, u.username 
       FROM community_member cm
       JOIN user u ON cm.user_id = u.id
       WHERE cm.community_id = ?`, 
      [id]
    );
    await conn.end();
    res.json(members);
  } catch (error) {
    console.error('Error fetching community members:', error);
    res.status(500).json({ error: 'Failed to fetch community members' });
  }
});

// Get community rules
app.get('/api/communities/:id/rules', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [rules] = await conn.query('SELECT * FROM community_rule WHERE community_id = ?', [id]);
    await conn.end();
    res.json(rules);
  } catch (error) {
    console.error('Error fetching community rules:', error);
    res.status(500).json({ error: 'Failed to fetch community rules' });
  }
});

// Get community settings
app.get('/api/communities/:id/settings', async (req, res) => {
  try {
    const { id } = req.params;
    const conn = await createConnection();
    const [settings] = await conn.query('SELECT * FROM community_setting WHERE community_id = ?', [id]);
    await conn.end();
    
    if (settings.length === 0) {
      return res.status(404).json({ error: 'Settings not found' });
    }
    
    res.json(settings[0]);
  } catch (error) {
    console.error('Error fetching community settings:', error);
    res.status(500).json({ error: 'Failed to fetch community settings' });
  }
});

// Get posts for a community
app.get('/api/posts', async (req, res) => {
  try {
    const { communityId } = req.query;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID required' });
    }
    
    const conn = await createConnection();
    const [posts] = await conn.query(
      `SELECT p.*, u.username 
       FROM post p
       JOIN user u ON p.user_id = u.id
       WHERE p.community_id = ?
       ORDER BY p.created_at DESC`, 
      [communityId]
    );
    await conn.end();
    res.json(posts);
  } catch (error) {
    console.error('Error fetching posts:', error);
    res.status(500).json({ error: 'Failed to fetch posts' });
  }
});

// Auth/me mock endpoint
app.get('/api/auth/me', (req, res) => {
  // Return a mock user for testing
  res.json({
    id: '123',
    username: 'testuser',
    email: 'test@example.com',
    role: 'user'
  });
});

// Activity mock endpoint
app.get('/api/activity/community/:id', (req, res) => {
  // Return empty activity array 
  res.json([]);
});

// Start the server
app.listen(PORT, () => {
  console.log(`Test API server running on port ${PORT}`);
});

================
File: backend/testServer.js
================
const express = require('express');
const cors = require('cors');
const pool = require('./dist/db/connection');

const app = express();
const port = 3001;

// Middlewares
app.use(express.json());
app.use(cors());

// Test database connection
app.get('/api/test', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    const [rows] = await connection.query('SELECT 1 as test');
    connection.release();
    res.json({ message: 'Database connection successful', data: rows });
  } catch (error) {
    console.error('Database connection error:', error);
    res.status(500).json({ error: 'Database connection failed', details: error.message });
  }
});

// API routes
app.get('/api/communities', async (req, res) => {
  try {
    const connection = await pool.getConnection();
    // Try both singular and plural table names
    let rows;
    try {
      [rows] = await connection.query('SELECT * FROM community');
    } catch (err) {
      // If singular name fails, try plural
      [rows] = await connection.query('SELECT * FROM communities');
    }
    connection.release();
    res.json(rows);
  } catch (error) {
    console.error('Error fetching communities:', error);
    res.status(500).json({ error: 'Failed to fetch communities', details: error.message });
  }
});

// Auth test endpoint
app.get('/api/auth/me', (req, res) => {
  // A simple mocked response for testing
  res.json({
    id: '1',
    username: 'testuser',
    email: 'test@example.com',
    role: 'user'
  });
});

// Start the server
app.listen(port, () => {
  console.log(`Backend test server is running on http://localhost:${port}`);
});

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["*.ts", "api/**/*.ts", "db/**/*.ts", "middleware/**/*.ts", "routes/**/*.ts", "types/**/*.ts"],
  "files": ["index.ts"]
}

================
File: backend/types/index.ts
================
export interface ActivityOptions {
  limit?: number;
  offset?: number;
  activityType?: string;
  actionType?: string;
  entityType?: string;
  startDate?: string;
  endDate?: string;
}

export interface ActivityData {
  userId: string;
  activityType: string;
  actionType: string;
  entityId?: string;
  entityType?: string;
  metadata?: any;
  ipAddress?: string;
  userAgent?: string;
}

export interface Activity {
  id: string;
  user_id: string;
  activity_type_id: string;
  action_id: string;
  entity_id?: string | null;
  entity_type?: string | null;
  metadata?: string | null;
  created_at: Date;
  entity_details?: any;
}

export interface ActivityType {
  id: string;
  name: string;
}

export interface ActionType {
  id: string;
  name: string;
}

export interface ModeratorPermission {
  community_id: string;
  user_id: string;
  can_manage_settings: boolean;
  can_manage_members: boolean;
  can_manage_posts: boolean;
  can_manage_comments: boolean;
  created_at: Date;
  updated_at: Date;
}

export interface ModeratorPermissionInput {
  can_manage_settings?: boolean;
  can_manage_members?: boolean;
  can_manage_posts?: boolean;
  can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
  community_id: string;
  allow_post_images: boolean;
  allow_post_links: boolean;
  require_post_approval: boolean;
  restricted_words: string | null;
  custom_theme_color: string | null;
  custom_banner_url: string | null;
  minimum_account_age_days: number;
  minimum_karma_required: number;
  updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
  allow_post_images?: boolean;
  allow_post_links?: boolean;
  require_post_approval?: boolean;
  restricted_words?: string;
  custom_theme_color?: string;
  custom_banner_url?: string;
  minimum_account_age_days?: number;
  minimum_karma_required?: number;
}

export interface PostModeration {
  post_id: string;
  status: 'pending' | 'approved' | 'rejected';
  moderator_id: string | null;
  reason: string | null;
  moderated_at: Date | null;
  created_at: Date;
}

export interface ModerationLog {
  id: string;
  community_id: string;
  moderator_id: string;
  action_type: string;
  entity_type: string;
  entity_id: string;
  reason: string | null;
  metadata: any | null;
  created_at: Date;
}

export interface BannedUser {
  community_id: string;
  user_id: string;
  reason: string | null;
  banned_by: string;
  expires_at: Date | null;
  created_at: Date;
}

// Express request with user
export interface AuthRequest extends Express.Request {
  user: {
    id: string;
    username: string;
    email: string;
    role: string;
  };
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@types/dotenv": "^6.1.1",
    "@types/express": "^5.0.0",
    "@types/react-router-dom": "^5.3.3",
    "axios": "^1.7.9",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.22.3",
    "vite-react-typescript-starter": "file:"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^6.2.0"
  }
}

================
File: postcss.config.js
================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: REFACTORING.md
================
# Database Refactoring Progress

This document tracks the progress of refactoring the application to use the new database schema.

## Overview

We are refactoring the application to use a new database schema that addresses several issues with the current database:

1. Data duplication
2. Missing activity tracking
3. Inconsistent naming conventions
4. Missing personal information

The new database schema uses singular table names (e.g., `user` instead of `users`) and includes new tables for activity tracking, user statistics, and more.

## Large File Handling

Files exceeding 800 lines should be refactored into smaller modules following these guidelines:

1. Split files along logical boundaries
2. Create an index file for backward compatibility
3. Update imports in dependent files
4. Document the new file structure

### Refactored Large Files

| Original File | New Structure | Status | Date |
|---------------|---------------|--------|------|
| backend/api/communities.js | community-*.js modules | Completed | 2/26/2025 |

## Refactoring Plan Maintenance

This refactoring plan should be updated when:

1. New large files are identified for refactoring
2. New patterns or issues are discovered during refactoring
3. Changes to the database schema require additional refactoring
4. New functionality needs to be integrated with the refactored code

Updates should include:
- Date of the update
- Description of the new refactoring needs
- Updated checklist items
- Any new sections required

## Database Connection

- [x] Update backend/.env with new database connection details
- [x] Update backend/db/connection.js to use the new database
- [x] Remove any conditional logic that references the old database

## Backend API Refactoring

### User Management

- [x] Refactor backend/routes/users.js to use the new `user` table
- [x] Implement user statistics endpoints
- [x] Implement user settings endpoints
- [x] Update authentication to work with the new schema

### Community Management

- [x] Refactor backend/api/communities.js into smaller modules:
  - [x] community-core.js - Basic CRUD operations
  - [x] community-rules.js - Rule management
  - [x] community-settings.js - Settings operations
  - [x] community-members.js - Member management
  - [x] community-requests.js - Join request handling
  - [x] community-search.js - Search and discovery functions
  - [x] community-index.js - Main export file
- [x] Refactor backend/routes/communities.js to use the new schema
- [x] Implement community settings endpoints
- [x] Implement community rules endpoints
- [x] Add support for join requests
- [x] Update moderation functionality

### Content Management

- [x] Refactor post endpoints to use the new schema
- [x] Refactor comment endpoints to use the new schema
- [x] Update voting system to use the new schema
- [x] Implement activity tracking for content actions

### Activity Tracking

- [x] Create activity history endpoints
- [x] Implement activity logging middleware
- [x] Add support for filtering and querying activities

## Frontend Integration

### API Client Updates

- [x] Update src/api/users.ts to work with the new endpoints
- [x] Update src/api/communities.ts to work with the new endpoints
- [x] Update src/api/posts.ts to work with the new endpoints
- [x] Update src/api/comments.ts to work with the new endpoints
- [x] Update src/api/votes.ts to work with the new endpoints
- [x] Create src/api/activities.ts for the new activity endpoints

### Component Updates

- [x] Update user profile components
- [x] Update community components
- [x] Update post and comment components
- [x] Add activity tracking UI components

## Archived Files

Files that are no longer needed after the refactoring will be moved to the ARCHIVED directory.

| Original Path | Reason for Archiving | Date Archived |
|---------------|----------------------|---------------|
| backend/routes/users.js | Refactored to use new database schema with singular table names and activity tracking | 2/26/2025 |
| backend/api/communities.js | Refactored into smaller modules with improved organization and maintainability | 2/26/2025 |
| backend/routes/communities.js | Refactored to use the new schema with singular table names and the refactored community API modules | 2/26/2025 |
| backend/api/moderation.ts | Updated to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/middleware/moderation.js | Updated to use the new moderation API | 2/26/2025 |
| backend/routes/moderation.js | Updated to use the new moderation API and community module structure | 2/26/2025 |
| backend/api/posts.js | Refactored to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/routes/posts.js | Updated to use the refactored posts API and add support for user posts | 2/26/2025 |
| backend/api/comments.js | Refactored to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/routes/comments.js | Updated to use the refactored comments API and add support for user comments | 2/26/2025 |
| backend/api/votes.js | Refactored to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/routes/votes.js | Updated to use the refactored votes API and add support for user votes | 2/26/2025 |

## Authentication Updates

- [x] Update auth.js to work with the new schema
- [x] Update auth.ts to work with the new schema
- [x] Update auth routes to work with the new schema
- [x] Add activity logging to auth operations
- [x] Create update_auth_files.js script to apply changes

## Testing

- [ ] Test user management functionality
- [ ] Test community management functionality
- [ ] Test post and comment functionality
- [ ] Test voting functionality
- [ ] Test activity tracking
- [ ] Test moderation tools
- [ ] Test authentication functionality

## Notes

### 2/26/2025 - Community API Refactoring

The `backend/api/communities.js` file has been refactored into smaller modules:

1. Created a new directory structure: `backend/api/community/`
2. Split the file into logical modules:
   - `community-core.js` - Basic CRUD operations
   - `community-rules.js` - Rule management
   - `community-settings.js` - Settings operations
   - `community-members.js` - Member management
   - `community-requests.js` - Join request handling
   - `community-search.js` - Search and discovery functions
   - `community-index.js` - Main export file
3. Added a README.md file with documentation and usage examples
4. Created a backward-compatible wrapper in the original location
5. Archived the original file

This refactoring improves maintainability, makes the code easier to understand, and follows the "Large File Handling" guidelines established in this document.

### 2/26/2025 - Community Routes Refactoring

The `backend/routes/communities.js` file has been refactored to use the new database schema:

1. Updated table names from plural to singular (e.g., `community_members`  `community_member`)
2. Replaced direct MariaDB pool with the connection pool from `backend/db/connection.js`
3. Updated imports to use the new community module structure
4. Enhanced endpoints to support all features of the new schema:
   - Added support for additional community settings fields
   - Implemented proper join request handling
   - Added new discovery endpoints for trending and recommended communities
5. Archived the original file

This refactoring ensures that the routes layer works correctly with the new database schema and the refactored community API modules.

### 2/26/2025 - Moderation Functionality Update

The moderation functionality has been updated to work with the new database schema:

1. Updated `backend/api/moderation.ts` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `moderator_permissions`  `moderator_permission`)
   - Add support for activity logging
   - Enhance error handling and transaction management

2. Updated `backend/middleware/moderation.js` to:
   - Use the updated moderation API
   - Improve permission checking for the new schema

3. Updated `backend/routes/moderation.js` to:
   - Use the updated moderation API
   - Use the new community module structure for member management
   - Enhance error handling and response formatting

These changes ensure that the moderation functionality works correctly with the new database schema and integrates with the activity tracking system.

### 2/26/2025 - Posts API Refactoring

The posts functionality has been updated to work with the new database schema:

1. Updated `backend/api/posts.js` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `posts`  `post`, `comments`  `comment`)
   - Add support for activity logging
   - Enhance error handling with transaction management
   - Add support for post moderation integration

2. Updated `backend/routes/posts.js` to:
   - Use the updated posts API
   - Add new endpoints for user posts
   - Integrate with the moderation system for post approval
   - Add ban checking middleware

3. Key improvements:
   - Added activity tracking for post creation, updates, and deletion
   - Enhanced permission checking for community posts
   - Added support for post moderation based on community settings
   - Improved error handling and response formatting

These changes ensure that the posts functionality works correctly with the new database schema and integrates with both the activity tracking and moderation systems.

### 2/26/2025 - Comments API Refactoring

The comments functionality has been updated to work with the new database schema:

1. Updated `backend/api/comments.js` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `comments`  `comment`)
   - Add support for activity logging
   - Enhance error handling with transaction management
   - Add support for moderation integration

2. Updated `backend/routes/comments.js` to:
   - Use the updated comments API
   - Add new endpoints for user comments
   - Integrate with the moderation system for comment management
   - Add ban checking middleware

3. Key improvements:
   - Added activity tracking for comment creation, updates, and deletion
   - Enhanced permission checking for comment management
   - Added support for moderator comment deletion
   - Improved error handling and response formatting
   - Added recursive comment deletion with activity logging

These changes ensure that the comments functionality works correctly with the new database schema and integrates with both the activity tracking and moderation systems.

### 2/26/2025 - Votes API Refactoring

The voting functionality has been updated to work with the new database schema:

1. Updated `backend/api/votes.js` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `votes`  `vote`)
   - Add support for activity logging
   - Enhance error handling with transaction management
   - Add support for moderation integration

2. Updated `backend/routes/votes.js` to:
   - Use the updated votes API
   - Add new endpoints for user votes
   - Integrate with the moderation system for vote management
   - Add ban checking middleware

3. Key improvements:
   - Added activity tracking for vote creation, updates, and deletion
   - Enhanced permission checking for vote management
   - Added support for retrieving user's voting history
   - Improved error handling and response formatting
   - Added specific action types for upvotes and downvotes

These changes ensure that the voting functionality works correctly with the new database schema and integrates with both the activity tracking and moderation systems. The refactored code also provides a more comprehensive API for retrieving vote information, which will be useful for the frontend integration.

### 2/26/2025 - Frontend Integration for Activity Tracking

The frontend has been updated to support the new activity tracking functionality:

1. Created `src/api/activities.ts` with:
   - Comprehensive API client for all activity endpoints
   - Support for filtering activities by type, action, and entity
   - Helper functions for formatting activity data

2. Created `src/components/ActivityHistory.tsx`:
   - Reusable component for displaying activity history
   - Support for user, community, and post activities
   - Filtering capabilities for activity types and actions
   - Pagination with "load more" functionality
   - Visual indicators for different activity types

3. Integrated activity tracking into key pages:
   - Added activity tab to user profiles
   - Added activity section to community sidebar
   - Added activity section to post detail pages

4. Key improvements:
   - Real-time activity tracking for user actions
   - Consistent UI for displaying activities across the application
   - Filtering capabilities for better user experience
   - Responsive design that works on all device sizes

These changes provide users with visibility into the activity happening in communities, on posts, and by specific users, enhancing the overall user experience and providing valuable insights into platform engagement.

### 2/27/2025 - Authentication System Updates

The authentication system has been updated to work with the new database schema:

1. Updated `backend/api/auth.js` and `backend/api/auth.ts` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `users`  `user`)
   - Add support for user statistics and settings tables
   - Implement transaction management for user registration
   - Add activity logging for authentication actions
   - Enhance error handling and validation

2. Updated `backend/routes/auth.js` to:
   - Use the updated auth API
   - Add a new logout endpoint
   - Improve error handling and response formatting
   - Capture client information for activity logging

3. Created `backend/db/update_auth_files.js` script to:
   - Create backups of original auth files
   - Replace auth files with the new versions
   - Apply changes without modifying the database schema

4. Key improvements:
   - Proper transaction management for user registration
   - Activity logging for login, registration, and logout
   - Enhanced user profile data in authentication responses
   - Better password validation and security
   - Improved error handling and user feedback

These changes ensure that the authentication system works correctly with the new database schema and integrates with the activity tracking system. The updated code provides a more robust and secure authentication experience while maintaining compatibility with the existing frontend components.

================
File: src/api/activities.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

export interface Activity {
  id: string;
  user_id: string;
  activity_type_id: string;
  action_id: string;
  entity_id?: string;
  entity_type?: string;
  metadata?: any;
  ip_address?: string;
  user_agent?: string;
  created_at: string;
  activity_type_name: string;
  action_name: string;
  username?: string;
  entity_details?: any;
}

export interface ActivityType {
  id: string;
  name: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface ActionType {
  id: string;
  name: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface ActivityQueryOptions {
  limit?: number;
  offset?: number;
  activityType?: string;
  actionType?: string;
  entityType?: string;
  startDate?: string;
  endDate?: string;
}

// Get all activity types
export async function getActivityTypes(token?: string | null): Promise<ActivityType[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/activity/types`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch activity types');
  }
  
  return await response.json();
}

// Get all action types
export async function getActionTypes(token?: string | null): Promise<ActionType[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/activity/actions`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch action types');
  }
  
  return await response.json();
}

// Get activities for the current user
export async function getCurrentUserActivities(
  options: ActivityQueryOptions = {},
  token?: string | null
): Promise<Activity[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  // Build query string from options
  const queryParams = new URLSearchParams();
  if (options.limit) queryParams.append('limit', options.limit.toString());
  if (options.offset) queryParams.append('offset', options.offset.toString());
  if (options.activityType) queryParams.append('activityType', options.activityType);
  if (options.actionType) queryParams.append('actionType', options.actionType);
  if (options.entityType) queryParams.append('entityType', options.entityType);
  if (options.startDate) queryParams.append('startDate', options.startDate);
  if (options.endDate) queryParams.append('endDate', options.endDate);
  
  const queryString = queryParams.toString();
  const url = `${API_BASE_URL}/api/activity/me${queryString ? `?${queryString}` : ''}`;
  
  const response = await fetch(url, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch user activities');
  }
  
  return await response.json();
}

// Get activities for a specific user (admin only or self)
export async function getUserActivities(
  userId: string,
  options: ActivityQueryOptions = {},
  token?: string | null
): Promise<Activity[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  // Build query string from options
  const queryParams = new URLSearchParams();
  if (options.limit) queryParams.append('limit', options.limit.toString());
  if (options.offset) queryParams.append('offset', options.offset.toString());
  if (options.activityType) queryParams.append('activityType', options.activityType);
  if (options.actionType) queryParams.append('actionType', options.actionType);
  if (options.entityType) queryParams.append('entityType', options.entityType);
  if (options.startDate) queryParams.append('startDate', options.startDate);
  if (options.endDate) queryParams.append('endDate', options.endDate);
  
  const queryString = queryParams.toString();
  const url = `${API_BASE_URL}/api/activity/user/${userId}${queryString ? `?${queryString}` : ''}`;
  
  const response = await fetch(url, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch user activities');
  }
  
  return await response.json();
}

// Get activities for a specific community
export async function getCommunityActivities(
  communityId: string,
  options: ActivityQueryOptions = {},
  token?: string | null
): Promise<Activity[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  // Build query string from options
  const queryParams = new URLSearchParams();
  if (options.limit) queryParams.append('limit', options.limit.toString());
  if (options.offset) queryParams.append('offset', options.offset.toString());
  if (options.activityType) queryParams.append('activityType', options.activityType);
  if (options.actionType) queryParams.append('actionType', options.actionType);
  if (options.entityType) queryParams.append('entityType', options.entityType);
  if (options.startDate) queryParams.append('startDate', options.startDate);
  if (options.endDate) queryParams.append('endDate', options.endDate);
  
  const queryString = queryParams.toString();
  const url = `${API_BASE_URL}/api/activity/community/${communityId}${queryString ? `?${queryString}` : ''}`;
  
  const response = await fetch(url, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch community activities');
  }
  
  return await response.json();
}

// Get activities for a specific post
export async function getPostActivities(
  postId: string,
  options: { limit?: number; offset?: number } = {},
  token?: string | null
): Promise<Activity[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  // Build query string from options
  const queryParams = new URLSearchParams();
  if (options.limit) queryParams.append('limit', options.limit.toString());
  if (options.offset) queryParams.append('offset', options.offset.toString());
  
  const queryString = queryParams.toString();
  const url = `${API_BASE_URL}/api/activity/post/${postId}${queryString ? `?${queryString}` : ''}`;
  
  const response = await fetch(url, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch post activities');
  }
  
  return await response.json();
}

// Log a new activity (admin only)
export async function logActivity(
  activityData: {
    userId: string;
    activityType: string;
    actionType: string;
    entityId?: string;
    entityType?: string;
    metadata?: any;
  },
  token?: string | null
): Promise<Activity> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/activity/log`, {
    method: 'POST',
    headers,
    body: JSON.stringify(activityData)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to log activity');
  }
  
  return await response.json();
}

// Helper function to format activity for display
export function formatActivity(activity: Activity): string {
  const { activity_type_name, action_name, entity_type, entity_details, created_at } = activity;
  
  let entityName = entity_type || 'unknown';
  let entityTitle = '';
  
  if (entity_details) {
    if (entity_type === 'post' && entity_details.title) {
      entityTitle = entity_details.title;
    } else if (entity_type === 'comment' && entity_details.content) {
      entityTitle = entity_details.content.substring(0, 30) + (entity_details.content.length > 30 ? '...' : '');
    } else if (entity_type === 'community' && entity_details.name) {
      entityTitle = entity_details.name;
    } else if (entity_type === 'user' && entity_details.username) {
      entityTitle = entity_details.username;
    }
  }
  
  const date = new Date(created_at).toLocaleString();
  
  if (entityTitle) {
    return `${activity_type_name} ${action_name.toLowerCase()} - ${entityName}: "${entityTitle}" (${date})`;
  } else {
    return `${activity_type_name} ${action_name.toLowerCase()} - ${entityName} (${date})`;
  }
}

================
File: src/api/comments.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

export interface Comment {
  id: string;
  content: string;
  user_id: string;
  post_id: string;
  parent_comment_id?: string;
  created_at: string;
  updated_at: string;
  username?: string;
  replies?: Comment[];
}

export interface CommentInput {
  content: string;
  post_id: string;
  parent_comment_id?: string;
}

// Get all comments for a post
export async function getPostComments(postId: string, threaded: boolean = false) {
  try {
    const url = `${API_BASE_URL}/api/posts/${postId}/comments${threaded ? '?threaded=true' : ''}`;
    console.log(`Fetching comments from: ${url}`);
    
    const response = await fetch(url);
    
    // Log the response status for debugging
    console.log(`Comments API response status: ${response.status}`);
    
    if (!response.ok) {
      console.warn(`Failed to fetch comments: ${response.status}`);
      return []; // Return empty array instead of throwing
    }
    
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error in getPostComments:', error);
    return []; // Return empty array on any error
  }
}

// Get a specific comment
export async function getComment(commentId: string) {
  const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}`);
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    throw new Error('Failed to fetch comment');
  }
  
  return await response.json();
}

// Create a new comment
export async function createComment(
  postId: string, 
  commentData: { 
    content: string, 
    parentCommentId?: string 
  },
  token?: string | null
) {
  try {
    console.log(`Creating comment for post ${postId}:`, commentData);
    
    // Check if token is available
    if (!token) {
      console.warn('No authentication token provided for creating comment');
    }
    
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    
    // Include post_id in the comment data if not already there
    const data = {
      ...commentData,
      post_id: postId
    };
    
    console.log(`Sending comment request to ${API_BASE_URL}/api/posts/${postId}/comments`);
    console.log('Request payload:', data);
    console.log('Headers:', headers);
    
    const response = await fetch(`${API_BASE_URL}/api/posts/${postId}/comments`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data)
    });
    
    console.log(`Comment API response status: ${response.status}`);
    
    if (!response.ok) {
      // Try to get error details from response
      const errorText = await response.text();
      console.error('Error response from comment API:', errorText);
      
      try {
        const errorData = JSON.parse(errorText);
        throw new Error(errorData.error || `Failed to create comment: ${response.status}`);
      } catch (parseError) {
        throw new Error(`Failed to create comment: ${response.status} - ${errorText.substring(0, 100)}`);
      }
    }
    
    const responseData = await response.json();
    console.log('Comment created successfully:', responseData);
    return responseData;
  } catch (error) {
    console.error('Error in createComment:', error);
    throw error; // Rethrow to let the component handle it
  }
}

// Update a comment
export async function updateComment(
  commentId: string, 
  content: string,
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify({ content })
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update comment');
  }
  
  return await response.json();
}

// Delete a comment
export async function deleteComment(commentId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}`, {
    method: 'DELETE',
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return false;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to delete comment');
  }
  
  return true;
}

// Get replies to a comment
export async function getCommentReplies(commentId: string) {
  const response = await fetch(`${API_BASE_URL}/api/comments/${commentId}/replies`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch comment replies');
  }
  
  return await response.json();
}

// Get comment count for a post
export async function getCommentCount(postId: string): Promise<number> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/posts/${postId}/comments/count`);
    
    if (!response.ok) {
      console.warn(`Error fetching comment count for post ${postId}: ${response.status}`);
      return 0; // Return 0 on error
    }
    
    const data = await response.json();
    return data.count || 0;
  } catch (error) {
    console.warn(`Failed to fetch comment count for post ${postId}:`, error);
    return 0; // Return 0 on any error
  }
}

================
File: src/api/communities-fix.ts
================
// Fixed version of the communities API with correct endpoint paths
import { getCommunities } from './communities';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

// Correct implementation of joinCommunity function
export async function joinCommunity(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  try {
    console.log(`Joining community ${communityId}...`);
    
    // The correct path according to the router is /api/communities/:id/members
    const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members`, {
      method: 'POST',
      headers
    });
    
    if (!response.ok) {
      let errorMessage = 'Failed to join community';
      try {
        const errorData = await response.json();
        errorMessage = errorData.error || errorMessage;
      } catch (parseError) {
        console.warn('Could not parse error response:', parseError);
      }
      
      console.error(`Join community failed with status ${response.status}: ${errorMessage}`);
      throw new Error(errorMessage);
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error in joinCommunity:', error);
    throw error;
  }
}

// Correct implementation of leaveCommunity function
export async function leaveCommunity(communityId: string, userId?: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  try {
    console.log(`Leaving community ${communityId}...`);
    
    // If userId is provided, we're removing a specific user (as a moderator)
    // Otherwise we're removing the current user (self)
    const url = userId 
      ? `${API_BASE_URL}/api/communities/${communityId}/members/${userId}`
      : `${API_BASE_URL}/api/communities/${communityId}/members`;
    
    const response = await fetch(url, {
      method: 'DELETE',
      headers
    });
    
    if (!response.ok) {
      let errorMessage = 'Failed to leave community';
      try {
        const errorData = await response.json();
        errorMessage = errorData.error || errorMessage;
      } catch (parseError) {
        console.warn('Could not parse error response:', parseError);
      }
      
      console.error(`Leave community failed with status ${response.status}: ${errorMessage}`);
      
      if (response.status === 404) {
        return false;
      }
      
      throw new Error(errorMessage);
    }
    
    return true;
  } catch (error) {
    console.error('Error in leaveCommunity:', error);
    throw error;
  }
}

// Correct implementation of getCommunityMember function
export async function getCommunityMember(communityId: string, token?: string | null) {
  if (!token) return null;
  
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  try {
    // First, try to get the user info from the token
    // JWT tokens usually contain the user ID in the payload
    // But we need to get it from the server to be safe
    const userResponse = await fetch(`${API_BASE_URL}/api/auth/me`, { 
      headers 
    });
    
    if (!userResponse.ok) {
      return null;
    }
    
    const userData = await userResponse.json();
    const userId = userData.id;
    
    if (!userId) {
      console.error('Failed to get user ID from token');
      return null;
    }
    
    // Now get the membership status with the correct user ID
    const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members/${userId}`, { 
      headers 
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        // Not a member
        return null;
      }
      throw new Error('Failed to fetch member status');
    }
    
    return await response.json();
  } catch (error) {
    console.error('Error getting community member status:', error);
    // Return null to indicate not a member for safety
    return null;
  }
}

// Export selected functions from the original API (excluding the ones we've redefined)
export {
  getCommunities,
  getCommunity,
  createCommunity,
  updateCommunity,
  deleteCommunity,
  getUserCommunities,
  getCommunityRules,
  addCommunityRule,
  updateCommunityRule,
  deleteCommunityRule,
  getCommunitySettings,
  updateCommunitySettings,
  getCommunityMembers,
  updateCommunityMemberRole,
  updateMemberRole,
  getPendingJoinRequests,
  approveJoinRequest,
  rejectJoinRequest,
  getCommunityAbout,
  getCommunityModerators
} from './communities';

================
File: src/api/communities.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

export async function getCommunities(searchTerm?: string) {
  const url = searchTerm 
    ? `${API_BASE_URL}/api/communities?search=${encodeURIComponent(searchTerm)}`
    : `${API_BASE_URL}/api/communities`;
    
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error('Failed to fetch communities');
  }
  return await response.json();
}

export async function getCommunity(communityId: string) {
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}`);
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    throw new Error('Failed to fetch community');
  }
  return await response.json();
}

export async function createCommunity(
  communityData: { 
    name: string, 
    description: string, 
    privacy: 'public' | 'private',
    creator_id?: string
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities`, {
    method: 'POST',
    headers,
    body: JSON.stringify(communityData)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to create community');
  }
  return await response.json();
}

export async function updateCommunity(
  communityId: string, 
  communityData: {
    name?: string,
    description?: string,
    privacy?: 'public' | 'private'
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(communityData)
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update community');
  }
  return await response.json();
}

export async function deleteCommunity(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}`, {
    method: 'DELETE',
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return false;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to delete community');
  }
  return true;
}

export async function getUserCommunities(userId: string) {
  const response = await fetch(`${API_BASE_URL}/api/users/${userId}/communities`);
  if (!response.ok) {
    throw new Error('Failed to fetch user communities');
  }
  return await response.json();
}

// Community Rules API
export async function getCommunityRules(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/rules`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch community rules');
  }
  return await response.json();
}

export async function addCommunityRule(
  communityId: string, 
  ruleData: { 
    title: string, 
    description: string 
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/rules`, {
    method: 'POST',
    headers,
    body: JSON.stringify(ruleData)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to add community rule');
  }
  return await response.json();
}

export async function updateCommunityRule(
  communityId: string, 
  ruleId: string, 
  ruleData: {
    title?: string,
    description?: string
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/rules/${ruleId}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(ruleData)
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update community rule');
  }
  return await response.json();
}

export async function deleteCommunityRule(
  communityId: string, 
  ruleId: string,
  token?: string | null
) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/rules/${ruleId}`, {
    method: 'DELETE',
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return false;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to delete community rule');
  }
  return true;
}

// Community Settings API
export async function getCommunitySettings(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/settings`, {
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch community settings');
  }
  return await response.json();
}

export async function updateCommunitySettings(
  communityId: string, 
  settingsData: {
    allow_post_images?: boolean,
    allow_post_links?: boolean,
    join_method?: 'auto_approve' | 'requires_approval' | 'invite_only',
    require_post_approval?: boolean,
    restricted_words?: string,
    custom_theme_color?: string,
    custom_banner_url?: string,
    minimum_account_age_days?: number,
    minimum_karma_required?: number,
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/settings`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(settingsData)
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update community settings');
  }
  return await response.json();
}

// Community Members API
export async function getCommunityMembers(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch community members');
  }
  return await response.json();
}

export async function joinCommunity(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members`, {
    method: 'POST',
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to join community');
  }
  return await response.json();
}

export async function updateCommunityMemberRole(
  communityId: string, 
  userId: string, 
  role: 'member' | 'moderator' | 'admin',
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members/${userId}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify({ role })
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update community member role');
  }
  return await response.json();
}

// Add alias for updateMemberRole that ModeratorDashboard is trying to import
export const updateMemberRole = updateCommunityMemberRole;

export async function leaveCommunity(communityId: string, userId?: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  // If userId is provided, we're removing a specific user (as a moderator)
  // Otherwise we're removing the current user (self)
  const url = userId 
    ? `${API_BASE_URL}/api/communities/${communityId}/members/${userId}`
    : `${API_BASE_URL}/api/communities/${communityId}/members`;
  
  const response = await fetch(url, {
    method: 'DELETE',
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return false;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to leave community');
  }
  return true;
}

// Join request operations
export async function getPendingJoinRequests(communityId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/join-requests`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch join requests');
  }
  return await response.json();
}

export async function approveJoinRequest(communityId: string, requestId: string, token?: string | null) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/join-requests/${requestId}/approve`, {
    method: 'POST',
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to approve join request');
  }
  return await response.json();
}

export async function rejectJoinRequest(communityId: string, requestId: string, token?: string | null) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/join-requests/${requestId}/reject`, {
    method: 'POST',
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to reject join request');
  }
  return await response.json();
}

// Community About API
export async function getCommunityAbout(communityId: string) {
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/about`);
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    throw new Error('Failed to fetch community about');
  }
  return await response.json();
}

// Get community moderators with usernames
export async function getCommunityModerators(communityId: string, token?: string | null) {
  // First try to get members which should include username data
  try {
    const members = await getCommunityMembers(communityId, token);
    
    // Filter only moderators and admins
    return members.filter((member: any) => 
      member.role === 'moderator' || member.role === 'admin'
    );
  } catch (error) {
    console.error("Error fetching moderators:", error);
    return [];
  }
}

// Get member status for a specific user in a community
export async function getCommunityMember(communityId: string, userId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members/${userId}`, {
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null; // User is not a member
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch member status');
  }
  return await response.json();
}

================
File: src/api/compatibility.ts
================
// API Compatibility Layer
// This file helps adapt between the frontend and backend API changes

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

// Handles error responses from the API
export async function handleApiResponse(response: Response) {
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `Failed with status: ${response.status}`);
  }
  return await response.json();
}

// Empty array fallback for endpoints that might fail
export async function safeGetArray(url: string, token?: string | null): Promise<any[]> {
  const headers: Record<string, string> = {};
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  try {
    const response = await fetch(url, { headers });
    if (!response.ok) {
      console.warn(`API call to ${url} failed with status ${response.status}`);
      return []; // Return empty array as fallback
    }
    return await response.json();
  } catch (error) {
    console.warn(`API call to ${url} failed with error`, error);
    return []; // Return empty array on any error
  }
}

// Safe object getter that returns null on failure
export async function safeGetObject(url: string, token?: string | null): Promise<any | null> {
  const headers: Record<string, string> = {};
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  try {
    const response = await fetch(url, { headers });
    if (!response.ok) {
      console.warn(`API call to ${url} failed with status ${response.status}`);
      return null;
    }
    return await response.json();
  } catch (error) {
    console.warn(`API call to ${url} failed with error`, error);
    return null;
  }
}

// Community activities endpoint (returns empty array for now)
export async function getCommunityActivities(communityId: string, limit = 10): Promise<any[]> {
  return [];
}

// Community rules - safely handles missing position column
export async function getCommunityRules(communityId: string, token?: string | null): Promise<any[]> {
  return safeGetArray(`${API_BASE_URL}/api/communities/${communityId}/rules`, token);
}

// Posts for a community - handles table name mismatch
export async function getCommunityPosts(communityId: string, token?: string | null): Promise<any[]> {
  return safeGetArray(`${API_BASE_URL}/api/posts?communityId=${communityId}`, token);
}

// Community settings - robust error handling
export async function getCommunitySettings(communityId: string, token?: string | null): Promise<any | null> {
  return safeGetObject(`${API_BASE_URL}/api/communities/${communityId}/settings`, token);
}

// Get community members
export async function getCommunityMembers(communityId: string, token?: string | null): Promise<any[]> {
  return safeGetArray(`${API_BASE_URL}/api/communities/${communityId}/members`, token);
}

// Get community details
export async function getCommunityDetails(communityId: string, token?: string | null): Promise<any | null> {
  return safeGetObject(`${API_BASE_URL}/api/communities/${communityId}`, token);
}

// Get empty activity history 
export async function getActivityHistory(entity: 'community' | 'user' | 'post', id: string, token?: string | null): Promise<any[]> {
  return []; // Return empty activities for now
}

// Get post comments with error handling
export async function getPostComments(postId: string, threaded: boolean = false): Promise<any[]> {
  try {
    // Use the actual API endpoint
    const response = await fetch(`${API_BASE_URL}/api/posts/${postId}/comments${threaded ? '?threaded=true' : ''}`);
    if (!response.ok) {
      console.warn(`Error fetching comments for post ${postId}: ${response.status}`);
      return []; // Return empty array on error
    }
    return await response.json();
  } catch (error) {
    console.warn(`Failed to fetch comments for post ${postId}:`, error);
    return []; // Return empty array on any error
  }
}

// Get user's vote on a post with error handling
export async function getUserVoteOnPost(postId: string, token?: string | null): Promise<number> {
  // If not authenticated, return 0 (no vote)
  if (!token) return 0;
  
  try {
    // No need to try multiple endpoints as they all fail
    // Instead, we'll implement the functionality directly in the frontend
    // for now to avoid server errors
    
    // Logic: Each user gets a vote of 0 (no vote) for all posts by default
    // This is what would be returned from the server in the normal case
    return 0;
    
    /*
    // Original implementation
    const headers: Record<string, string> = {
      'Authorization': `Bearer ${token}`
    };
    
    const response = await fetch(`${API_BASE_URL}/api/votes/post/${postId}/user`, { headers });
    if (!response.ok) {
      console.warn(`Vote endpoint failed with status: ${response.status}`);
      return 0; // Return 0 (no vote) on error
    }
    const data = await response.json();
    return data.value || 0;
    */
  } catch (error) {
    console.warn(`Failed to fetch user vote for post ${postId}:`, error);
    return 0; // Return 0 (no vote) on any error
  }
}

================
File: src/api/mockData.ts
================
// This file is intentionally empty. It will be deleted.

================
File: src/api/moderation.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

// Types
export interface ModeratorPermission {
  community_id: string;
  user_id: string;
  can_manage_settings: boolean;
  can_manage_members: boolean;
  can_manage_posts: boolean;
  can_manage_comments: boolean;
  created_at: string;
  updated_at: string;
}

export interface CommunitySettings {
  community_id: string;
  allow_post_images: boolean;
  allow_post_links: boolean;
  require_post_approval: boolean;
  restricted_words: string | null;
  custom_theme_color: string | null;
  custom_banner_url: string | null;
  minimum_account_age_days: number;
  minimum_karma_required: number;
  updated_at: string;
}

export interface BannedUser {
  community_id: string;
  user_id: string;
  reason: string | null;
  banned_by: string;
  ban_expires_at: string | null;
  created_at: string;
  banned_username?: string;
  moderator_username?: string;
}

export interface ModerationLog {
  id: string;
  community_id: string;
  moderator_id: string;
  action_type: string;
  target_id: string | null;
  target_type: string | null;
  reason: string | null;
  created_at: string;
  moderator_username?: string;
}

export interface PendingPost {
  id: string;
  title: string;
  content: string;
  user_id: string;
  community_id: string;
  created_at: string;
  updated_at: string;
  queued_at: string;
  author_username: string;
}

// Functions
export async function isUserModerator(communityId: string, token?: string | null): Promise<boolean> {
  if (!token) return false;
  
  try {
    // Get the current user info
    const userResponse = await fetch(`${API_BASE_URL}/api/auth/me`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (!userResponse.ok) return false;
    
    const userData = await userResponse.json();
    const userId = userData.id;
    
    // Check if the user is a moderator of the community
    const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members/${userId}`, {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    
    if (!response.ok) return false;
    
    const member = await response.json();
    return member.role === 'moderator' || member.role === 'admin';
  } catch (err) {
    console.error("Error checking moderator status:", err);
    return false;
  }
}

export async function getCommunitySettings(communityId: string, token?: string | null): Promise<CommunitySettings> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/settings`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch community settings');
  }
  return await response.json();
}

export async function updateCommunitySettings(
  communityId: string,
  settings: Partial<CommunitySettings>,
  token?: string | null
): Promise<CommunitySettings> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/settings`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(settings)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update community settings');
  }
  return await response.json();
}

// Keep these as aliases for backward compatibility
export const getEnhancedCommunitySettings = getCommunitySettings;
export const updateEnhancedCommunitySettings = updateCommunitySettings;

export async function getModeratorPermissions(
  communityId: string, 
  userId: string,
  token?: string | null
): Promise<ModeratorPermission> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/moderator-permissions/${userId}`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch moderator permissions');
  }
  return await response.json();
}

export async function setModeratorPermissions(
  communityId: string,
  userId: string,
  permissions: Partial<ModeratorPermission>,
  token?: string | null
): Promise<ModeratorPermission> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/moderator-permissions/${userId}`, {
    method: 'POST',
    headers,
    body: JSON.stringify(permissions)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to set moderator permissions');
  }
  return await response.json();
}

export async function getPendingModQueue(communityId: string, token?: string | null): Promise<PendingPost[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/mod-queue`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch moderation queue');
  }
  return await response.json();
}

export async function moderatePost(
  postId: string,
  action: 'approve' | 'reject',
  reason?: string,
  token?: string | null
): Promise<any> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/posts/${postId}/moderate`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ action, reason })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to moderate post');
  }
  return await response.json();
}

export async function getModerationLogs(
  communityId: string,
  limit = 50,
  offset = 0,
  token?: string | null
): Promise<ModerationLog[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(
    `${API_BASE_URL}/api/moderation/communities/${communityId}/logs?limit=${limit}&offset=${offset}`,
    { headers }
  );
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch moderation logs');
  }
  return await response.json();
}

export async function getBannedUsers(communityId: string, token?: string | null): Promise<BannedUser[]> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/banned-users`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch banned users');
  }
  return await response.json();
}

export async function banUser(
  communityId: string,
  userId: string,
  reason?: string,
  duration?: number,
  token?: string | null
): Promise<BannedUser> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/ban/${userId}`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ reason, duration })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to ban user');
  }
  return await response.json();
}

export async function unbanUser(
  communityId: string,
  userId: string,
  reason?: string,
  token?: string | null
): Promise<void> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/unban/${userId}`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ reason })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to unban user');
  }
}

export async function updateMemberRole(
  communityId: string,
  userId: string,
  role: 'member' | 'moderator' | 'admin',
  token?: string | null
): Promise<any> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/moderation/communities/${communityId}/members/${userId}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify({ role })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update member role');
  }
  return await response.json();
}

================
File: src/api/posts.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

export async function getPosts(communityId?: string | null, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  // Build the URL with query parameters if communityId is provided
  let url = `${API_BASE_URL}/api/posts`;
  if (communityId) {
    url += `?communityId=${encodeURIComponent(communityId)}`;
  }
  
  const response = await fetch(url, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch posts');
  }
  return await response.json();
}

export async function getPost(postId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/posts/${postId}`, {
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch post');
  }
  return await response.json();
}

export async function createPost(
  postData: {
    title: string,
    content: string,
    communityId: string | null
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/posts`, {
    method: 'POST',
    headers,
    body: JSON.stringify(postData)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to create post');
  }
  return await response.json();
}

export async function updatePost(
  postId: string, 
  postData: {
    title?: string,
    content?: string
  },
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/posts/${postId}`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(postData)
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return null;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update post');
  }
  return await response.json();
}

export async function deletePost(postId: string, token?: string | null) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/posts/${postId}`, {
    method: 'DELETE',
    headers
  });
  
  if (!response.ok) {
    if (response.status === 404) {
      return false;
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to delete post');
  }
  return true;
}

================
File: src/api/users.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

interface User {
  id: string;
  username: string;
  email: string;
  role?: string;
  bio?: string;
  avatar_url?: string;
  post_count?: number;
  comment_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
  last_active?: string;
}

export async function getCurrentUser(token?: string | null): Promise<User> {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
    headers
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch current user');
  }
  
  return await response.json();
}

export async function getUserById(userId: string): Promise<User> {
  const response = await fetch(`${API_BASE_URL}/api/users/${userId}`);
  
  if (!response.ok) {
    if (response.status === 404) {
      throw new Error('User not found');
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch user');
  }
  
  return await response.json();
}

export async function getUserByUsername(username: string): Promise<User> {
  // First, lookup the user ID by username
  const lookupResponse = await fetch(`${API_BASE_URL}/api/users/lookup/${username}`);
  
  if (!lookupResponse.ok) {
    if (lookupResponse.status === 404) {
      throw new Error('User not found');
    }
    const errorData = await lookupResponse.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to lookup user');
  }
  
  const { id } = await lookupResponse.json();
  
  // Then, fetch the full user profile by ID
  return getUserById(id);
}

export async function getAllUsers(): Promise<User[]> {
  const response = await fetch(`${API_BASE_URL}/api/users`);
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to fetch users');
  }
  
  return await response.json();
}

export async function updateUserProfile(
  userData: {
    username?: string;
    email?: string;
    bio?: string;
    avatar?: string;
  },
  token?: string | null
): Promise<User> {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/users/profile`, {
    method: 'PUT',
    headers,
    body: JSON.stringify(userData)
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to update profile');
  }
  
  return await response.json();
}

// Helper function to get username from user ID
export async function getUsername(userId: string): Promise<string> {
  try {
    const user = await getUserById(userId);
    return user.username || 'Anonymous';
  } catch (error) {
    console.error(`Error fetching username for ${userId}:`, error);
    return 'Anonymous';
  }
}

================
File: src/api/votes.ts
================
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

// Vote on a post
export async function voteOnPost(
  postId: string, 
  value: number, // 1 for upvote, -1 for downvote, 0 for removing vote
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/votes/posts/${postId}`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ value })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to vote on post');
  }
  
  return await response.json();
}

// Vote on a comment
export async function voteOnComment(
  commentId: string, 
  value: number, // 1 for upvote, -1 for downvote, 0 for removing vote
  token?: string | null
) {
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/votes/comments/${commentId}`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ value })
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to vote on comment');
  }
  
  return await response.json();
}

// Get user's vote on a post
export async function getUserPostVote(
  postId: string,
  token?: string | null
) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/votes/posts/${postId}/user`, {
    headers
  });
  
  if (!response.ok) {
    if (response.status === 401) {
      // Not authenticated, return 0 (no vote)
      return { value: 0 };
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to get user post vote');
  }
  
  return await response.json();
}

// Get user's vote on a comment
export async function getUserCommentVote(
  commentId: string,
  token?: string | null
) {
  const headers: Record<string, string> = {};
  
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  
  const response = await fetch(`${API_BASE_URL}/api/votes/comments/${commentId}/user`, {
    headers
  });
  
  if (!response.ok) {
    if (response.status === 401) {
      // Not authenticated, return 0 (no vote)
      return { value: 0 };
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || 'Failed to get user comment vote');
  }
  
  return await response.json();
}

================
File: src/App.tsx
================
import React from 'react';
import { Outlet } from 'react-router-dom';
import Navbar from './components/Navbar';
import { AuthProvider } from './context/AuthContext';

export default function App() {
  return (
    <AuthProvider>
      <div className="min-h-screen bg-gray-50">
        <Navbar />
        <main className="max-w-[1800px] mx-auto px-4 py-0">
          <Outlet />
        </main>
      </div>
    </AuthProvider>
  );
}

================
File: src/components/ActivityHistory.tsx
================
import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { 
  formatActivity,
  ActivityQueryOptions
} from '../api/activities';
import { getActivityHistory } from '../api/compatibility';

interface Activity {
  id: string;
  user_id: string;
  activity_type_id: string;
  action_id: string;
  entity_id?: string;
  entity_type?: string;
  metadata?: any;
  created_at: string;
  activity_type_name: string;
  action_name: string;
  username?: string;
  entity_details?: any;
}

interface ActivityHistoryProps {
  userId?: string;
  communityId?: string;
  postId?: string;
  limit?: number;
  showFilters?: boolean;
}

const ActivityHistory: React.FC<ActivityHistoryProps> = ({ 
  userId, 
  communityId, 
  postId, 
  limit = 20,
  showFilters = false
}) => {
  const { token } = useAuth();
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [offset, setOffset] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  
  // Filter states
  const [activityType, setActivityType] = useState<string>('');
  const [actionType, setActionType] = useState<string>('');
  const [entityType, setEntityType] = useState<string>('');
  
  useEffect(() => {
    fetchActivities();
  }, [userId, communityId, postId, offset, activityType, actionType, entityType]);
  
  const fetchActivities = async () => {
    setLoading(true);
    setError(null);
    
    try {
      let result: Activity[] = [];
      
      // Use the compatibility layer to get activities
      if (communityId) {
        result = await getActivityHistory('community', communityId, token) as Activity[];
      } else if (userId) {
        result = await getActivityHistory('user', userId, token) as Activity[];
      } else if (postId) {
        result = await getActivityHistory('post', postId, token) as Activity[];
      }
      
      setActivities(result);
      setHasMore(result.length === limit);
    } catch (error: any) {
      console.error('Error fetching activities:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  
  const loadMore = () => {
    setOffset(prev => prev + limit);
  };
  
  if (loading && activities.length === 0) {
    return <div className="text-center py-4">Loading activities...</div>;
  }
  
  if (error && activities.length === 0) {
    return (
      <div className="text-center text-red-500 py-4">
        Error loading activities: {error}
      </div>
    );
  }
  
  if (activities.length === 0) {
    return <div className="text-center py-4">No activities found.</div>;
  }
  
  return (
    <div className="activity-history mt-4">
      {showFilters && (
        <div className="filters mb-4 flex gap-2 flex-wrap">
          <select 
            value={activityType} 
            onChange={e => setActivityType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Activity Types</option>
            <option value="POST">Posts</option>
            <option value="COMMENT">Comments</option>
            <option value="VOTE">Votes</option>
            <option value="COMMUNITY">Communities</option>
          </select>
          
          <select 
            value={actionType} 
            onChange={e => setActionType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Actions</option>
            <option value="CREATE">Create</option>
            <option value="UPDATE">Update</option>
            <option value="DELETE">Delete</option>
            <option value="UPVOTE">Upvote</option>
            <option value="DOWNVOTE">Downvote</option>
            <option value="JOIN">Join</option>
            <option value="LEAVE">Leave</option>
          </select>
          
          <select 
            value={entityType} 
            onChange={e => setEntityType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Entities</option>
            <option value="post">Posts</option>
            <option value="comment">Comments</option>
            <option value="community">Communities</option>
            <option value="user">Users</option>
          </select>
        </div>
      )}
      
      <ul className="divide-y">
        {activities.map(activity => (
          <li key={activity.id} className="py-2">
            <div className="flex justify-between">
              <div>
                <strong>{activity.username || 'User'}</strong> {' '}
                {formatActivity(activity)}
              </div>
              <div className="text-gray-500 text-sm">
                {new Date(activity.created_at).toLocaleString()}
              </div>
            </div>
          </li>
        ))}
      </ul>
      
      {hasMore && (
        <button 
          onClick={loadMore} 
          className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Load More'}
        </button>
      )}
    </div>
  );
};

export default ActivityHistory;

================
File: src/components/ActivityHistory.tsxold
================
import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { 
  formatActivity,
  ActivityQueryOptions
} from '../api/activities';
import { getActivityHistory } from '../api/compatibility';

interface Activity {
  id: string;
  user_id: string;
  activity_type_id: string;
  action_id: string;
  entity_id?: string;
  entity_type?: string;
  metadata?: any;
  created_at: string;
  activity_type_name: string;
  action_name: string;
  username?: string;
  entity_details?: any;
}

interface ActivityHistoryProps {
  userId?: string;
  communityId?: string;
  postId?: string;
  limit?: number;
  showFilters?: boolean;
}

const ActivityHistory: React.FC<ActivityHistoryProps> = ({ 
  userId, 
  communityId, 
  postId, 
  limit = 20,
  showFilters = false
}) => {
  const { token } = useAuth();
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [offset, setOffset] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  
  // Filter states
  const [activityType, setActivityType] = useState<string>('');
  const [actionType, setActionType] = useState<string>('');
  const [entityType, setEntityType] = useState<string>('');
  
  useEffect(() => {
    fetchActivities();
  }, [userId, communityId, postId, offset, activityType, actionType, entityType]);
  
  const fetchActivities = async () => {
    setLoading(true);
    setError(null);
    
    try {
      let result: Activity[] = [];
      
      // Use the compatibility layer to get activities
      if (communityId) {
        result = await getActivityHistory('community', communityId, token) as Activity[];
      } else if (userId) {
        result = await getActivityHistory('user', userId, token) as Activity[];
      } else if (postId) {
        result = await getActivityHistory('post', postId, token) as Activity[];
      }
      
      setActivities(result);
      setHasMore(result.length === limit);
    } catch (error: any) {
      console.error('Error fetching activities:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  
  const loadMore = () => {
    setOffset(prev => prev + limit);
  };
  
  if (loading && activities.length === 0) {
    return <div className="text-center py-4">Loading activities...</div>;
  }
  
  if (error && activities.length === 0) {
    return (
      <div className="text-center text-red-500 py-4">
        Error loading activities: {error}
      </div>
    );
  }
  
  if (activities.length === 0) {
    return <div className="text-center py-4">No activities found.</div>;
  }
  
  return (
    <div className="activity-history mt-4">
      {showFilters && (
        <div className="filters mb-4 flex gap-2 flex-wrap">
          <select 
            value={activityType} 
            onChange={e => setActivityType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Activity Types</option>
            <option value="POST">Posts</option>
            <option value="COMMENT">Comments</option>
            <option value="VOTE">Votes</option>
            <option value="COMMUNITY">Communities</option>
          </select>
          
          <select 
            value={actionType} 
            onChange={e => setActionType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Actions</option>
            <option value="CREATE">Create</option>
            <option value="UPDATE">Update</option>
            <option value="DELETE">Delete</option>
            <option value="UPVOTE">Upvote</option>
            <option value="DOWNVOTE">Downvote</option>
            <option value="JOIN">Join</option>
            <option value="LEAVE">Leave</option>
          </select>
          
          <select 
            value={entityType} 
            onChange={e => setEntityType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Entities</option>
            <option value="post">Posts</option>
            <option value="comment">Comments</option>
            <option value="community">Communities</option>
            <option value="user">Users</option>
          </select>
        </div>
      )}
      
      <ul className="divide-y">
        {activities.map(activity => (
          <li key={activity.id} className="py-2">
            <div className="flex justify-between">
              <div>
                <strong>{activity.username || 'User'}</strong> {' '}
                {formatActivity(activity)}
              </div>
              <div className="text-gray-500 text-sm">
                {new Date(activity.created_at).toLocaleString()}
              </div>
            </div>
          </li>
        ))}
      </ul>
      
      {hasMore && (
        <button 
          onClick={loadMore} 
          className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Load More'}
        </button>
      )}
    </div>
  );
};

export default ActivityHistory;

================
File: src/components/CommentItem.tsx
================
import React, { useState, useEffect, useContext } from 'react'
import { ArrowUp, Reply, Edit, Trash2 } from 'lucide-react'
import { AuthContext } from '../context/AuthContext'
import { updateComment, deleteComment } from '../api/comments'
import { voteOnComment, getUserCommentVote } from '../api/votes'

interface CommentItemProps {
  comment: {
    id: string;
    content: string;
    username: string;
    timestamp: string;
    votes?: number;
    user_id?: string;
    replies?: any[];
  };
  onReply: (parentId: string, content: string) => Promise<boolean | undefined>;
  level: number;
}

export default function CommentItem({ comment, onReply, level = 0 }: CommentItemProps) {
  const [isReplying, setIsReplying] = useState(false)
  const [replyText, setReplyText] = useState('')
  const [isEditing, setIsEditing] = useState(false)
  const [editText, setEditText] = useState(comment.content)
  const [isDeleting, setIsDeleting] = useState(false)
  const [userVote, setUserVote] = useState<number>(0)
  const [voteLoading, setVoteLoading] = useState<boolean>(false)
  const [voteCount, setVoteCount] = useState<number>(comment.votes || 0)
  
  const auth = useContext(AuthContext)
  const user = auth?.user
  const token = auth?.token
  
  const isAuthor = user && user.id === comment.user_id
  const maxLevel = 6 // Maximum nesting level for replies
  
  // Fetch user's vote when component mounts
  useEffect(() => {
    const fetchUserVote = async () => {
      if (!user || !token || !comment.id) return
      
      try {
        const response = await getUserCommentVote(comment.id, token)
        setUserVote(response.value)
      } catch (err) {
        console.error('Error fetching user vote:', err)
      }
    }
    
    fetchUserVote()
  }, [comment.id, user, token])
  
  // Handle vote
  const handleVote = async (voteValue: number) => {
    if (!user || !token) {
      // Prompt to login if not authenticated
      alert('Please log in to vote')
      return
    }
    
    if (voteLoading) return
    
    try {
      setVoteLoading(true)
      
      // Determine the new vote value
      let newVoteValue = voteValue
      
      // If user clicks the same vote button again, remove the vote
      if (userVote === voteValue) {
        newVoteValue = 0
      }
      
      // Calculate the vote difference for optimistic UI update
      const voteDifference = newVoteValue - userVote
      
      // Update UI optimistically
      setUserVote(newVoteValue)
      setVoteCount(prev => prev + voteDifference)
      
      // Make API call
      await voteOnComment(comment.id, newVoteValue, token)
    } catch (err) {
      console.error('Error voting:', err)
      
      // Revert optimistic updates on failure
      setUserVote(userVote)
      setVoteCount(comment.votes || 0)
      
      // Show error message
      alert('Failed to vote. Please try again.')
    } finally {
      setVoteLoading(false)
    }
  }
  
  // Handle reply submission
  const handleSubmitReply = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!replyText.trim() || !user) return
    
    const success = await onReply(comment.id, replyText)
    
    if (success) {
      setReplyText('')
      setIsReplying(false)
    }
  }
  
  // Handle comment editing
  const handleEditComment = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!editText.trim() || !isAuthor) return
    
    try {
      await updateComment(comment.id, editText, token)
      comment.content = editText
      setIsEditing(false)
    } catch (err) {
      console.error('Error updating comment:', err)
    }
  }
  
  // Handle comment deletion
  const handleDeleteComment = async () => {
    if (!isAuthor) return
    
    try {
      setIsDeleting(true)
      await deleteComment(comment.id, token)
      // We would ideally remove this comment from the parent component's state
      // For now, we'll just hide it
      comment.content = '[deleted]'
      setIsDeleting(false)
    } catch (err) {
      console.error('Error deleting comment:', err)
      setIsDeleting(false)
    }
  }
  
  // Get indentation class based on nesting level
  const getIndentClass = () => {
    if (level === 0) return '';
    const indentLevel = Math.min(level, 6); // Cap at 6 levels
    return `ml-${indentLevel * 4}`;
  };
  
  // Determine color accent based on nesting level
  const colorAccents = ['teal', 'pink', 'purple', 'teal', 'pink', 'purple'];
  const colorAccent = colorAccents[level % colorAccents.length];
  
  return (
    <>
      <div className={`bg-white p-4 rounded-sm shadow-sm border-l-2 border-${colorAccent}-400 ${getIndentClass()} mb-3 hover:shadow-md transition-shadow`}>        
        <div className="flex items-start gap-2">
          {/* Voting */}
          <div className="flex flex-col items-center mr-2">
            <button
              className={`p-1 transition-colors ${
                userVote === 1 
                  ? `text-${colorAccent}-600`
                  : `text-gray-400 hover:text-${colorAccent}-600`
              }`}
              onClick={() => handleVote(1)}
              disabled={voteLoading}
            >
              <ArrowUp className="w-4 h-4" />
            </button>
            <span className={`text-xs font-medium ${
              voteCount > 0 ? `text-${colorAccent}-600` : voteCount < 0 ? 'text-pink-600' : 'text-gray-700'
            }`}>
              {voteCount}
            </span>
            <button
              className={`p-1 transition-colors transform rotate-180 ${
                userVote === -1 
                  ? 'text-pink-600'
                  : 'text-gray-400 hover:text-pink-600'
              }`}
              onClick={() => handleVote(-1)}
              disabled={voteLoading}
            >
              <ArrowUp className="w-4 h-4" />
            </button>
          </div>

          {/* Content */}
          <div className="flex-1 min-w-0">
            {isEditing ? (
              <form onSubmit={handleEditComment} className="w-full">
                <textarea
                  className={`w-full p-2 border border-gray-200 rounded focus:border-${colorAccent}-400 focus:outline-none transition-colors`}
                  value={editText}
                  onChange={(e) => setEditText(e.target.value)}
                  rows={3}
                />
                <div className="flex gap-2 mt-2">
                  <button 
                    type="submit"
                    className={`px-3 py-1 text-sm bg-${colorAccent}-600 text-white rounded hover:bg-${colorAccent}-700 transition-colors`}
                  >
                    Save
                  </button>
                  <button 
                    type="button"
                    className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors"
                    onClick={() => setIsEditing(false)}
                  >
                    Cancel
                  </button>
                </div>
              </form>
            ) : (
              <>
                <div className="flex items-center gap-2 mb-1">
                  <span className={`font-medium text-${colorAccent}-600`}>{comment.username}</span>
                  <span className="text-xs text-gray-500">{comment.timestamp}</span>
                </div>
                
                <p className="text-gray-800 break-words">{comment.content}</p>
                
                {/* Action buttons */}
                <div className="flex gap-4 mt-2 text-xs">
                  {user && level < maxLevel && (
                    <button 
                      className={`flex items-center text-gray-500 hover:text-${colorAccent}-600 transition-colors`}
                      onClick={() => setIsReplying(!isReplying)}
                    >
                      <Reply className="w-3 h-3 mr-1" />
                      Reply
                    </button>
                  )}
                  
                  {isAuthor && (
                    <>
                      <button 
                        className="flex items-center text-gray-500 hover:text-teal-600 transition-colors"
                        onClick={() => setIsEditing(true)}
                      >
                        <Edit className="w-3 h-3 mr-1" />
                        Edit
                      </button>
                      
                      <button 
                        className="flex items-center text-gray-500 hover:text-pink-600 transition-colors"
                        onClick={handleDeleteComment}
                        disabled={isDeleting}
                      >
                        <Trash2 className="w-3 h-3 mr-1" />
                        {isDeleting ? 'Deleting...' : 'Delete'}
                      </button>
                    </>
                  )}
                </div>
              </>
            )}
            
            {/* Reply form */}
            {isReplying && (
              <form onSubmit={handleSubmitReply} className="mt-3">
                <textarea
                  className={`w-full p-2 border border-gray-200 rounded focus:border-${colorAccent}-400 focus:outline-none transition-colors`}
                  placeholder="Write a reply..."
                  value={replyText}
                  onChange={(e) => setReplyText(e.target.value)}
                  rows={3}
                />
                <div className="flex gap-2 mt-2">
                  <button 
                    type="submit"
                    className={`px-3 py-1 text-sm bg-${colorAccent}-600 text-white rounded hover:bg-${colorAccent}-700 transition-colors`}
                    disabled={!replyText.trim()}
                  >
                    Reply
                  </button>
                  <button 
                    type="button"
                    className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors"
                    onClick={() => {
                      setIsReplying(false)
                      setReplyText('')
                    }}
                  >
                    Cancel
                  </button>
                </div>
              </form>
            )}
          </div>
        </div>
      </div>
      
      {/* Render replies */}
      {comment.replies && comment.replies.length > 0 && (
        <div className={`ml-4 pl-2 ${level < 1 ? 'border-l border-gray-200' : ''}`}>
          {comment.replies.map((reply) => (
            <CommentItem 
              key={reply.id} 
              comment={reply} 
              onReply={onReply}
              level={level + 1}
            />
          ))}
        </div>
      )}
    </>
  )
}

================
File: src/components/CommentSection.tsx
================
import React, { useState, useEffect, useContext } from 'react'
import CommentItem from './CommentItem'
import { getPostComments, createComment, Comment } from '../api/comments'
import { AuthContext } from '../context/AuthContext'
import { formatDistanceToNow } from 'date-fns'

interface CommentSectionProps {
  postId: string;
}

export default function CommentSection({ postId }: CommentSectionProps) {
  const [comments, setComments] = useState<Comment[]>([])
  const [loading, setLoading] = useState<boolean>(true)
  const [error, setError] = useState<string | null>(null)
  const [commentText, setCommentText] = useState<string>('')
  const [submitting, setSubmitting] = useState<boolean>(false)
  const [sortOption, setSortOption] = useState<string>('new')
  const auth = useContext(AuthContext)
  const user = auth?.user
  const token = auth?.token

  // Fetch comments when component mounts
  useEffect(() => {
    const fetchComments = async () => {
      try {
        setLoading(true)
        console.log('Fetching comments for post:', postId)
        const data = await getPostComments(postId, true) // Get threaded comments
        console.log('Comments data:', data)
        setComments(data || []) // Ensure we always have an array even if API returns null/undefined
        setError(null)
      } catch (err) {
        console.error('Error fetching comments:', err)
        setError('Failed to load comments')
        setComments([]) // Set empty array on error
      } finally {
        setLoading(false)
      }
    }

    if (postId) {
      fetchComments()
    } else {
      setLoading(false)
      setComments([])
    }
  }, [postId])

  // Handle comment submission
  const handleSubmitComment = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!commentText.trim() || !user) {
      if (!user) {
        setError('You must be logged in to comment')
      }
      return
    }
    
    setError(null) // Clear any previous errors
    
    try {
      setSubmitting(true)
      console.log('Submitting comment for post:', postId)
      console.log('Comment text:', commentText)
      console.log('User:', user.username)
      
      const newComment = await createComment(
        postId, 
        { content: commentText },
        token
      )
      
      console.log('Comment submission successful, response:', newComment)
      
      // Add the new comment to the list
      setComments(prevComments => [...prevComments, {
        ...newComment,
        username: user.username,
        replies: []
      }])
      
      // Clear the input
      setCommentText('')
      
      // Show success message temporarily
      setError('Comment posted successfully!')
      setTimeout(() => setError(null), 3000)
    } catch (err: any) {
      console.error('Error posting comment:', err)
      // Provide more detailed error message
      if (err instanceof Error) {
        setError(`Failed to post comment: ${err.message}`)
      } else {
        setError('Failed to post comment. Please try again.')
      }
    } finally {
      setSubmitting(false)
    }
  }

  // Handle reply submission
  const handleReply = async (parentId: string, content: string) => {
    if (!content.trim() || !user) return
    
    try {
      const newReply = await createComment(
        postId,
        { 
          content, 
          parentCommentId: parentId 
        },
        token
      )
      
      // Update the comments state to include the new reply
      setComments(prevComments => {
        // Create a deep copy of the comments array
        const updatedComments = JSON.parse(JSON.stringify(prevComments))
        
        // Find the parent comment
        const findAndAddReply = (comments: any[]) => {
          for (let i = 0; i < comments.length; i++) {
            if (comments[i].id === parentId) {
              // Add the reply to this comment
              if (!comments[i].replies) {
                comments[i].replies = []
              }
              comments[i].replies.push({
                ...newReply,
                username: user.username,
                replies: []
              })
              return true
            }
            
            // Check in replies recursively
            if (comments[i].replies && comments[i].replies.length > 0) {
              if (findAndAddReply(comments[i].replies)) {
                return true
              }
            }
          }
          return false
        }
        
        findAndAddReply(updatedComments)
        return updatedComments
      })
      
      return true
    } catch (err) {
      console.error('Error posting reply:', err)
      if (err instanceof Error) {
        setError(`Failed to post reply: ${err.message}`)
      } else {
        setError('Failed to post reply. Please try again.')
      }
      setTimeout(() => setError(null), 3000)
      return false
    }
  }

  // Format comment data for display
  const formatCommentForDisplay = (comment: Comment): any => {
    return {
      ...comment,
      timestamp: comment.created_at ? formatDistanceToNow(new Date(comment.created_at), { addSuffix: true }) : '',
      votes: comment.votes || 0, // Use actual votes from API
      replies: comment.replies ? comment.replies.map(formatCommentForDisplay) : []
    }
  }

  const formattedComments = comments.map(formatCommentForDisplay)
  
  // Sort comments based on the selected option
  const sortedComments = [...formattedComments].sort((a, b) => {
    if (sortOption === 'top') {
      return (b.votes || 0) - (a.votes || 0);
    } else if (sortOption === 'old') {
      return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
    } else {
      // Default 'new'
      return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
    }
  });

  if (loading) {
    return (
      <div className="bg-white p-6 shadow-md mb-6 border-l-4 border-teal-400">
        <div className="h-5 bg-gray-200 rounded w-1/4 mb-4"></div>
        <div className="h-32 bg-gray-100 rounded mb-4"></div>
        <div className="space-y-4">
          <div className="h-24 bg-gray-100 rounded"></div>
          <div className="h-24 bg-gray-100 rounded ml-8"></div>
          <div className="h-24 bg-gray-100 rounded"></div>
        </div>
      </div>
    )
  }

  return (
    <div className="bg-white p-6 shadow-md mb-6 border-l-4 border-teal-400">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-semibold">
          Comments ({comments.length})
        </h2>
        <div className="flex items-center">
          <span className="mr-2 text-sm text-gray-600">Sort by:</span>
          <select 
            className="border border-gray-300 rounded px-2 py-1 text-sm"
            value={sortOption}
            onChange={(e) => setSortOption(e.target.value)}
          >
            <option value="new">New</option>
            <option value="top">Top</option>
            <option value="old">Old</option>
          </select>
        </div>
      </div>
      
      {/* Error/Success Display */}
      {error && (
        <div className={`mb-4 p-3 rounded text-sm ${
          error.includes('success') 
            ? 'bg-green-50 text-green-700 border border-green-200' 
            : 'bg-red-50 text-red-700 border border-red-200'
        }`}>
          {error}
        </div>
      )}
      
      {/* Comment form */}
      <div className="mb-6 border-2 border-gray-100 rounded-md p-3 transition-all hover:border-teal-100">
        <h3 className="text-sm font-medium mb-2">Comment as {user ? user.username : 'guest'}</h3>
        <form onSubmit={handleSubmitComment}>
          <textarea
            className="w-full p-3 border border-gray-200 rounded focus:border-teal-400 focus:outline-none transition-colors"
            rows={4}
            placeholder={user ? "What are your thoughts?" : "Please sign in to comment"}
            value={commentText}
            onChange={(e) => setCommentText(e.target.value)}
            disabled={!user || submitting}
          />
          <div className="flex justify-end mt-2">
            <button 
              type="submit"
              className="px-4 py-2 bg-teal-600 text-white rounded hover:bg-teal-700 disabled:bg-gray-400 transition-colors"
              disabled={!user || !commentText.trim() || submitting}
            >
              {submitting ? 'Posting...' : 'Comment'}
            </button>
          </div>
        </form>
      </div>
      
      {/* Comments list */}
      <div className="space-y-4">
        {sortedComments.length > 0 ? (
          sortedComments.map((comment) => (
            <CommentItem 
              key={comment.id} 
              comment={comment} 
              onReply={handleReply}
              level={0}
            />
          ))
        ) : (
          <div className="bg-gray-50 p-6 text-center rounded border border-gray-100">
            <p className="text-gray-500">No comments yet. Be the first to comment!</p>
          </div>
        )}
      </div>
    </div>
  )
}

================
File: src/components/CommunityAbout.tsx
================
import React, { useState, useEffect } from 'react';
import { getCommunityAbout } from "../api/communities";

interface CommunityAboutInfo {
  id: string;
  name: string;
  description: string;
  privacy: 'public' | 'private';
  created_at: string;
  updated_at?: string;
  moderators: {
    community_id: string;
    user_id: string;
    role: 'moderator' | 'admin';
    username: string;
    joined_at: string;
  }[];
  memberCount: number;
  postCount: number;
  creationDateFormatted: string;
}

interface Props {
  communityId: string;
}

export default function CommunityAbout({ communityId }: Props) {
  const [communityAbout, setCommunityAbout] = useState<CommunityAboutInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        
        // Use the more efficient getCommunityAbout endpoint
        const communityData = await getCommunityAbout(communityId);
        
        if (communityData) {
          setCommunityAbout(communityData);
        } else {
          setError('Community not found');
        }
      } catch (error: unknown) {
        console.error("Error fetching community data:", error);
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('An unexpected error occurred');
        }
      } finally {
        setLoading(false);
      }
    }

    if (communityId) {
      fetchData();
    }
  }, [communityId]);

  if (loading) {
    return (
      <div className="card p-4">
        <h2 className="font-medium mb-2">About</h2>
        <div className="text-sm text-gray-600">
          <p>Loading community information...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="card p-4">
        <h2 className="font-medium mb-2">About</h2>
        <div className="text-sm text-red-600">
          <p>Error: {error}</p>
        </div>
      </div>
    );
  }

  if (!communityAbout) {
    return (
      <div className="card p-4">
        <h2 className="font-medium mb-2">About</h2>
        <div className="text-sm text-gray-600">
          <p>Community not found</p>
        </div>
      </div>
    );
  }

  return (
    <div className="card p-4">
      <h2 className="font-medium mb-2">About</h2>
      <div className="text-sm text-gray-600 space-y-2">
        <p>Created: {communityAbout.creationDateFormatted}</p>
        <p>Members: {communityAbout.memberCount}</p>
        <p>Posts: {communityAbout.postCount}</p>
        
        {communityAbout.moderators && communityAbout.moderators.length > 0 && (
          <div>
            <p className="font-medium">Moderators:</p>
            <ul className="list-disc list-inside ml-2">
              {communityAbout.moderators.map(mod => (
                <li key={mod.user_id} className="text-blue-600 font-medium">
                  {mod.username || `User ${mod.user_id.substring(0, 8)}`}
                </li>
              ))}
            </ul>
          </div>
        )}
        
        <div>
          <p className="font-medium">Description:</p>
          <p>{communityAbout.description}</p>
        </div>
        
        <p>Privacy: {communityAbout.privacy === 'public' ? 'Public' : 'Private'}</p>
      </div>
    </div>
  );
}

================
File: src/components/CommunityCard.tsx
================
import React from 'react'
import { Link } from 'react-router-dom'
import { useAuth } from '../context/AuthContext'
import JoinCommunityButton from './JoinCommunityButton'

interface CommunityCardProps {
  community: {
    id: string;
    name: string;
    description: string;
    members?: number;
    privacy?: 'public' | 'private';
  };
}

export default function CommunityCard({ community }: CommunityCardProps) {
  const { isAuthenticated } = useAuth();

  return (
    <div className="wireframe-border p-4 bg-white wireframe-shadow">
      <div className="flex items-center justify-between">
        <div>
          <Link
            to={`/community/${community.id}`}
            className="font-medium text-gray-900 hover:underline"
          >
            {community.name}
          </Link>
          <p className="text-sm text-gray-600 mt-1">{community.description}</p>
        </div>
        <JoinCommunityButton 
          communityId={community.id}
          variant="compact"
          className="px-3 py-1 wireframe-border text-sm"
        />
      </div>
      <div className="mt-2 text-sm text-gray-500">
        {community.members} members
      </div>
    </div>
  )
}

================
File: src/components/CommunityDiscovery.tsx
================
import React, { useState, useEffect } from 'react'
import { Link, useNavigate } from 'react-router-dom'
import { getCommunities } from '../api/communities'

interface Community {
  id: string;
  name: string;
  description: string;
  created_at: string;
  updated_at?: string;
}

export default function CommunityDiscovery() {
  const [newCommunities, setNewCommunities] = useState<Community[]>([])
  const [popularCommunities, setPopularCommunities] = useState<Community[]>([])
  const [randomCommunity, setRandomCommunity] = useState<Community | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const navigate = useNavigate()

  useEffect(() => {
    const fetchCommunities = async () => {
      try {
        setLoading(true)
        const allCommunities = await getCommunities()
        
        if (allCommunities.length === 0) {
          return;
        }
        
        // Sort by creation date for newest communities
        const sortedByDate = [...allCommunities].sort(
          (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        );
        setNewCommunities(sortedByDate.slice(0, 3));
        
        // For now, just use the first 3 communities as "popular"
        setPopularCommunities(allCommunities.slice(0, 3));
        
        // Get a random community
        const randomIndex = Math.floor(Math.random() * allCommunities.length);
        setRandomCommunity(allCommunities[randomIndex]);
        
        setError(null)
      } catch (err) {
        console.error('Error fetching communities:', err)
        setError('Failed to load communities')
      } finally {
        setLoading(false)
      }
    }

    fetchCommunities()
  }, [])
  
  // Navigate to random community
  const goToRandomCommunity = () => {
    if (randomCommunity) {
      navigate(`/community/${randomCommunity.id}`)
    }
  }

  if (loading) {
    return (
      <div className="bg-black text-white p-8 relative font-mono transform rotate-0.5">
        <div className="absolute -top-6 left-16 bg-white text-black px-4 py-1 transform -rotate-2">EXPLORE</div>
        <h2 className="font-bold text-3xl mb-8 uppercase tracking-tight">DISCOVER COMMUNITIES</h2>
        <div className="text-center py-12 text-2xl uppercase tracking-widest animate-pulse">LOADING...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-black text-white p-8 relative font-mono transform rotate-0.5">
        <div className="absolute -top-6 left-16 bg-white text-black px-4 py-1 transform -rotate-2">EXPLORE</div>
        <h2 className="font-bold text-3xl mb-8 uppercase tracking-tight">DISCOVER COMMUNITIES</h2>
        <div className="text-center py-12 bg-gray-800">
          <span className="text-2xl uppercase font-bold">ERROR:</span> {error}
        </div>
      </div>
    )
  }

  return (
    <div className="bg-black text-white p-8 relative font-mono transform rotate-0.5 shadow-lg">
      <div className="absolute -top-6 left-16 bg-white text-black px-4 py-1 transform -rotate-2 shadow-md">
        <span className="text-purple-500">E</span>
        <span>X</span>
        <span className="text-teal-500">P</span>
        <span>L</span>
        <span className="text-pink-500">O</span>
        <span>R</span>
        <span>E</span>
      </div>
      <h2 className="font-bold text-3xl mb-8 uppercase tracking-tight">
        DISCOVER <span className="text-teal-400">COMMUNITIES</span>
      </h2>
      
      {/* Explore Grid */}
      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6">
        {/* New Communities section */}
        <div className="bg-gray-800 p-4 border-l-4 border-teal-500 transform hover:skew-x-1 hover:-skew-y-1 transition-transform shadow-md">
          <div className="flex items-center justify-between border-b border-gray-700 mb-3 pb-1">
            <h3 className="text-sm uppercase font-medium tracking-wide text-teal-400">NEW</h3>
            <span className="text-xs text-gray-500">Communities</span>
          </div>
          <div className="space-y-2">
            {newCommunities.map((community) => (
              <Link 
                key={community.id} 
                to={`/community/${community.id}`}
                className="block hover:bg-gray-700 p-2 rounded transition-colors"
              >
                <div className="font-medium">r/{community.name}</div>
                <p className="text-sm text-gray-300 truncate">{community.description}</p>
              </Link>
            ))}
          </div>
        </div>
        
        {/* Popular Communities section */}
        <div className="bg-gray-800 p-4 border-l-4 border-pink-500 transform hover:skew-x-1 hover:-skew-y-1 transition-transform shadow-md">
          <div className="flex items-center justify-between border-b border-gray-700 mb-3 pb-1">
            <h3 className="text-sm uppercase font-medium tracking-wide text-pink-400">POPULAR</h3>
            <span className="text-xs text-gray-500">Communities</span>
          </div>
          <div className="space-y-2">
            {popularCommunities.map((community) => (
              <Link 
                key={community.id} 
                to={`/community/${community.id}`}
                className="block hover:bg-gray-700 p-2 rounded transition-colors"
              >
                <div className="font-medium">r/{community.name}</div>
                <p className="text-sm text-gray-300 truncate">{community.description}</p>
              </Link>
            ))}
          </div>
        </div>
        
        {/* Random Community section */}
        <div 
          className="bg-gray-800 p-4 border-l-4 border-purple-500 transform hover:skew-x-1 hover:-skew-y-1 transition-transform shadow-md cursor-pointer"
          onClick={goToRandomCommunity}
        >
          <div className="flex items-center justify-between border-b border-gray-700 mb-3 pb-1">
            <h3 className="text-sm uppercase font-medium tracking-wide text-purple-400">RANDOM</h3>
            <span className="text-xs text-gray-500">Community</span>
          </div>
          {randomCommunity ? (
            <div className="p-2">
              <div className="font-medium">r/{randomCommunity.name}</div>
              <p className="text-sm text-gray-300 truncate">{randomCommunity.description}</p>
              <div className="mt-4 text-sm text-purple-400">Click to visit </div>
            </div>
          ) : (
            <p className="text-sm text-gray-300 mt-2">No communities found</p>
          )}
        </div>
      </div>
      
      {newCommunities.length === 0 && popularCommunities.length === 0 && !randomCommunity && (
        <div className="text-center py-12 bg-gray-800 shadow-inner">
          <span className="text-2xl uppercase font-bold">EMPTY</span>
          <p className="mt-4 text-gray-300">No communities found. Create one to get started!</p>
        </div>
      )}
      
      <div className="mt-8 text-center">
        <Link 
          to="/communities" 
          className="inline-block px-8 py-4 bg-white text-black uppercase tracking-wider transform hover:skew-x-2 transition-transform shadow-md relative overflow-hidden group"
        >
          <span className="relative z-10">View All Communities</span>
          <span className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 transform translate-x-full group-hover:translate-x-0 transition-transform duration-300"></span>
        </Link>
      </div>
    </div>
  )
}

================
File: src/components/CommunityDiscoverySidebar.tsx
================
import React, { useState, useEffect } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { getCommunities } from '../api/communities';

interface Community {
  id: string;
  name: string;
  description: string;
  created_at: string;
  updated_at?: string;
  privacy?: 'public' | 'private';
}

export default function CommunityDiscoverySidebar() {
  const [newCommunities, setNewCommunities] = useState<Community[]>([]);
  const [popularCommunities, setPopularCommunities] = useState<Community[]>([]);
  const [randomCommunity, setRandomCommunity] = useState<Community | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        
        // Get all communities
        const allCommunities = await getCommunities();
        
        if (allCommunities.length === 0) {
          return;
        }
        
        // Sort by creation date for newest communities
        const sortedByDate = [...allCommunities].sort(
          (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        );
        setNewCommunities(sortedByDate.slice(0, 3));
        
        // For now, just use the first 3 communities as "popular"
        setPopularCommunities(allCommunities.slice(0, 3));
        
        // Get a random community
        const randomIndex = Math.floor(Math.random() * allCommunities.length);
        setRandomCommunity(allCommunities[randomIndex]);
        
      } catch (error) {
        console.error('Error fetching community data:', error);
        setError('Failed to load communities');
      } finally {
        setLoading(false);
      }
    }
    
    fetchData();
  }, []);
  
  // Function to navigate to a random community
  const goToRandomCommunity = () => {
    if (randomCommunity) {
      navigate(`/community/${randomCommunity.id}`);
    }
  };

  return (
    <div className="bg-black text-white p-4">
      <h2 className="font-bold uppercase tracking-tight text-xl relative inline-block mb-4">
        <span className="text-teal-400">DISCOVER</span>
      </h2>
      
      <div className="space-y-6 mt-6">
        {/* New Communities Section */}
        <div className="bg-gray-900 p-4 border-l-2 border-teal-400">
          <div className="flex items-center justify-between border-b border-gray-700 mb-2 pb-1">
            <h3 className="text-xs uppercase font-medium tracking-wide text-teal-400">NEW</h3>
            <span className="text-xs text-gray-500">Communities</span>
          </div>
          
          {loading ? (
            <div className="animate-pulse text-xs">Loading...</div>
          ) : error ? (
            <div className="text-xs text-red-400">Error loading communities</div>
          ) : newCommunities.length > 0 ? (
            <ul className="space-y-1">
              {newCommunities.map(community => (
                <li key={community.id} className="rounded hover:bg-gray-800 p-1 transition-colors">
                  <Link to={`/community/${community.id}`} className="block">
                    <span className="font-medium text-sm">{community.name}</span>
                    <p className="text-xs text-gray-400 truncate">{community.description}</p>
                  </Link>
                </li>
              ))}
            </ul>
          ) : (
            <div className="text-xs text-gray-400">No communities found</div>
          )}
        </div>
        
        {/* Popular Communities Section */}
        <div className="bg-gray-900 p-4 border-l-2 border-pink-400">
          <div className="flex items-center justify-between border-b border-gray-700 mb-2 pb-1">
            <h3 className="text-xs uppercase font-medium tracking-wide text-pink-400">POPULAR</h3>
            <span className="text-xs text-gray-500">Communities</span>
          </div>
          
          {loading ? (
            <div className="animate-pulse text-xs">Loading...</div>
          ) : error ? (
            <div className="text-xs text-red-400">Error loading communities</div>
          ) : popularCommunities.length > 0 ? (
            <ul className="space-y-1">
              {popularCommunities.map(community => (
                <li key={community.id} className="rounded hover:bg-gray-800 p-1 transition-colors">
                  <Link to={`/community/${community.id}`} className="block">
                    <span className="font-medium text-sm">{community.name}</span>
                    <p className="text-xs text-gray-400 truncate">{community.description}</p>
                  </Link>
                </li>
              ))}
            </ul>
          ) : (
            <div className="text-xs text-gray-400">No communities found</div>
          )}
        </div>
        
        {/* Random Community Section */}
        <div 
          className="bg-gray-900 p-4 border-l-2 border-purple-400 cursor-pointer hover:bg-gray-800 transition-colors"
          onClick={goToRandomCommunity}
        >
          <div className="flex items-center justify-between border-b border-gray-700 mb-2 pb-1">
            <h3 className="text-xs uppercase font-medium tracking-wide text-purple-400">RANDOM</h3>
            <span className="text-xs text-gray-500">Community</span>
          </div>
          
          {loading ? (
            <div className="animate-pulse text-xs">Loading...</div>
          ) : error ? (
            <div className="text-xs text-red-400">Error loading communities</div>
          ) : randomCommunity ? (
            <div className="text-sm">
              <div className="font-medium">{randomCommunity.name}</div>
              <p className="text-xs text-gray-400 truncate">{randomCommunity.description}</p>
              <button className="mt-2 text-xs text-purple-400 hover:text-purple-300">
                Click to visit 
              </button>
            </div>
          ) : (
            <div className="text-xs text-gray-400">No communities found</div>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: src/components/CommunityHeader.tsx
================
import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { getCommunityDetails } from '../api/compatibility';
import JoinCommunityButton from './JoinCommunityButton';

interface CommunityAbout {
  id: string;
  name: string;
  description: string;
  privacy: 'public' | 'private';
  memberCount?: number;
  postCount?: number;
  moderators?: string[];
  created_at: string;
}

interface Props {
  communityId: string;
}

export default function CommunityHeader({ communityId }: Props) {
  const [community, setCommunity] = useState<CommunityAbout | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isMember, setIsMember] = useState(false);
  const [joinLoading, setJoinLoading] = useState(false);
  const { user, token, isAuthenticated } = useAuth();

  // For demo purposes - hardcoded counts until backend is updated
  const getDemoStats = (community: any) => {
    // Generate pseudo-random but consistent numbers based on community ID
    const hash = community.id.split('').reduce((acc: number, char: string) => acc + char.charCodeAt(0), 0);
    const memberCount = 10 + (hash % 990); // Between 10-1000 members
    const postCount = 5 + (hash % 195);   // Between 5-200 posts
    
    return {
      memberCount,
      postCount
    };
  };

  useEffect(() => {
    async function fetchCommunity() {
      try {
        setLoading(true);
        // Use our compatibility layer to get community details
        const communityData = await getCommunityDetails(communityId, token);
        
        // If we got data, construct a CommunityAbout object
        if (communityData) {
          // Get demo stats until backend is updated
          const stats = getDemoStats(communityData);
          
          setCommunity({
            ...communityData,
            memberCount: stats.memberCount,
            postCount: stats.postCount,
          });
          
          // Check if the user is a member
          if (user) {
            // This would normally check if the user is a member
            // For now we'll assume they are for demo purposes
            setIsMember(true);
          }
        } else {
          setError('Community not found');
        }
      } catch (err: any) {
        console.error("Error fetching community:", err);
        setError(err.message || 'Failed to fetch community');
      } finally {
        setLoading(false);
      }
    }

    if (communityId) {
      fetchCommunity();
    }
  }, [communityId, user, token]);

  // Join and leave functionality is now handled by the JoinCommunityButton component

  if (loading) {
    return (
      <div className="animate-pulse bg-gray-200 p-8 rounded-md text-center">
        <div className="h-6 bg-gray-300 w-1/3 mx-auto mb-4 rounded"></div>
        <div className="h-4 bg-gray-300 w-2/3 mx-auto rounded"></div>
      </div>
    );
  }

  if (error || !community) {
    return (
      <div className="text-center p-8 bg-red-50 text-red-500 rounded-md">
        <h2 className="text-xl font-bold">Error</h2>
        <p>{error || 'Community not found'}</p>
      </div>
    );
  }

  return (
    <div className="bg-white p-6 rounded-md shadow mb-6">
      <div className="flex justify-between items-start">
        <div>
          <h1 className="text-2xl font-bold">{community.name}</h1>
          <p className="text-gray-600 mt-2">{community.description}</p>
          
          <div className="flex mt-4 text-sm text-gray-500 space-x-4">
            <div>
              <span className="font-medium">{community.memberCount}</span> members
            </div>
            <div>
              <span className="font-medium">{community.postCount}</span> posts
            </div>
            <div>
              Created {new Date(community.created_at).toLocaleDateString()}
            </div>
          </div>
        </div>
        
        <JoinCommunityButton 
          communityId={community.id}
          className={`px-4 py-2 rounded-md`}
          onJoin={() => setIsMember(true)}
          onLeave={() => setIsMember(false)}
        />
      </div>
    </div>
  );
}

================
File: src/components/CommunityInfo.tsx
================
import React, { useState, useEffect } from 'react';
import { getCommunityAbout } from '../api/communities';

interface CommunityAbout {
  id: string;
  name: string;
  description: string;
  privacy: 'public' | 'private';
  memberCount: number;
  postCount: number;
  moderators: string[];
  created_at: string;
}

interface Props {
  communityId: string;
}

export default function CommunityInfo({ communityId }: Props) {
  const [community, setCommunity] = useState<CommunityAbout | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchCommunity() {
      try {
        setLoading(true);
        const communityData = await getCommunityAbout(communityId);
        setCommunity(communityData);
      } catch (error: unknown) {
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('An unexpected error occurred');
        }
      } finally {
        setLoading(false);
      }
    }

    if (communityId) {
      fetchCommunity();
    }
  }, [communityId]);

  if (loading) {
    return (
      <div className="bg-white p-4 rounded-lg shadow-sm mb-6">
        <div className="h-8 w-48 bg-gray-200 animate-pulse rounded mb-2"></div>
        <div className="h-4 w-full bg-gray-200 animate-pulse rounded mb-2"></div>
        <div className="h-4 w-24 bg-gray-200 animate-pulse rounded"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-white p-4 rounded-lg shadow-sm mb-6 border-red-300">
        <h1 className="text-2xl font-bold mb-2">Error</h1>
        <p className="text-red-600">{error}</p>
      </div>
    );
  }

  if (!community) {
    return (
      <div className="bg-white p-4 rounded-lg shadow-sm mb-6">
        <h1 className="text-2xl font-bold mb-2">Community Not Found</h1>
        <p className="text-gray-600">The community you're looking for doesn't exist or has been removed.</p>
      </div>
    );
  }

  return (
    <div className="bg-white p-4 rounded-lg shadow-sm mb-6">
      <h1 className="text-2xl font-bold mb-2">r/{community.name}</h1>
      <p className="text-gray-600">{community.description}</p>
      <div className="mt-4 text-sm text-gray-500 flex space-x-4">
        <span>{community.memberCount} members</span>
        <span>{community.postCount} posts</span>
      </div>
      {community.privacy === 'private' && (
        <div className="mt-2 text-sm text-gray-500 bg-gray-100 p-2 rounded">
          This is a private community
        </div>
      )}
    </div>
  );
}

================
File: src/components/CommunityList.tsx
================
import React from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { joinCommunity } from '../api/communities';

interface Community {
  id: string;
  name: string;
  description: string;
  members?: number;
  isPublic?: boolean;
  created_at?: string;
  updated_at?: string;
  privacy?: 'public' | 'private';
}

interface CommunityListProps {
  communities: Community[];
}

export default function CommunityList({ communities }: CommunityListProps) {
  const { user, token, isAuthenticated } = useAuth();
  const [joiningMap, setJoiningMap] = React.useState<Record<string, boolean>>({});
  
  // Function to get a color based on index
  const getColorClass = (index: number) => {
    const colors = [
      'border-teal-400',
      'border-pink-400',
      'border-purple-400'
    ];
    return colors[index % colors.length];
  };

  const handleJoin = async (e: React.MouseEvent, communityId: string) => {
    e.preventDefault(); // Prevent navigating to community page
    
    if (!isAuthenticated) {
      alert('Please log in to join this community');
      return;
    }
    
    try {
      // Set this community as joining
      setJoiningMap(prev => ({ ...prev, [communityId]: true }));
      console.log(`Attempting to join community ${communityId} from CommunityList`);
      
      const result = await joinCommunity(communityId, token);
      console.log('Join result:', result);
      
      // Check response message to show appropriate alert
      if (result.message && result.message.includes('approval')) {
        alert('Join request submitted for approval');
      } else {
        alert('Successfully joined community!');
      }
      
      // Force-refresh the page to update membership state everywhere
      window.location.reload();
      
    } catch (error) {
      if (error instanceof Error) {
        if (error.message.includes('invite-only')) {
          alert('This community is invite-only');
        } else if (error.message.includes('approval')) {
          alert('Join request submitted for approval');
        } else {
          alert(`Error: ${error.message}`);
        }
      } else {
        alert('An error occurred');
      }
      console.error('Join error:', error);
    } finally {
      // Clear the joining state
      setJoiningMap(prev => ({ ...prev, [communityId]: false }));
    }
  };

  return (
    <div className="grid grid-cols-1 gap-3 font-mono">
      {communities.length === 0 ? (
        <div className="col-span-full text-center py-12 bg-black text-white shadow-lg">
          <span className="text-2xl uppercase font-bold tracking-wider">EMPTY</span>
          <p className="mt-4 text-gray-300">No communities found. Create one to get started!</p>
        </div>
      ) : (
        communities.map((community, index) => (
          <div
            key={community.id}
            className="bg-white shadow-md rounded-sm hover:shadow-lg transition-shadow"
          >
            <div className="flex flex-col md:flex-row">
              {/* Left color strip */}
              <div className={`w-1 md:w-2 flex-shrink-0 ${getColorClass(index)}`}></div>
              
              <div className="flex-grow p-4">
                <div className="flex flex-col md:flex-row md:items-center justify-between">
                  <div className="flex-grow">
                    <div className="flex items-center mb-1">
                      <Link
                        to={`/community/${community.id}`}
                        className="font-bold text-lg hover:text-teal-600 transition-colors"
                      >
                        {community.name}
                      </Link>
                      
                      {/* Privacy tag */}
                      {(community.isPublic === false || community.privacy === 'private') && (
                        <span className="ml-2 text-xs bg-gray-100 px-2 py-0.5 text-pink-600 font-medium rounded-full">
                          PRIVATE
                        </span>
                      )}
                    </div>
                    
                    {/* Community stats in a horizontal row */}
                    <div className="flex items-center text-xs text-gray-500 space-x-3 mb-2">
                      {community.members !== undefined && (
                        <div>
                          <span className="font-medium text-gray-700">{community.members}</span> members
                        </div>
                      )}
                      
                      {community.created_at && (
                        <div>
                          Created <span className="text-gray-700">{new Date(community.created_at).toLocaleDateString()}</span>
                        </div>
                      )}
                    </div>
                    
                    <p className="text-sm text-gray-700 mb-3 md:mb-0 md:pr-8 line-clamp-2">{community.description}</p>
                  </div>
                  
                  <div className="flex-shrink-0 mt-2 md:mt-0">
                    <button 
                      className={`px-4 py-1 text-white text-xs uppercase tracking-wider rounded-sm relative overflow-hidden
                        ${joiningMap[community.id] ? 'bg-gray-400 cursor-wait' : 'bg-black hover:bg-gray-800 transition-colors'}`}
                      onClick={(e) => handleJoin(e, community.id)}
                      disabled={joiningMap[community.id]}
                    >
                      {joiningMap[community.id] ? 'Joining...' : 'Join'}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        ))
      )}
    </div>
  );
}

================
File: src/components/CommunityModControls.tsx
================
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { getPendingModQueue } from '../api/moderation';
import { getPendingJoinRequests } from '../api/communities';

interface CommunityModControlsProps {
  communityId: string;
}

const CommunityModControls: React.FC<CommunityModControlsProps> = ({ communityId }) => {
  const { token } = useAuth();
  const [pendingCount, setPendingCount] = useState<number>(0);
  const [pendingJoinCount, setPendingJoinCount] = useState<number>(0);
  const [loading, setLoading] = useState<boolean>(true);
  
  useEffect(() => {
    if (!token) return;
    loadPendingCounts();
  }, [communityId, token]);
  
  const loadPendingCounts = async () => {
    try {
      setLoading(true);
      
      // Load both pending post moderation and join requests in parallel
      const [pendingPosts, joinRequests] = await Promise.all([
        getPendingModQueue(communityId, token).catch(() => []),
        getPendingJoinRequests(communityId, token).catch(() => [])
      ]);
      
      setPendingCount(pendingPosts.length);
      setPendingJoinCount(joinRequests.length);
    } catch (err) {
      console.error('Error loading pending counts:', err);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="bg-white rounded-lg shadow p-4 mb-4">
      <h3 className="text-lg font-semibold mb-3">Moderator Tools</h3>
      
      <div className="space-y-2">
        <Link
          to={`/community/${communityId}/moderation`}
          className="block bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded text-center"
        >
          Moderator Dashboard
        </Link>
        
        {pendingCount > 0 && (
          <Link
            to={`/community/${communityId}/moderation?tab=queue`}
            className="flex items-center justify-between bg-orange-100 hover:bg-orange-200 text-orange-800 py-2 px-4 rounded"
          >
            <span>Posts Pending Approval</span>
            <span className="bg-orange-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm">
              {pendingCount}
            </span>
          </Link>
        )}
        
        {pendingJoinCount > 0 && (
          <Link
            to={`/community/${communityId}/moderation?tab=join-requests`}
            className="flex items-center justify-between bg-green-100 hover:bg-green-200 text-green-800 py-2 px-4 rounded"
          >
            <span>Join Requests</span>
            <span className="bg-green-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-sm">
              {pendingJoinCount}
            </span>
          </Link>
        )}
      </div>
    </div>
  );
};

export default CommunityModControls;

================
File: src/components/CommunityRules.tsx
================
import React, { useState, useEffect } from 'react';
import { getCommunityRules } from '../api/compatibility';

interface CommunityRule {
  id: string;
  title: string;
  description: string;
}

interface Props {
  communityId: string;
}

export default function CommunityRules({ communityId }: Props) {
  const [rules, setRules] = useState<CommunityRule[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchRules() {
      try {
        setLoading(true);
        const fetchedRules = await getCommunityRules(communityId);
        setRules(fetchedRules || []);
      } catch (error: unknown) {
        console.error("Error fetching community rules:", error);
        // Do not show an error for missing rules - simply show no rules are set
        setRules([]);
        
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('Unknown error');
        }
      } finally {
        setLoading(false);
      }
    }

    if (communityId) {
      fetchRules();
    }
  }, [communityId]);

  if (loading) {
    return (
      <div className="bg-white rounded-md shadow p-4 animate-pulse">
        <h3 className="text-lg font-medium h-5 bg-gray-200 rounded w-1/3 mb-4"></h3>
        <div className="space-y-3">
          <div className="h-4 bg-gray-200 rounded w-5/6"></div>
          <div className="h-4 bg-gray-200 rounded w-4/6"></div>
          <div className="h-4 bg-gray-200 rounded w-3/6"></div>
        </div>
      </div>
    );
  }

  // Display nothing or a minimal message if no rules
  if (rules.length === 0) {
    return (
      <div className="bg-white rounded-md shadow p-4">
        <h3 className="text-lg font-medium">Community Rules</h3>
        <p className="text-gray-500 mt-2">No rules have been set for this community yet.</p>
      </div>
    );
  }

  return (
    <div className="bg-white rounded-md shadow p-4">
      <h3 className="text-lg font-medium">Community Rules</h3>
      <ol className="mt-3 space-y-3 list-decimal list-inside">
        {rules.map((rule) => (
          <li key={rule.id} className="text-gray-700">
            <span className="font-medium">{rule.title}</span>
            {rule.description && (
              <p className="text-gray-600 ml-6 mt-1 text-sm">{rule.description}</p>
            )}
          </li>
        ))}
      </ol>
    </div>
  );
}

================
File: src/components/CommunitySearch.tsx
================
import React, { useState } from 'react';
import { getCommunities } from '../api/communities';

interface Props {
  onSearch: (results: any[]) => void;
  onSearchStart: () => void;
  onSearchError: (error: string) => void;
}

export default function CommunitySearch({ onSearch, onSearchStart, onSearchError }: Props) {
  const [searchTerm, setSearchTerm] = useState('');
  const [isSearching, setIsSearching] = useState(false);

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!searchTerm.trim()) {
      return;
    }
    
    try {
      setIsSearching(true);
      onSearchStart();
      
      const results = await getCommunities(searchTerm);
      onSearch(results);
    } catch (error: unknown) {
      if (error instanceof Error) {
        onSearchError(error.message);
      } else {
        onSearchError('An unexpected error occurred');
      }
    } finally {
      setIsSearching(false);
    }
  };

  return (
    <div className="mb-8 font-mono">
      <div className="bg-black text-white px-4 py-2 mb-4 inline-block transform -rotate-0.5 shadow-sm">
        <span className="text-teal-400">F</span>
        <span>I</span>
        <span className="text-pink-400">N</span>
        <span>D</span>
        <span> </span>
        <span className="text-purple-400">C</span>
        <span>O</span>
        <span className="text-teal-400">M</span>
        <span>M</span>
        <span className="text-pink-400">U</span>
        <span>N</span>
        <span className="text-purple-400">I</span>
        <span>T</span>
        <span className="text-teal-400">I</span>
        <span>E</span>
        <span className="text-pink-400">S</span>
      </div>
      
      <form onSubmit={handleSearch} className="flex items-center">
        <input
          type="text"
          placeholder="Search communities..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="flex-1 p-3 mr-4 bg-white border-0 shadow-inner focus:outline-none focus:ring-2 focus:ring-teal-400"
          disabled={isSearching}
        />
        <button 
          type="submit" 
          className="px-6 py-3 bg-black text-white uppercase tracking-wider hover:bg-gray-900 disabled:bg-gray-600 shadow-md relative overflow-hidden group"
          disabled={isSearching || !searchTerm.trim()}
        >
          <span className="relative z-10">{isSearching ? 'Searching...' : 'Search'}</span>
          <span className="absolute bottom-0 left-0 w-0 h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 group-hover:w-full transition-all duration-300"></span>
        </button>
      </form>
    </div>
  );
}

================
File: src/components/CommunitySettings.tsx
================
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { getCommunitySettings, updateCommunitySettings, getCommunity, updateCommunity } from '../api/communities';
import { useAuth } from '../context/AuthContext';

interface CommunitySettings {
  community_id: string;
  allow_post_images: boolean;
  allow_post_links: boolean;
  join_method: 'auto_approve' | 'requires_approval' | 'invite_only';
  require_post_approval: boolean;
  restricted_words: string | null;
  custom_theme_color: string | null;
  custom_banner_url: string | null;
  minimum_account_age_days: number;
  minimum_karma_required: number;
  updated_at: Date;
}

interface Community {
  id: string;
  name: string;
  description: string;
  privacy: 'public' | 'private';
}

interface Props {
  communityId: string;
}

export default function CommunitySettings({ communityId }: Props) {
  const { user, token } = useAuth();
  const [settings, setSettings] = useState<CommunitySettings | null>(null);
  const [community, setCommunity] = useState<Community | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [saving, setSaving] = useState(false);
  const [isModerator, setIsModerator] = useState(false);

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        const [settingsData, communityData] = await Promise.all([
          getCommunitySettings(communityId),
          getCommunity(communityId)
        ]);
        setSettings(settingsData);
        setCommunity(communityData);
        
        // Check if user is a moderator
        if (user && token) {
          try {
            const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';
            const response = await fetch(`${API_BASE_URL}/api/communities/${communityId}/members/${user.id}`, {
              headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (response.ok) {
              const member = await response.json();
              setIsModerator(member.role === 'moderator' || member.role === 'admin');
            }
          } catch (err) {
            console.error("Error checking moderator status:", err);
          }
        }
      } catch (error: unknown) {
        console.error("Error fetching community settings:", error);
        
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('An unexpected error occurred');
        }
      } finally {
        setLoading(false);
      }
    }

    if (communityId) {
      fetchData();
    }
  }, [communityId, user, token]);

  // Create default data when only partial data is available
  useEffect(() => {
    if (!settings && community) {
      // Create default settings to display
      setSettings({
        community_id: community.id,
        allow_post_images: true,
        allow_post_links: true,
        join_method: 'auto_approve',
        require_post_approval: false,
        restricted_words: null,
        custom_theme_color: null,
        custom_banner_url: null,
        minimum_account_age_days: 0,
        minimum_karma_required: 0,
        updated_at: new Date()
      });
    }
    
    // If we have settings but no community data
    if (settings && !community) {
      // Create basic community info
      setCommunity({
        id: communityId,
        name: 'Community',
        description: 'No description available',
        privacy: 'public'
      });
    }
  }, [settings, community, communityId]);

  const handleTogglePrivacy = async () => {
    if (!community) return;
    
    try {
      setSaving(true);
      const newPrivacy = community.privacy === 'public' ? 'private' : 'public';
      const updatedCommunity = await updateCommunity(communityId, { privacy: newPrivacy });
      setCommunity(updatedCommunity);
    } catch (error: unknown) {
      if (error instanceof Error) {
        setError(error.message);
      } else {
        setError('Failed to update privacy setting');
      }
    } finally {
      setSaving(false);
    }
  };

  const handleTogglePostImages = async () => {
    if (!settings) return;
    
    try {
      setSaving(true);
      const updatedSettings = await updateCommunitySettings(communityId, {
        allow_post_images: !settings.allow_post_images
      });
      setSettings(updatedSettings);
    } catch (error: unknown) {
      if (error instanceof Error) {
        setError(error.message);
      } else {
        setError('Failed to update settings');
      }
    } finally {
      setSaving(false);
    }
  };

  const handleTogglePostLinks = async () => {
    if (!settings) return;
    
    try {
      setSaving(true);
      const updatedSettings = await updateCommunitySettings(communityId, {
        allow_post_links: !settings.allow_post_links
      });
      setSettings(updatedSettings);
    } catch (error: unknown) {
      if (error instanceof Error) {
        setError(error.message);
      } else {
        setError('Failed to update settings');
      }
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <div className="card p-4">
        <h2 className="font-medium mb-2">Community Settings</h2>
        <p className="text-sm text-gray-600">Loading settings...</p>
      </div>
    );
  }

  // Don't show error, show appropriate message
  if (!settings && !community) {
    return (
      <div className="card p-4">
        <h2 className="font-medium mb-2">Community Settings</h2>
        <p className="text-sm text-gray-600">Settings not available</p>
      </div>
    );
  }

  const handleJoinMethodChange = async (e: React.ChangeEvent<HTMLSelectElement>) => {
    if (!settings) return;
    
    const newJoinMethod = e.target.value as 'auto_approve' | 'requires_approval' | 'invite_only';
    
    try {
      setSaving(true);
      const updatedSettings = await updateCommunitySettings(communityId, {
        join_method: newJoinMethod
      }, token);
      setSettings(updatedSettings);
    } catch (error: unknown) {
      if (error instanceof Error) {
        setError(error.message);
      } else {
        setError('Failed to update join method');
      }
    } finally {
      setSaving(false);
    }
  };

  // We need both settings and community to render the form
  if (!settings || !community) {
    return (
      <div className="card p-4">
        <h2 className="font-medium mb-2">Community Settings</h2>
        <p className="text-sm text-gray-600">Loading settings...</p>
      </div>
    );
  }

  return (
    <div className="card p-4">
      <h2 className="font-medium mb-2">Community Settings</h2>
      <div className="text-sm text-gray-600 space-y-3">
        <div className="mt-2">
          <label className="flex items-center">
            <input
              type="checkbox"
              checked={community.privacy === 'public'}
              onChange={handleTogglePrivacy}
              disabled={saving}
              className="mr-2"
            />
            Public Community
          </label>
        </div>
        
        <div>
          <label className="flex items-center">
            <input
              type="checkbox"
              checked={settings.allow_post_images}
              onChange={handleTogglePostImages}
              disabled={saving}
              className="mr-2"
            />
            Allow Post Images
          </label>
        </div>
        
        <div>
          <label className="flex items-center">
            <input
              type="checkbox"
              checked={settings.allow_post_links}
              onChange={handleTogglePostLinks}
              disabled={saving}
              className="mr-2"
            />
            Allow Post Links
          </label>
        </div>
        
        <div className="mt-4">
          <label className="block mb-2 font-medium">Join Method:</label>
          <select 
            value={settings.join_method}
            onChange={handleJoinMethodChange}
            disabled={saving}
            className="w-full p-2 border border-gray-300 rounded"
          >
            <option value="auto_approve">Auto Approve (anyone can join)</option>
            <option value="requires_approval">Requires Approval (moderator must approve joins)</option>
            <option value="invite_only">Invite Only (no join requests)</option>
          </select>
        </div>
        
        {saving && (
          <p className="text-blue-600 italic">Saving changes...</p>
        )}
        
        {isModerator && (
          <div className="mt-4 pt-4 border-t border-gray-200">
            <h3 className="font-medium text-gray-800 mb-2">Moderator Controls</h3>
            <Link
              to={`/community/${communityId}/moderation`}
              className="inline-block px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors"
            >
              Moderation Dashboard
            </Link>
          </div>
        )}
      </div>
    </div>
  );
}

================
File: src/components/CommunitySidebar.tsx
================
import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import CommunityModControls from './CommunityModControls';
import { getCommunityMember } from '../api/communities';
import JoinCommunityButton from './JoinCommunityButton';

interface CommunitySidebarProps {
  communityId: string;
  communityName: string;
  description: string;
  memberCount: number;
  onJoin?: () => void;
  onLeave?: () => void;
}

const CommunitySidebar: React.FC<CommunitySidebarProps> = ({
  communityId,
  communityName,
  description,
  memberCount,
  onJoin,
  onLeave
}) => {
  const { user, token } = useAuth();
  const [isMember, setIsMember] = useState<boolean>(false);
  const [isModerator, setIsModerator] = useState<boolean>(false);
  const [loading, setLoading] = useState<boolean>(false);
  
  useEffect(() => {
    if (user && token) {
      checkMembershipStatus();
    }
  }, [user, token, communityId]);
  
  const checkMembershipStatus = async () => {
    if (!user || !token) return;
    
    setLoading(true);
    
    try {
      // Use the imported getCommunityMember function
      console.log(`Checking membership for user ${user.id} in community ${communityId}`);
      const member = await getCommunityMember(communityId, user.id, token);
      
      if (member) {
        console.log("Membership found:", member);
        setIsMember(true);
        setIsModerator(member.role === 'moderator' || member.role === 'admin');
      } else {
        console.log("User is not a member of this community");
        setIsMember(false);
        setIsModerator(false);
      }
    } catch (error) {
      console.error('Error checking membership status:', error);
    } finally {
      setLoading(false);
    }
  };
  
  // These functions are now handled by the JoinCommunityButton component
  
  return (
    <div className="space-y-4">
      <div className="bg-white rounded-lg shadow p-4">
        <h2 className="text-xl font-semibold mb-2">About r/{communityName}</h2>
        <p className="text-gray-700 mb-4">{description}</p>
        <div className="mb-4">
          <div className="font-medium">Members</div>
          <div className="text-gray-700">{memberCount}</div>
        </div>
        <div className="flex">
          <JoinCommunityButton 
            communityId={communityId}
            variant="sidebar"
            onJoin={onJoin}
            onLeave={onLeave}
          />
        </div>
      </div>
      
      {isMember && (
        <div className="bg-white rounded-lg shadow p-4">
          <h3 className="text-lg font-semibold mb-3">Community Actions</h3>
          <Link
            to={`/c/${communityId}/submit`}
            className="block w-full bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded text-center focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 mb-2"
          >
            Create Post
          </Link>
        </div>
      )}
      
      {isModerator && <CommunityModControls communityId={communityId} />}
    </div>
  );
};

export default CommunitySidebar;

================
File: src/components/CreateCommunityModal.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { createCommunity } from '../api/communities';
import { useAuth } from '../context/AuthContext';

interface CreateCommunityModalProps {
  onClose: () => void;
  onSuccess?: (communityId: string) => void;
}

export default function CreateCommunityModal({ onClose, onSuccess }: CreateCommunityModalProps) {
  const [name, setName] = useState('');
  const [description, setDescription] = useState('');
  const [privacy, setPrivacy] = useState<'public' | 'private'>('public');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { isAuthenticated, token, user } = useAuth();
  const navigate = useNavigate();

  // Redirect to login if not authenticated
  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login', { state: { from: window.location.pathname } });
    }
  }, [isAuthenticated, navigate]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isAuthenticated) {
      setError('You must be logged in to create a community');
      return;
    }
    
    if (!name.trim()) {
      setError('Community name is required');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const newCommunity = await createCommunity({
        name,
        description,
        privacy,
        creator_id: user?.id // Include the creator_id from auth context
      }, token);
      
      if (onSuccess) {
        onSuccess(newCommunity.id);
      }
      
      onClose();
    } catch (err) {
      console.error('Failed to create community:', err);
      setError('Failed to create community. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md">
        <h2 className="text-xl font-bold mb-4">Create Community</h2>
        
        {error && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            {error}
          </div>
        )}
        
        <form className="space-y-4" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="name" className="block text-sm font-medium text-gray-700 mb-1">
              Name
            </label>
            <input
              id="name"
              type="text"
              placeholder="Community name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md"
              disabled={isSubmitting}
            />
          </div>
          
          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700 mb-1">
              Description
            </label>
            <textarea
              id="description"
              placeholder="What is this community about?"
              rows={4}
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="w-full px-3 py-2 border border-gray-300 rounded-md"
              disabled={isSubmitting}
            />
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              Privacy
            </label>
            <div className="flex space-x-4">
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  name="privacy"
                  value="public"
                  checked={privacy === 'public'}
                  onChange={() => setPrivacy('public')}
                  disabled={isSubmitting}
                  className="mr-2"
                />
                Public
              </label>
              <label className="inline-flex items-center">
                <input
                  type="radio"
                  name="privacy"
                  value="private"
                  checked={privacy === 'private'}
                  onChange={() => setPrivacy('private')}
                  disabled={isSubmitting}
                  className="mr-2"
                />
                Private
              </label>
            </div>
          </div>
          
          <div className="flex justify-end space-x-2 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded-md text-gray-700"
              disabled={isSubmitting}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
              disabled={isSubmitting}
            >
              {isSubmitting ? 'Creating...' : 'Create Community'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}

================
File: src/components/CreatePostModal.tsx
================
import React, { useState, useEffect } from 'react';
import { X } from 'lucide-react';
import { useNavigate } from 'react-router-dom';
import { getUserCommunities } from '../api/communities';
import { createPost } from '../api/posts';
import { useAuth } from '../context/AuthContext';

interface Props {
  onClose: () => void;
  communityId?: string;
  onSuccess?: (postId: string) => void;
}

interface Community {
  id: string;
  name: string;
}

export default function CreatePostModal({ onClose, communityId, onSuccess }: Props) {
  const [postType, setPostType] = useState(communityId ? 'community' : 'profile'); // 'community' or 'profile'
  const [selectedCommunity, setSelectedCommunity] = useState(communityId || '');
  const [postTitle, setPostTitle] = useState('');
  const [postContent, setPostContent] = useState('');
  const [userCommunities, setUserCommunities] = useState<Community[]>([]);
  const [loading, setLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { user, isAuthenticated, token } = useAuth();
  const navigate = useNavigate();

  // Redirect to login if not authenticated
  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login', { state: { from: window.location.pathname } });
    }
  }, [isAuthenticated, navigate]);

  useEffect(() => {
    async function fetchData() {
      if (!isAuthenticated || !user) return;
      
      try {
        setLoading(true);
        console.log('Fetching communities user is a member of...');
        const communities = await getUserCommunities(user.id);
        console.log('User communities:', communities);
        
        // Make sure we're getting user's joined communities
        if (Array.isArray(communities)) {
          setUserCommunities(communities);
        } else {
          console.error('Invalid communities data:', communities);
          setError('Failed to load your communities - invalid data format');
        }
      } catch (error) {
        console.error('Failed to fetch communities:', error);
        setError('Failed to load your communities');
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [isAuthenticated, user, token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!isAuthenticated) {
      setError('You must be logged in to create a post');
      return;
    }
    
    if (postType === 'community' && !selectedCommunity) {
      setError('Please select a community');
      return;
    }
    
    if (!postTitle.trim()) {
      setError('Post title is required');
      return;
    }
    
    if (!postContent.trim()) {
      setError('Post content is required');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);

    try {
      const postData = {
        title: postTitle,
        content: postContent,
        communityId: postType === 'community' ? selectedCommunity : null
      };

      console.log('Creating post with data:', postData);
      const newPost = await createPost(postData, token);
      console.log('New post created:', newPost);
      
      if (onSuccess) {
        onSuccess(newPost.id);
      }
      
      onClose();
    } catch (error: any) {
      console.error('Failed to create post:', error);
      setError(error.message || 'Failed to create post');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg w-full max-w-md">
        <div className="p-4 border-b border-gray-200 flex justify-between items-center">
          <h2 className="text-lg font-medium">Create Post</h2>
          <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
            <X className="w-5 h-5" />
          </button>
        </div>

        {error && (
          <div className="mx-4 mt-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit} className="p-4 space-y-4">
          <div className="flex space-x-4">
            <button
              type="button"
              onClick={() => setPostType('community')}
              className={`px-4 py-2 wireframe-border ${
                postType === 'community' ? 'bg-gray-100' : ''
              }`}
            >
              Community
            </button>
            <button
              type="button"
              onClick={() => setPostType('profile')}
              className={`px-4 py-2 wireframe-border ${
                postType === 'profile' ? 'bg-gray-100' : ''
              }`}
            >
              Profile
            </button>
          </div>

          {postType === 'community' && (
            <div>
              <label htmlFor="community" className="block text-sm font-medium text-gray-700 mb-1">
                Community
              </label>
              <select
                id="community"
                value={selectedCommunity}
                onChange={(e) => setSelectedCommunity(e.target.value)}
                className="w-full p-2 border border-gray-300 rounded-md"
                required
                disabled={isSubmitting || loading}
              >
                <option value="">Select a community</option>
                {userCommunities.map((community) => (
                  <option key={community.id} value={community.id}>
                    r/{community.name}
                  </option>
                ))}
              </select>
              {loading && (
                <p className="text-sm text-gray-500 mt-1">Loading your communities...</p>
              )}
            </div>
          )}
          
          <div>
            <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
              Title
            </label>
            <input
              id="title"
              type="text"
              value={postTitle}
              onChange={(e) => setPostTitle(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md"
              placeholder="Post title"
              required
              disabled={isSubmitting}
            />
          </div>

          <div>
            <label htmlFor="content" className="block text-sm font-medium text-gray-700 mb-1">
              Content
            </label>
            <textarea
              id="content"
              value={postContent}
              onChange={(e) => setPostContent(e.target.value)}
              className="w-full p-2 border border-gray-300 rounded-md"
              rows={4}
              placeholder="What's on your mind?"
              required
              disabled={isSubmitting}
            />
          </div>

          <div className="flex justify-end space-x-2 pt-2">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 border border-gray-300 rounded-md text-gray-700"
              disabled={isSubmitting}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
              disabled={isSubmitting}
            >
              {isSubmitting ? 'Posting...' : 'Post'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}

================
File: src/components/EditProfileModal.tsx
================
import React, { useState } from 'react'
import { updateUserProfile } from '../api/users'
import { useAuth } from '../context/AuthContext'

interface EditProfileModalProps {
  onClose: () => void;
  onSuccess: () => void;
}

export default function EditProfileModal({ onClose, onSuccess }: EditProfileModalProps) {
  const { user, token } = useAuth()
  const [username, setUsername] = useState(user?.username || '')
  const [email, setEmail] = useState(user?.email || '')
  const [bio, setBio] = useState(user?.bio || '')
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    
    if (!username.trim()) {
      setError('Username is required')
      return
    }
    
    if (!email.trim()) {
      setError('Email is required')
      return
    }
    
    try {
      setLoading(true)
      setError(null)
      
      await updateUserProfile(
        {
          username,
          email,
          bio: bio.trim() || undefined
        },
        token
      )
      
      onSuccess()
    } catch (err) {
      console.error('Failed to update profile:', err)
      setError(err instanceof Error ? err.message : 'Failed to update profile')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white w-full max-w-md transform rotate-0.5 shadow-lg">
        <div className="bg-black text-white p-4">
          <h2 className="text-xl font-bold uppercase tracking-tight relative inline-block">
            <span className="text-teal-400">EDIT</span> PROFILE
            <span className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500"></span>
          </h2>
        </div>
        
        <form onSubmit={handleSubmit} className="p-6 space-y-4">
          {error && (
            <div className="bg-black text-white p-3 transform -rotate-0.5 shadow-md">
              <span className="text-pink-400 font-bold uppercase">ERROR:</span> {error}
            </div>
          )}
          
          <div>
            <label htmlFor="username" className="block text-sm font-bold uppercase tracking-wider text-gray-700 mb-1">
              Username
            </label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              className="w-full p-3 bg-gray-100 border-l-2 border-teal-400 focus:outline-none"
              disabled={loading}
            />
          </div>
          
          <div>
            <label htmlFor="email" className="block text-sm font-bold uppercase tracking-wider text-gray-700 mb-1">
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full p-3 bg-gray-100 border-l-2 border-pink-400 focus:outline-none"
              disabled={loading}
            />
          </div>
          
          <div>
            <label htmlFor="bio" className="block text-sm font-bold uppercase tracking-wider text-gray-700 mb-1">
              Bio
            </label>
            <textarea
              id="bio"
              value={bio}
              onChange={(e) => setBio(e.target.value)}
              className="w-full p-3 bg-gray-100 border-l-2 border-purple-400 focus:outline-none"
              rows={4}
              placeholder="Tell us about yourself..."
              disabled={loading}
            />
          </div>
          
          <div className="flex justify-end space-x-3 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="px-4 py-2 bg-gray-300 text-gray-700 uppercase tracking-wider hover:bg-gray-400"
              disabled={loading}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="px-4 py-2 bg-black text-white uppercase tracking-wider hover:bg-gray-800 relative overflow-hidden group"
              disabled={loading}
            >
              <span className="relative z-10">{loading ? 'Saving...' : 'Save'}</span>
              <span className="absolute bottom-0 left-0 w-0 h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 group-hover:w-full transition-all duration-300"></span>
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}

================
File: src/components/JoinCommunityButton.tsx
================
import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { joinCommunity, leaveCommunity, getCommunityMember } from '../api/communities-fix';

interface JoinCommunityButtonProps {
  communityId: string;
  className?: string;
  variant?: 'primary' | 'sidebar' | 'compact'; // Different visual styles
  onJoin?: () => void;
  onLeave?: () => void;
  showLeaveButton?: boolean; // Whether to show leave option (default true)
}

const JoinCommunityButton: React.FC<JoinCommunityButtonProps> = ({
  communityId,
  className = '',
  variant = 'primary',
  onJoin,
  onLeave,
  showLeaveButton = true,
}) => {
  const { user, token, isAuthenticated } = useAuth();
  const [isMember, setIsMember] = useState(false);
  const [loading, setLoading] = useState(false);
  const [initialCheckComplete, setInitialCheckComplete] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Check membership status on load
  useEffect(() => {
    if (isAuthenticated && token) {
      checkMembershipStatus();
    } else {
      setIsMember(false);
      setInitialCheckComplete(true);
    }
  }, [communityId, isAuthenticated, token]);
  
  // If the component doesn't unmount but props change, we should recheck
  useEffect(() => {
    if (isAuthenticated && token && initialCheckComplete) {
      checkMembershipStatus();
    }
  }, [communityId]);

  // Check if user is a member of this community
  const checkMembershipStatus = async () => {
    if (!isAuthenticated || !token) {
      setIsMember(false);
      setInitialCheckComplete(true);
      return;
    }

    setError(null);
    try {
      const member = await getCommunityMember(communityId, token);
      setIsMember(!!member);
    } catch (error) {
      console.error('Error checking membership:', error);
      setIsMember(false);
      setError('Could not verify membership status');
    }
    setInitialCheckComplete(true);
  };

  // Join community handler
  const handleJoin = async () => {
    if (!isAuthenticated || !token) {
      alert('Please log in to join communities');
      return;
    }

    setLoading(true);
    setError(null);
    
    // Set member immediately for better UX (optimistic update)
    setIsMember(true);
    
    try {
      // Make the API call to join
      await joinCommunity(communityId, token);
      
      // If we got here, it was successful!
      console.log('Successfully joined community');
      
      // Verify membership status to be sure
      await checkMembershipStatus();
      
      // Trigger any parent component callback
      if (onJoin) onJoin();
    } catch (error: any) {
      console.error('Failed to join community:', error);
      
      // Get the error message
      const errorMessage = error?.message || 'Failed to join community. Please try again.';
      
      // Verify our membership status - maybe it succeeded despite the error
      await checkMembershipStatus();
      
      // If we're still not a member after the check, the join actually failed
      if (!isMember) {
        setError(errorMessage);
        // Reset the optimistic update
        setIsMember(false);
      }
    } finally {
      setLoading(false);
    }
  };

  // Leave community handler
  const handleLeave = async () => {
    if (!isAuthenticated || !token) return;
    
    if (!confirm('Are you sure you want to leave this community?')) {
      return;
    }

    setLoading(true);
    setError(null);
    
    // Optimistic update
    setIsMember(false);
    
    try {
      const success = await leaveCommunity(communityId, undefined, token);
      
      if (!success) {
        // If the API returns false, it means the member couldn't be found
        console.log('Not a member of this community');
      }
      
      // Verify membership status to be sure
      await checkMembershipStatus();
      
      if (onLeave) onLeave();
    } catch (error: any) {
      console.error('Failed to leave community:', error);
      
      // Get the error message
      const errorMessage = error?.message || 'Failed to leave community. Please try again.';
      setError(errorMessage);
      
      // Verify our membership status - maybe we're still a member
      await checkMembershipStatus();
    } finally {
      setLoading(false);
    }
  };

  // Button styles based on variant
  const getButtonStyles = () => {
    const baseStyles = 'transition-all duration-200 font-bold flex items-center justify-center';
    
    if (!initialCheckComplete) {
      return `${baseStyles} bg-gray-300 text-gray-600 cursor-wait opacity-70 py-1 px-3 rounded`;
    }
    
    if (!isAuthenticated) {
      if (variant === 'compact') {
        return `${baseStyles} bg-gray-200 hover:bg-gray-300 text-gray-700 py-1 px-2 text-xs rounded`;
      }
      return `${baseStyles} bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 px-4 rounded`;
    }
    
    if (isMember && showLeaveButton) {
      if (variant === 'compact') {
        return `${baseStyles} bg-red-500 hover:bg-red-600 text-white py-1 px-2 text-xs rounded`;
      } else if (variant === 'sidebar') {
        return `${baseStyles} w-full bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded focus:ring-2 focus:ring-red-500 focus:ring-opacity-50`;
      }
      return `${baseStyles} bg-red-500 hover:bg-red-600 text-white py-2 px-4 rounded`;
    }
    
    if (variant === 'compact') {
      return `${baseStyles} bg-teal-500 hover:bg-teal-600 text-white py-1 px-2 text-xs rounded`;
    } else if (variant === 'sidebar') {
      return `${baseStyles} w-full bg-teal-500 hover:bg-teal-600 text-white font-medium py-2 px-4 rounded focus:ring-2 focus:ring-teal-500 focus:ring-opacity-50`;
    }
    return `${baseStyles} bg-teal-500 hover:bg-teal-600 text-white py-2 px-4 rounded`;
  };

  // Button label
  const getButtonLabel = () => {
    if (!initialCheckComplete) return 'Loading...';
    if (!isAuthenticated) return 'Join';
    if (loading) return isMember ? 'Leaving...' : 'Joining...';
    if (isMember && showLeaveButton) return 'Leave';
    return 'Join';
  };

  // Click handler
  const handleClick = () => {
    if (!initialCheckComplete || loading) return;
    if (!isAuthenticated) {
      alert('Please log in to join communities');
      return;
    }
    
    if (isMember && showLeaveButton) {
      handleLeave();
    } else if (!isMember) {
      handleJoin();
    }
  };

  return (
    <div className="inline-block">
      <button
        className={`${getButtonStyles()} ${className}`}
        onClick={handleClick}
        disabled={loading || !initialCheckComplete}
        title={error || ''}
      >
        {getButtonLabel()}
      </button>
      {error && (
        <div className="text-red-500 text-xs mt-1">
          {error}
        </div>
      )}
    </div>
  );
};

export default JoinCommunityButton;

================
File: src/components/ModeratorDashboard.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import {
  getCommunitySettings,
  updateCommunitySettings,
  CommunitySettings,
  getModerationLogs,
  ModerationLog,
  getBannedUsers,
  BannedUser,
  getPendingModQueue,
  PendingPost,
  moderatePost,
  banUser,
  unbanUser
} from '../api/moderation';
import { getCommunityMembers, updateMemberRole } from '../api/communities';

interface ModeratorDashboardProps {
  communityId: string;
}

const ModeratorDashboard: React.FC<ModeratorDashboardProps> = ({ communityId }) => {
  const { token } = useAuth();
  const navigate = useNavigate();
  const [activeTab, setActiveTab] = useState<'settings' | 'members' | 'queue' | 'logs' | 'banned'>('settings');
  const [settings, setSettings] = useState<CommunitySettings | null>(null);
  const [members, setMembers] = useState<any[]>([]);
  const [pendingPosts, setPendingPosts] = useState<PendingPost[]>([]);
  const [logs, setLogs] = useState<ModerationLog[]>([]);
  const [bannedUsers, setBannedUsers] = useState<BannedUser[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  
  // For editing settings
  const [editedSettings, setEditedSettings] = useState<Partial<CommunitySettings>>({});
  
  // For ban form
  const [showBanForm, setShowBanForm] = useState<boolean>(false);
  const [banUserId, setBanUserId] = useState<string>('');
  const [banReason, setBanReason] = useState<string>('');
  const [banDuration, setBanDuration] = useState<string>('permanent');
  
  // For rejection reason
  const [rejectReason, setRejectReason] = useState<string>('');
  const [rejectingPostId, setRejectingPostId] = useState<string | null>(null);
  
  useEffect(() => {
    if (token) {
      loadData();
    }
  }, [communityId, activeTab, token]);
  
  const loadData = async () => {
    if (!token) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // Load data based on active tab
      if (activeTab === 'settings') {
        const communitySettings = await getCommunitySettings(communityId, token);
        setSettings(communitySettings);
        setEditedSettings({});
      } else if (activeTab === 'members') {
        const communityMembers = await getCommunityMembers(communityId, token);
        setMembers(communityMembers);
      } else if (activeTab === 'queue') {
        const queue = await getPendingModQueue(communityId, token);
        setPendingPosts(queue);
      } else if (activeTab === 'logs') {
        const moderationLogs = await getModerationLogs(communityId, 100, 0, token);
        setLogs(moderationLogs);
      } else if (activeTab === 'banned') {
        const banned = await getBannedUsers(communityId, token);
        setBannedUsers(banned);
      }
    } catch (err) {
      console.error('Error loading data:', err);
      setError('Failed to load data. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const handleSettingsChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value, type } = e.target as HTMLInputElement;
    
    // Handle different input types
    if (type === 'checkbox') {
      const checked = (e.target as HTMLInputElement).checked;
      setEditedSettings(prev => ({ ...prev, [name]: checked }));
    } else if (name === 'minimum_account_age_days' || name === 'minimum_karma_required') {
      setEditedSettings(prev => ({ ...prev, [name]: parseInt(value, 10) }));
    } else {
      setEditedSettings(prev => ({ ...prev, [name]: value }));
    }
  };
  
  const saveSettings = async () => {
    if (!token) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const updatedSettings = await updateCommunitySettings(communityId, editedSettings, token);
      setSettings(updatedSettings);
      setEditedSettings({});
      alert('Settings saved successfully!');
    } catch (err) {
      console.error('Error saving settings:', err);
      setError('Failed to save settings. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const handleRoleChange = async (userId: string, newRole: 'member' | 'moderator' | 'admin') => {
    if (!token) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await updateMemberRole(communityId, userId, newRole, token);
      // Refresh members list
      const updatedMembers = await getCommunityMembers(communityId, token);
      setMembers(updatedMembers);
    } catch (err) {
      console.error('Error updating role:', err);
      setError('Failed to update role. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const approvePost = async (postId: string) => {
    if (!token) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await moderatePost(postId, 'approve', undefined, token);
      // Remove post from queue
      setPendingPosts(prev => prev.filter(post => post.id !== postId));
    } catch (err) {
      console.error('Error approving post:', err);
      setError('Failed to approve post. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const showRejectForm = (postId: string) => {
    setRejectingPostId(postId);
  };
  
  const rejectPost = async () => {
    if (!token || !rejectingPostId) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await moderatePost(rejectingPostId, 'reject', rejectReason, token);
      // Remove post from queue
      setPendingPosts(prev => prev.filter(post => post.id !== rejectingPostId));
      setRejectReason('');
      setRejectingPostId(null);
    } catch (err) {
      console.error('Error rejecting post:', err);
      setError('Failed to reject post. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const showBanUserForm = (userId: string) => {
    setBanUserId(userId);
    setShowBanForm(true);
  };
  
  const submitBan = async () => {
    if (!token || !banUserId) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const duration = banDuration === 'permanent' ? undefined : parseInt(banDuration, 10);
      await banUser(communityId, banUserId, banReason, duration, token);
      // Refresh banned users
      const banned = await getBannedUsers(communityId, token);
      setBannedUsers(banned);
      setShowBanForm(false);
      setBanUserId('');
      setBanReason('');
      setBanDuration('permanent');
    } catch (err) {
      console.error('Error banning user:', err);
      setError('Failed to ban user. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const unbanUserAction = async (userId: string) => {
    if (!token) return;
    
    if (!confirm('Are you sure you want to unban this user?')) return;
    
    setLoading(true);
    setError(null);
    
    try {
      await unbanUser(communityId, userId, undefined, token);
      // Refresh banned users
      const banned = await getBannedUsers(communityId, token);
      setBannedUsers(banned);
    } catch (err) {
      console.error('Error unbanning user:', err);
      setError('Failed to unban user. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
  };
  
  return (
    <div className="p-4 bg-white rounded-lg shadow">
      <h2 className="text-2xl font-bold mb-4">Moderator Dashboard</h2>
      
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}
      
      <div className="flex mb-4 border-b">
        <button 
          className={`px-4 py-2 ${activeTab === 'settings' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
          onClick={() => setActiveTab('settings')}
        >
          Settings
        </button>
        <button 
          className={`px-4 py-2 ${activeTab === 'members' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
          onClick={() => setActiveTab('members')}
        >
          Members
        </button>
        <button 
          className={`px-4 py-2 ${activeTab === 'queue' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
          onClick={() => setActiveTab('queue')}
        >
          Post Queue
        </button>
        <button 
          className={`px-4 py-2 ${activeTab === 'logs' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
          onClick={() => setActiveTab('logs')}
        >
          Logs
        </button>
        <button 
          className={`px-4 py-2 ${activeTab === 'banned' ? 'border-b-2 border-blue-500 text-blue-600' : 'text-gray-600'}`}
          onClick={() => setActiveTab('banned')}
        >
          Banned Users
        </button>
      </div>
      
      {loading ? (
        <div className="flex justify-center">
          <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
        </div>
      ) : (
        <div className="mt-4">
          {/* Settings Tab */}
          {activeTab === 'settings' && settings && (
            <div>
              <h3 className="text-xl font-semibold mb-4">Community Settings</h3>
              
              <div className="grid grid-cols-1 gap-4 max-w-2xl">
                <div className="mb-4">
                  <label className="flex items-center">
                    <input 
                      type="checkbox" 
                      name="allow_post_images" 
                      checked={editedSettings.allow_post_images !== undefined ? editedSettings.allow_post_images : settings.allow_post_images} 
                      onChange={handleSettingsChange}
                      className="mr-2"
                    />
                    <span>Allow images in posts</span>
                  </label>
                </div>
                
                <div className="mb-4">
                  <label className="flex items-center">
                    <input 
                      type="checkbox" 
                      name="allow_post_links" 
                      checked={editedSettings.allow_post_links !== undefined ? editedSettings.allow_post_links : settings.allow_post_links} 
                      onChange={handleSettingsChange}
                      className="mr-2"
                    />
                    <span>Allow links in posts</span>
                  </label>
                </div>
                
                <div className="mb-4">
                  <label className="flex items-center">
                    <input 
                      type="checkbox" 
                      name="require_post_approval" 
                      checked={editedSettings.require_post_approval !== undefined ? editedSettings.require_post_approval : settings.require_post_approval} 
                      onChange={handleSettingsChange}
                      className="mr-2"
                    />
                    <span>Require moderator approval for posts</span>
                  </label>
                </div>
                
                <div className="mb-4">
                  <label className="block mb-1">Restricted words (comma separated)</label>
                  <textarea 
                    name="restricted_words" 
                    value={editedSettings.restricted_words !== undefined ? editedSettings.restricted_words || '' : settings.restricted_words || ''} 
                    onChange={handleSettingsChange}
                    className="w-full p-2 border rounded"
                    rows={3}
                  ></textarea>
                </div>
                
                <div className="mb-4">
                  <label className="block mb-1">Custom theme color</label>
                  <input 
                    type="text" 
                    name="custom_theme_color" 
                    value={editedSettings.custom_theme_color !== undefined ? editedSettings.custom_theme_color || '' : settings.custom_theme_color || ''}
                    onChange={handleSettingsChange}
                    placeholder="#FF0000" 
                    className="w-full p-2 border rounded"
                  />
                </div>
                
                <div className="mb-4">
                  <label className="block mb-1">Custom banner URL</label>
                  <input 
                    type="text" 
                    name="custom_banner_url" 
                    value={editedSettings.custom_banner_url !== undefined ? editedSettings.custom_banner_url || '' : settings.custom_banner_url || ''}
                    onChange={handleSettingsChange}
                    placeholder="https://example.com/banner.jpg" 
                    className="w-full p-2 border rounded"
                  />
                </div>
                
                <div className="mb-4">
                  <label className="block mb-1">Minimum account age (days)</label>
                  <input 
                    type="number" 
                    name="minimum_account_age_days" 
                    value={editedSettings.minimum_account_age_days !== undefined ? editedSettings.minimum_account_age_days : settings.minimum_account_age_days}
                    onChange={handleSettingsChange}
                    min="0" 
                    className="w-full p-2 border rounded"
                  />
                </div>
                
                <div className="mb-4">
                  <label className="block mb-1">Minimum karma required</label>
                  <input 
                    type="number" 
                    name="minimum_karma_required" 
                    value={editedSettings.minimum_karma_required !== undefined ? editedSettings.minimum_karma_required : settings.minimum_karma_required}
                    onChange={handleSettingsChange}
                    min="0" 
                    className="w-full p-2 border rounded"
                  />
                </div>
                
                <div className="flex justify-end">
                  <button 
                    className="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded"
                    onClick={saveSettings}
                  >
                    Save Settings
                  </button>
                </div>
              </div>
            </div>
          )}
          
          {/* Members Tab */}
          {activeTab === 'members' && (
            <div>
              <h3 className="text-xl font-semibold mb-4">Community Members</h3>
              
              <div className="overflow-x-auto">
                <table className="min-w-full bg-white">
                  <thead>
                    <tr>
                      <th className="py-2 px-4 border-b text-left">Username</th>
                      <th className="py-2 px-4 border-b text-left">Role</th>
                      <th className="py-2 px-4 border-b text-left">Joined</th>
                      <th className="py-2 px-4 border-b text-left">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {members.map((member) => (
                      <tr key={member.user_id}>
                        <td className="py-2 px-4 border-b">{member.username}</td>
                        <td className="py-2 px-4 border-b">
                          <select 
                            value={member.role}
                            onChange={(e) => handleRoleChange(member.user_id, e.target.value as 'member' | 'moderator' | 'admin')}
                            className="p-1 border rounded"
                          >
                            <option value="member">Member</option>
                            <option value="moderator">Moderator</option>
                            <option value="admin">Admin</option>
                          </select>
                        </td>
                        <td className="py-2 px-4 border-b">{formatDate(member.joined_at)}</td>
                        <td className="py-2 px-4 border-b">
                          <button 
                            className="text-red-500 hover:text-red-700"
                            onClick={() => showBanUserForm(member.user_id)}
                          >
                            Ban
                          </button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
          
          {/* Post Queue Tab */}
          {activeTab === 'queue' && (
            <div>
              <h3 className="text-xl font-semibold mb-4">Post Approval Queue</h3>
              
              {pendingPosts.length === 0 ? (
                <p>No posts awaiting approval.</p>
              ) : (
                <div className="space-y-4">
                  {pendingPosts.map((post) => (
                    <div key={post.id} className="border rounded p-4">
                      <h4 className="text-lg font-medium">{post.title}</h4>
                      <p className="text-sm text-gray-500">By {post.author_username}  {formatDate(post.created_at)}</p>
                      <div className="my-2 p-2 bg-gray-50 rounded">{post.content}</div>
                      
                      <div className="flex mt-2 space-x-2">
                        <button 
                          className="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded"
                          onClick={() => approvePost(post.id)}
                        >
                          Approve
                        </button>
                        <button 
                          className="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded"
                          onClick={() => showRejectForm(post.id)}
                        >
                          Reject
                        </button>
                      </div>
                      
                      {rejectingPostId === post.id && (
                        <div className="mt-3 p-3 border rounded">
                          <label className="block mb-1">Rejection reason (optional)</label>
                          <textarea 
                            value={rejectReason} 
                            onChange={(e) => setRejectReason(e.target.value)}
                            className="w-full p-2 border rounded mb-2"
                            rows={2}
                          ></textarea>
                          <div className="flex space-x-2">
                            <button 
                              className="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded"
                              onClick={rejectPost}
                            >
                              Confirm Rejection
                            </button>
                            <button 
                              className="bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-1 rounded"
                              onClick={() => setRejectingPostId(null)}
                            >
                              Cancel
                            </button>
                          </div>
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          )}
          
          {/* Logs Tab */}
          {activeTab === 'logs' && (
            <div>
              <h3 className="text-xl font-semibold mb-4">Moderation Logs</h3>
              
              <div className="overflow-x-auto">
                <table className="min-w-full bg-white">
                  <thead>
                    <tr>
                      <th className="py-2 px-4 border-b text-left">Action</th>
                      <th className="py-2 px-4 border-b text-left">Moderator</th>
                      <th className="py-2 px-4 border-b text-left">Target</th>
                      <th className="py-2 px-4 border-b text-left">Reason</th>
                      <th className="py-2 px-4 border-b text-left">Date</th>
                    </tr>
                  </thead>
                  <tbody>
                    {logs.map((log) => (
                      <tr key={log.id}>
                        <td className="py-2 px-4 border-b">
                          {log.action_type.replace(/_/g, ' ')}
                        </td>
                        <td className="py-2 px-4 border-b">{log.moderator_username}</td>
                        <td className="py-2 px-4 border-b">
                          {log.target_type} {log.target_id ? `#${log.target_id.substring(0, 8)}` : ''}
                        </td>
                        <td className="py-2 px-4 border-b">{log.reason || '-'}</td>
                        <td className="py-2 px-4 border-b">{formatDate(log.created_at)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
          
          {/* Banned Users Tab */}
          {activeTab === 'banned' && (
            <div>
              <h3 className="text-xl font-semibold mb-4">Banned Users</h3>
              
              {bannedUsers.length === 0 ? (
                <p>No banned users.</p>
              ) : (
                <div className="overflow-x-auto">
                  <table className="min-w-full bg-white">
                    <thead>
                      <tr>
                        <th className="py-2 px-4 border-b text-left">Username</th>
                        <th className="py-2 px-4 border-b text-left">Banned By</th>
                        <th className="py-2 px-4 border-b text-left">Reason</th>
                        <th className="py-2 px-4 border-b text-left">Expires</th>
                        <th className="py-2 px-4 border-b text-left">Actions</th>
                      </tr>
                    </thead>
                    <tbody>
                      {bannedUsers.map((ban) => (
                        <tr key={ban.user_id}>
                          <td className="py-2 px-4 border-b">{ban.banned_username}</td>
                          <td className="py-2 px-4 border-b">{ban.moderator_username}</td>
                          <td className="py-2 px-4 border-b">{ban.reason || '-'}</td>
                          <td className="py-2 px-4 border-b">
                            {ban.ban_expires_at ? formatDate(ban.ban_expires_at) : 'Permanent'}
                          </td>
                          <td className="py-2 px-4 border-b">
                            <button 
                              className="text-blue-500 hover:text-blue-700"
                              onClick={() => unbanUserAction(ban.user_id)}
                            >
                              Unban
                            </button>
                          </td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              )}
            </div>
          )}
        </div>
      )}
      
      {/* Ban User Modal */}
      {showBanForm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
          <div className="bg-white rounded-lg p-6 max-w-md w-full">
            <h3 className="text-xl font-bold mb-4">Ban User</h3>
            
            <div className="mb-4">
              <label className="block mb-1">Ban reason (optional)</label>
              <textarea 
                value={banReason} 
                onChange={(e) => setBanReason(e.target.value)}
                className="w-full p-2 border rounded"
                rows={3}
              ></textarea>
            </div>
            
            <div className="mb-4">
              <label className="block mb-1">Ban duration</label>
              <select 
                value={banDuration} 
                onChange={(e) => setBanDuration(e.target.value)}
                className="w-full p-2 border rounded"
              >
                <option value="permanent">Permanent</option>
                <option value="1">1 day</option>
                <option value="3">3 days</option>
                <option value="7">7 days</option>
                <option value="14">14 days</option>
                <option value="30">30 days</option>
              </select>
            </div>
            
            <div className="flex justify-end space-x-2">
              <button 
                className="bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-2 rounded"
                onClick={() => setShowBanForm(false)}
              >
                Cancel
              </button>
              <button 
                className="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded"
                onClick={submitBan}
              >
                Ban User
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ModeratorDashboard;

================
File: src/components/Navbar.tsx
================
import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function Navbar() {
  const { user, isAuthenticated, logout } = useAuth();
  const [showUserMenu, setShowUserMenu] = useState(false);

  const handleLogout = () => {
    logout();
    setShowUserMenu(false);
  };

  return (
      <nav className="bg-black text-white font-mono relative z-10 mb-0">                          
        <div className="max-w-6xl mx-auto px-6 py-3 flex items-center justify-between">   
        <div className="flex items-center space-x-8">
          <Link 
            to="/" 
            className="text-3xl font-bold tracking-tighter text-white relative group"
          >
            <span className="relative z-10">RUMFOR</span>
            <span className="absolute -bottom-1 left-0 w-full h-2 bg-teal-400 transform -skew-x-12 group-hover:skew-x-12 transition-transform"></span>
          </Link>
          <div className="flex space-x-6">
            <Link 
              to="/communities" 
              className="text-white uppercase tracking-wide hover:text-teal-300 transition-colors"
            >
              Communities
            </Link>
            {isAuthenticated && (
              <Link 
                to="/profile"
                className="text-white uppercase tracking-wide hover:text-pink-300 transition-colors"
              >
                Profile
              </Link>
            )}
          </div>
        </div>
        
        <div className="flex items-center space-x-6">
          {isAuthenticated ? (
            <div className="relative">
              <button
                onClick={() => setShowUserMenu(!showUserMenu)}
                className="flex items-center space-x-2 text-white bg-gray-800 px-4 py-2 uppercase tracking-wide"
              >
                <span>{user?.username}</span>
                <svg
                  className={`w-4 h-4 transition-transform ${showUserMenu ? 'rotate-180' : ''}`}
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                  xmlns="http://www.w3.org/2000/svg"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M19 9l-7 7-7-7"
                  ></path>
                </svg>
              </button>
              
              {showUserMenu && (
                <div className="absolute right-0 mt-2 w-56 bg-gray-800 shadow-lg py-2 z-10">
                  <Link
                    to="/profile"
                    className="block px-4 py-3 text-sm text-white hover:bg-gray-700 uppercase"
                    onClick={() => setShowUserMenu(false)}
                  >
                    Your Profile
                  </Link>
                  {user?.role === 'admin' && (
                    <Link
                      to="/admin"
                      className="block px-4 py-3 text-sm text-white hover:bg-gray-700 uppercase"
                      onClick={() => setShowUserMenu(false)}
                    >
                      Admin Dashboard
                    </Link>
                  )}
                  <button
                    onClick={handleLogout}
                    className="block w-full text-left px-4 py-3 text-sm text-white hover:bg-gray-700 uppercase"
                  >
                    Logout
                  </button>
                </div>
              )}
            </div>
          ) : (
            <>
              <Link 
                to="/login" 
                className="text-white uppercase tracking-wide hover:text-teal-300 transition-colors"
              >
                Login
              </Link>
              <Link 
                to="/register" 
                className="px-4 py-2 bg-gray-800 text-white uppercase tracking-wide hover:bg-gray-700 transition-colors relative group"
              >
                <span className="relative z-10">Sign Up</span>
                <span className="absolute bottom-0 left-0 w-0 h-1 bg-pink-400 group-hover:w-full transition-all duration-300"></span>
              </Link>
            </>
          )}
        </div>
      </div>
      <div className="h-1 w-full bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500"></div>
    </nav>
  );
}

================
File: src/components/Post.tsx
================
import React, { useState, useEffect } from 'react'
import { ArrowUp, MessageSquare, Share2, Bookmark } from 'lucide-react'
import { getPost } from '../api/posts'
import { voteOnPost, getUserPostVote } from '../api/votes'
import { useAuth } from '../context/AuthContext'
import { formatDistanceToNow } from 'date-fns'
import { Link } from 'react-router-dom'

interface PostProps {
  postId: string;
}

export default function Post({ postId }: PostProps) {
  const [post, setPost] = useState<any>(null)
  const [loading, setLoading] = useState<boolean>(true)
  const [error, setError] = useState<string | null>(null)
  const [userVote, setUserVote] = useState<number>(0)
  const [voteLoading, setVoteLoading] = useState<boolean>(false)
  const [votes, setVotes] = useState<number>(0)
  const { user, token } = useAuth()

  useEffect(() => {
    const fetchPost = async () => {
      try {
        setLoading(true)
        const data = await getPost(postId, token)
        setPost(data)
        setVotes(data.votes || 0)
        setError(null)
      } catch (err) {
        console.error('Error fetching post:', err)
        setError('Failed to load post')
      } finally {
        setLoading(false)
      }
    }

    if (postId) {
      fetchPost()
    }
  }, [postId, token])

  useEffect(() => {
    // Fetch user's vote if they're logged in
    const fetchUserVote = async () => {
      if (!user || !token || !postId) return
      
      try {
        const response = await getUserPostVote(postId, token)
        setUserVote(response.value)
      } catch (err) {
        console.error('Error fetching user vote:', err)
      }
    }
    
    fetchUserVote()
  }, [postId, user, token])

  const handleVote = async (voteValue: number) => {
    if (!user || !token) {
      // Prompt to login if not authenticated
      alert('Please log in to vote')
      return
    }
    
    if (voteLoading) return
    
    try {
      setVoteLoading(true)
      
      // Determine the new vote value
      let newVoteValue = voteValue
      
      // If user clicks the same vote button again, remove the vote
      if (userVote === voteValue) {
        newVoteValue = 0
      }
      
      // Calculate the vote difference for optimistic UI update
      const voteDifference = newVoteValue - userVote
      
      // Update UI optimistically
      setUserVote(newVoteValue)
      setVotes(prev => prev + voteDifference)
      
      // Make API call
      await voteOnPost(postId, newVoteValue, token)
    } catch (err) {
      console.error('Error voting:', err)
      
      // Revert optimistic updates on failure
      setUserVote(userVote)
      setVotes(votes)
      
      // Show error message
      alert('Failed to vote. Please try again.')
    } finally {
      setVoteLoading(false)
    }
  }

  if (loading) {
    return (
      <div className="bg-white p-6 shadow-md mb-6 animate-pulse">
        <div className="h-6 bg-gray-200 rounded w-3/4 mb-4"></div>
        <div className="h-4 bg-gray-200 rounded w-full mb-2"></div>
        <div className="h-4 bg-gray-200 rounded w-full mb-2"></div>
        <div className="h-4 bg-gray-200 rounded w-2/3"></div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="bg-white p-6 border-l-4 border-red-500 shadow-md mb-6">
        <div className="flex items-center">
          <svg className="w-6 h-6 text-red-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span className="font-medium">{error}</span>
        </div>
      </div>
    )
  }

  if (!post) {
    return (
      <div className="bg-white p-6 border-l-4 border-yellow-500 shadow-md mb-6">
        <div className="flex items-center">
          <svg className="w-6 h-6 text-yellow-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
          <span className="font-medium">Post not found</span>
        </div>
        <p className="mt-2 text-gray-600">This post doesn't exist or has been deleted.</p>
      </div>
    )
  }

  // Format timestamp
  const timestamp = post.timestamp || post.created_at
  const formattedTime = timestamp 
    ? formatDistanceToNow(new Date(timestamp), { addSuffix: true })
    : 'unknown time'

  return (
    <div className="bg-white p-6 shadow-md mb-6 border-l-4 border-teal-400 transform hover:scale-[1.005] transition-transform">      
      <div className="flex">
        {/* Voting */}
        <div className="flex flex-col items-center mr-4">
          <button 
            className={`p-1 rounded transition-colors ${
              userVote === 1 
                ? 'text-teal-600'
                : 'text-gray-400 hover:text-teal-600'
            }`}
            onClick={() => handleVote(1)}
            disabled={voteLoading}
          >
            <ArrowUp className="w-6 h-6" />
          </button>
          <span className={`font-medium my-1 ${
            votes > 0 ? 'text-teal-600' : votes < 0 ? 'text-pink-600' : 'text-gray-700'
          }`}>
            {votes}
          </span>
          <button 
            className={`p-1 rounded transition-colors transform rotate-180 ${
              userVote === -1 
                ? 'text-pink-600'
                : 'text-gray-400 hover:text-pink-600'
            }`}
            onClick={() => handleVote(-1)}
            disabled={voteLoading}
          >
            <ArrowUp className="w-6 h-6" />
          </button>
        </div>

        {/* Content */}
        <div className="flex-1">
          {/* Post metadata */}
          <div className="mb-2 text-sm text-gray-500">
            {post.community_name || post.community ? (
              <Link to={`/community/${post.community_id}`} className="font-medium text-teal-600 hover:underline">
                r/{post.community_name || post.community}
              </Link>
            ) : (
              <span className="font-medium">Posted by {post.username || 'Anonymous'}</span>
            )}
            <span className="mx-1"></span>
            <span>{formattedTime}</span>
          </div>
          
          {/* Post title and content */}
          <h1 className="text-2xl font-bold mb-2">{post.title}</h1>
          <div className="text-gray-800 mb-4 whitespace-pre-line">
            {post.content}
          </div>
          
          {/* Post tags/categories if available */}
          {post.tags && post.tags.length > 0 && (
            <div className="flex flex-wrap gap-2 mb-4">
              {post.tags.map((tag: string) => (
                <span key={tag} className="px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-full">
                  {tag}
                </span>
              ))}
            </div>
          )}
        </div>
      </div>
      
      {/* Post Actions */}
      <div className="mt-4 pt-3 border-t border-gray-100 flex space-x-6">
        <button className="flex items-center text-gray-500 hover:text-teal-600 transition-colors">
          <MessageSquare className="w-5 h-5 mr-1" />
          <span>Comments</span>
        </button>
        
        <button className="flex items-center text-gray-500 hover:text-pink-600 transition-colors">
          <Share2 className="w-5 h-5 mr-1" />
          <span>Share</span>
        </button>
        
        <button className="flex items-center text-gray-500 hover:text-purple-600 transition-colors">
          <Bookmark className="w-5 h-5 mr-1" />
          <span>Save</span>
        </button>
      </div>
    </div>
  )
}

================
File: src/components/PostCreationForm.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import { getEnhancedCommunitySettings } from '../api/moderation';

interface PostCreationFormProps {
  communityId: string;
  onPostCreated?: () => void;
}

const PostCreationForm: React.FC<PostCreationFormProps> = ({ communityId, onPostCreated }) => {
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [requiresApproval, setRequiresApproval] = useState(false);
  const { user, token } = useAuth();
  const navigate = useNavigate();

  useEffect(() => {
    // Check if community requires post approval
    const checkCommunitySettings = async () => {
      if (!token) return;
      
      try {
        const settings = await getEnhancedCommunitySettings(communityId, token);
        setRequiresApproval(settings.require_post_approval);
      } catch (err) {
        console.error('Error fetching community settings:', err);
      }
    };
    
    checkCommunitySettings();
  }, [communityId, token]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!title.trim() || !content.trim()) {
      setError('Title and content are required');
      return;
    }
    
    if (!user || !token) {
      setError('You must be logged in to create a post');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const API_BASE_URL = 'http://localhost:3001';
      const response = await fetch(`${API_BASE_URL}/api/posts`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          title,
          content,
          communityId
        })
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || 'Failed to create post');
      }
      
      const newPost = await response.json();
      
      // Clear form
      setTitle('');
      setContent('');
      
      // Notify parent component
      if (onPostCreated) {
        onPostCreated();
      }
      
      // Check if post is pending approval
      if (newPost.pending_approval) {
        alert('Your post has been submitted and is pending moderator approval.');
        navigate(`/c/${communityId}`);
      } else {
        // Navigate to the new post
        navigate(`/posts/${newPost.id}`);
      }
    } catch (err: any) {
      console.error('Error creating post:', err);
      setError(err.message || 'Failed to create post');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow p-4 mb-4">
      <h2 className="text-xl font-semibold mb-4">Create a Post</h2>
      
      {requiresApproval && (
        <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
          <p className="font-bold">Note:</p>
          <p>Posts in this community require moderator approval before they are visible to other users.</p>
        </div>
      )}
      
      {error && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          {error}
        </div>
      )}
      
      <form onSubmit={handleSubmit}>
        <div className="mb-4">
          <label htmlFor="title" className="block text-gray-700 font-medium mb-2">Title</label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Give your post a title"
            required
          />
        </div>
        
        <div className="mb-4">
          <label htmlFor="content" className="block text-gray-700 font-medium mb-2">Content</label>
          <textarea
            id="content"
            value={content}
            onChange={(e) => setContent(e.target.value)}
            className="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            rows={6}
            placeholder="What do you want to share?"
            required
          ></textarea>
        </div>
        
        <div className="flex justify-end">
          <button
            type="submit"
            className="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
            disabled={loading}
          >
            {loading ? 'Creating...' : 'Create Post'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default PostCreationForm;

================
File: src/components/PostItem.tsx
================
import React, { useState } from 'react'
import { Link } from 'react-router-dom'
import { ArrowUp, MessageCircle, Share2 } from 'lucide-react'
import { useAuth } from '../context/AuthContext'
import { voteOnPost } from '../api/votes'
import { formatDistanceToNow } from 'date-fns'

interface PostItemProps {
  post: {
    id: string;
    title: string;
    content: string;
    username: string;
    timestamp: string;
    comments: number;
    votes: number;
    community_id?: string;
    community_name?: string;
  };
  communityId?: string | null;
  compact?: boolean;
}

export default function PostItem({ post, communityId, compact = false }: PostItemProps) {
  const { user, token } = useAuth();
  const [votes, setVotes] = useState(post.votes || 0);
  const [userVote, setUserVote] = useState(0); // 0 = no vote, 1 = upvote, -1 = downvote
  const [voteLoading, setVoteLoading] = useState(false);

  // Format timestamp to relative time (e.g., "2 hours ago")
  const formattedTime = post.timestamp 
    ? formatDistanceToNow(new Date(post.timestamp), { addSuffix: true })
    : 'unknown time';

  const handleVote = async (voteValue: number) => {
    if (!user || !token) {
      // Prompt to login if not authenticated
      alert('Please log in to vote');
      return;
    }
    
    if (voteLoading) return;
    
    try {
      setVoteLoading(true);
      
      // Determine the new vote value
      let newVoteValue = voteValue;
      
      // If user clicks the same vote button again, remove the vote
      if (userVote === voteValue) {
        newVoteValue = 0;
      }
      
      // Calculate the vote difference for optimistic UI update
      const voteDifference = newVoteValue - userVote;
      
      // Update UI optimistically
      setUserVote(newVoteValue);
      setVotes(prev => prev + voteDifference);
      
      // Make API call
      await voteOnPost(post.id, newVoteValue, token);
    } catch (err) {
      console.error('Error voting:', err);
      
      // Revert optimistic updates on failure
      setUserVote(userVote);
      setVotes(post.votes);
      
      // Show error message
      alert('Failed to vote. Please try again.');
    } finally {
      setVoteLoading(false);
    }
  };

  // Render a more compact version when compact prop is true
  if (compact) {
    return (
      <div className="bg-white p-2 shadow-sm rounded-sm border-l-2 border-purple-400 hover:border-l-4 transition-all">
        <Link 
          to={`/post/${post.id}`} 
          className="block hover:text-purple-600 transition-colors"
        >
          <h3 className="font-medium text-sm text-gray-900 truncate">{post.title}</h3>
        </Link>
        <div className="text-xs text-gray-500 flex items-center mt-1">
          <span>{votes} votes</span>
          <span className="mx-1"></span>
          <span>{post.comments} comments</span>
        </div>
      </div>
    );
  }

  // Regular post card
  return (
    <div className="bg-white p-4 shadow-sm rounded-sm transform hover:scale-[1.01] transition-transform border-l-4 border-teal-400">
      <div className="flex items-start space-x-4">
        {/* Voting */}
        <div className="flex flex-col items-center">
          <button 
            className={`p-1 rounded-sm transition-colors ${
              userVote === 1 
                ? 'text-teal-600'
                : 'text-gray-400 hover:text-teal-600'
            }`}
            onClick={() => handleVote(1)}
            disabled={voteLoading}
          >
            <ArrowUp className="w-5 h-5" />
          </button>
          <span className={`text-sm font-medium ${
            votes > 0 ? 'text-teal-600' : votes < 0 ? 'text-pink-600' : 'text-gray-600'
          }`}>
            {votes}
          </span>
          <button 
            className={`p-1 rounded-sm transition-colors transform rotate-180 ${
              userVote === -1 
                ? 'text-pink-600'
                : 'text-gray-400 hover:text-pink-600'
            }`}
            onClick={() => handleVote(-1)}
            disabled={voteLoading}
          >
            <ArrowUp className="w-5 h-5" />
          </button>
        </div>

        {/* Content */}
        <div className="flex-1">
          {/* Community and metadata */}
          <div className="mb-1 text-xs text-gray-500 flex items-center">
            {post.community_name && !communityId && (
              <>
                <Link 
                  to={`/community/${post.community_id}`}
                  className="font-medium text-teal-600 hover:underline"
                >
                  r/{post.community_name}
                </Link>
                <span className="mx-1"></span>
              </>
            )}
            <span>Posted by {post.username}</span>
            <span className="mx-1"></span>
            <span>{formattedTime}</span>
          </div>
          
          {/* Title and content */}
          <Link 
            to={`/post/${post.id}`} 
            className="block hover:text-teal-600 transition-colors"
          >
            <h3 className="font-bold text-gray-900">{post.title}</h3>
          </Link>
          <p className="text-sm text-gray-600 mt-1 line-clamp-2">{post.content}</p>
          
          {/* Actions */}
          <div className="mt-2 flex items-center space-x-4 text-xs text-gray-500">
            <Link
              to={`/post/${post.id}`}
              className="flex items-center space-x-1 hover:text-teal-600 transition-colors"
            >
              <MessageCircle className="w-4 h-4" />
              <span>{post.comments} comment{post.comments !== 1 ? 's' : ''}</span>
            </Link>
            
            <button className="flex items-center space-x-1 hover:text-pink-600 transition-colors">
              <Share2 className="w-4 h-4" />
              <span>Share</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/PostList.tsx
================
import React, { useState, useEffect } from 'react';
import PostItem from './PostItem';
import { useAuth } from '../context/AuthContext';
import { getCommunityPosts } from '../api/compatibility';
import { getPosts } from '../api/posts';
import { getCommentCount } from '../api/comments';

interface Post {
  id: string;
  title: string;
  content: string;
  username: string;
  timestamp: string;
  comments: number;
  votes: number;
  privacy?: 'public' | 'private';
}

interface PostListProps {
  communityId?: string | null;
  postType?: 'trending' | 'all' | 'following';
  maxPosts?: number;
  compact?: boolean;
}

export default function PostList({ communityId, postType = 'all', maxPosts, compact = false }: PostListProps) {
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { token } = useAuth();

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        
        let data;
        if (communityId) {
          // Use our compatibility layer for community-specific posts
          data = await getCommunityPosts(communityId, token);
        } else {
          // Use the posts API directly for all posts based on the post type
          const params: Record<string, string> = {};
          
          if (postType === 'trending') {
            params.sort = 'trending';
          } else if (postType === 'all') {
            params.sort = 'new';
          } else if (postType === 'following') {
            params.following = 'true';
          }
          
          data = await getPosts(null, token);
          
          // Sort the posts based on post type if the API doesn't support it yet
          if (postType === 'trending' && data.length > 0) {
            // Sort by highest vote count as a proxy for trending
            data.sort((a: any, b: any) => (b.votes || 0) - (a.votes || 0));
          } else if (postType === 'all' && data.length > 0) {
            // Sort by creation date, newest first
            data.sort((a: any, b: any) => {
              return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
            });
          }
          // For 'following', we would filter for posts from communities the user follows
          // This would typically be handled by the API, but we've left it as-is for now
        }
        
        // Convert the data to our Post interface format
        const formattedPosts = data.map((post: any) => ({
          id: post.id,
          title: post.title || 'Untitled Post',
          content: post.content || '',
          username: post.username || 'Unknown User',
          timestamp: post.created_at || new Date().toISOString(),
          comments: post.comments_count || 0, // Use the comments_count property if available
          votes: post.votes_count || post.vote_count || 0, // Use any available vote count property
          community_id: post.community_id || null,
          community_name: post.community_name || post.community || null
        }));
        
        // For each post, try to fetch the comment count if it's not already included
        const postsWithComments = await Promise.all(
          formattedPosts.map(async (post) => {
            // If comments is already set to a non-zero value, keep it
            if (post.comments > 0) {
              return post;
            }
            
            try {
              // Otherwise try to fetch the comment count
              const count = await getCommentCount(post.id);
              return { ...post, comments: count };
            } catch (err) {
              // If fetching fails, keep the original count
              return post;
            }
          })
        );
        
        setPosts(postsWithComments);
      } catch (error: unknown) {
        console.error('Error fetching posts:', error);
        if (error instanceof Error) {
          setError(error.message);
        } else {
          setError('An unknown error occurred');
        }
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [communityId, token, postType]);

  if (loading) {
    return <div>Loading posts...</div>;
  }

  if (error) {
    return <div>Error loading posts: {error}</div>;
  }

  if (posts.length === 0) {
    return (
      <div className="text-center py-8">
        <h3 className="text-lg font-medium text-gray-600">No posts found</h3>
        <p className="text-gray-500 mt-2">
          {communityId 
            ? "Be the first to create a post in this community!" 
            : "No posts available. Try creating a new post or joining communities."}
        </p>
      </div>
    );
  }

  // Apply maxPosts limit if provided
  const displayPosts = maxPosts ? posts.slice(0, maxPosts) : posts;

  return (
    <div className={`${compact ? 'space-y-1' : 'space-y-4'}`}>
      {displayPosts.map(post => (
        <PostItem 
          key={post.id} 
          post={post}
          communityId={communityId}
          compact={compact}
        />
      ))}
    </div>
  );
}

================
File: src/components/ProfileActions.tsx
================
import React from 'react'
import { useAuth } from '../context/AuthContext'

interface ProfileActionsProps {
  onEditProfile: () => void;
}

export default function ProfileActions({ onEditProfile }: ProfileActionsProps) {
  const { logout } = useAuth()
  
  const handleLogout = () => {
    logout()
    // Redirect to login page happens automatically via AuthContext
  }
  
  return (
    <div className="bg-black text-white p-6 transform -rotate-0.5 shadow-md">
      <div className="space-y-4">
        <button 
          className="w-full px-4 py-3 bg-gray-900 text-white uppercase tracking-wider hover:bg-gray-800 transition-transform transform hover:translate-x-1 border-l-2 border-teal-400 shadow-md relative overflow-hidden group"
          onClick={onEditProfile}
        >
          <span className="relative z-10">Edit Profile</span>
          <span className="absolute bottom-0 left-0 w-0 h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 group-hover:w-full transition-all duration-300"></span>
        </button>
        
        <button className="w-full px-4 py-3 bg-gray-900 text-white uppercase tracking-wider hover:bg-gray-800 transition-transform transform hover:translate-x-1 border-l-2 border-pink-400 shadow-md relative overflow-hidden group">
          <span className="relative z-10">Settings</span>
          <span className="absolute bottom-0 left-0 w-0 h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 group-hover:w-full transition-all duration-300"></span>
        </button>
        
        <button 
          className="w-full px-4 py-3 bg-gray-900 text-white uppercase tracking-wider hover:bg-gray-800 transition-transform transform hover:translate-x-1 border-l-2 border-purple-400 shadow-md relative overflow-hidden group"
          onClick={handleLogout}
        >
          <span className="relative z-10">Logout</span>
          <span className="absolute bottom-0 left-0 w-0 h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 group-hover:w-full transition-all duration-300"></span>
        </button>
      </div>
    </div>
  )
}

================
File: src/components/Sidebar.tsx
================
import React, { useState, useEffect } from 'react'
import { Link } from 'react-router-dom'
import { getCommunities } from '../api/communities'
import { useAuth } from '../context/AuthContext'

export default function Sidebar() {
  const [communities, setCommunities] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const { isAuthenticated, user } = useAuth()

  useEffect(() => {
    const fetchCommunities = async () => {
      try {
        setLoading(true)
        const data = await getCommunities()
        setCommunities(data)
      } catch (error) {
        console.error('Failed to fetch communities:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchCommunities()
  }, [])

  return (
    <div className="space-y-8 font-mono">
      {/* User Section - Only show if logged in */}
      {isAuthenticated && user && (
        <div className="bg-gray-900 text-white p-6 relative transform -rotate-1 shadow-lg">
          <div className="absolute -top-4 -right-4 bg-white text-black px-3 py-1 text-xs uppercase transform rotate-3 shadow-md">
            <span className="text-teal-500">Y</span>
            <span className="text-pink-500">O</span>
            <span className="text-purple-500">U</span>
          </div>
          <h2 className="font-bold mb-4 uppercase text-xl">{user.username}</h2>
          <div className="space-y-3 bg-gray-800 p-3 ml-4 border-l-2 border-teal-400">
            <Link to="/profile" className="block text-sm font-bold hover:text-teal-300 uppercase">
              Profile
            </Link>
            <Link to="/profile/posts" className="block text-sm hover:text-pink-300 uppercase">
              Your Posts
            </Link>
            <Link to="/profile/comments" className="block text-sm hover:text-purple-300 uppercase">
              Your Comments
            </Link>
          </div>
        </div>
      )}

      {/* Quick Links */}
      <div className="bg-gray-100 p-6 transform rotate-1 shadow-md">
        <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
          Quick Links
          <span className="absolute bottom-0 left-0 w-full h-1 bg-teal-400"></span>
        </h2>
        <div className="space-y-3 ml-2">
          <Link to="/communities" className="block text-sm uppercase hover:ml-2 transition-all hover:text-teal-600">
            All Communities
          </Link>
          <Link to="/communities?sort=popular" className="block text-sm uppercase hover:ml-2 transition-all hover:text-pink-600">
            Popular Communities
          </Link>
          <Link to="/communities?sort=new" className="block text-sm uppercase hover:ml-2 transition-all hover:text-purple-600">
            New Communities
          </Link>
          <Link to="/communities" className="block text-sm font-bold uppercase mt-6 bg-black text-white p-2 text-center hover:bg-gray-800 transition-colors shadow-sm relative overflow-hidden group">
            <span className="relative z-10">+ Create a Community</span>
            <span className="absolute bottom-0 left-0 w-0 h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 group-hover:w-full transition-all duration-300"></span>
          </Link>
        </div>
      </div>

      {/* Popular Communities */}
      <div className="bg-gray-100 p-6 transform -rotate-0.5 shadow-md">
        <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
          Popular Communities
          <span className="absolute bottom-0 left-0 w-full h-1 bg-pink-400"></span>
        </h2>
        {loading ? (
          <div className="text-sm uppercase tracking-widest animate-pulse p-4 bg-white text-center shadow-inner">Loading...</div>
        ) : (
          <div className="space-y-3">
            {communities.slice(0, 5).map((community, index) => (
              <Link
                key={community.id}
                to={`/community/${community.id}`}
                className={`block text-sm hover:ml-2 transition-all p-2 hover:bg-white ${
                  index % 3 === 0 ? 'border-l-2 border-teal-400' : 
                  index % 3 === 1 ? 'border-l-2 border-pink-400' : 
                  'border-l-2 border-purple-400'
                }`}
              >
                r/{community.name}
              </Link>
            ))}
            {communities.length === 0 && (
              <div className="text-sm bg-white p-4 text-center uppercase shadow-inner">No communities found</div>
            )}
          </div>
        )}
      </div>

      {/* About Section */}
      <div className="bg-black text-white p-6 transform rotate-0.5 shadow-lg">
        <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
          About Rumfor
          <span className="absolute bottom-0 left-0 w-full h-1 bg-purple-400"></span>
        </h2>
        <p className="text-sm mb-4 ml-4 border-l-2 border-teal-400 pl-2">
          Rumfor is a community platform where you can join communities, share posts, and connect with others.
        </p>
        <div className="text-xs uppercase tracking-widest text-center bg-gray-800 p-2 mt-4">
          <span className="text-teal-400"></span> 2025 <span className="text-pink-400">R</span>umfor
        </div>
      </div>
    </div>
  )
}

================
File: src/components/UserInfo.tsx
================
import React from 'react'

interface UserData {
  id?: string;
  username?: string;
  email?: string;
  role?: string;
  bio?: string;
  avatar_url?: string;
  post_count?: number;
  comment_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
  last_active?: string;
}

interface UserInfoProps {
  username: string;
  userData?: UserData;
  isCurrentUser?: boolean;
  onEditProfile?: () => void;
}

export default function UserInfo({ username, userData, isCurrentUser = false, onEditProfile }: UserInfoProps) {
  // Display a default username if none is provided
  const displayName = username || 'anonymous'
  
  return (
    <div className="bg-black text-white p-6 transform rotate-0.5 shadow-md">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          {/* Profile Picture Placeholder */}
          <div className="w-16 h-16 bg-gray-800 rounded-none transform -rotate-3 shadow-md border-2 border-teal-400 relative overflow-hidden">
            {/* Placeholder Icon */}
            <div className="absolute inset-0 flex items-center justify-center text-gray-600">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-10 w-10" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
              </svg>
            </div>
          </div>
          
          <div>
            <h1 className="text-xl font-bold uppercase">{displayName}</h1>
            <p className="text-sm text-gray-400">Member since 2023</p>
          </div>
        </div>
        
        {/* Edit Profile Button - Only shown for current user */}
        {isCurrentUser && onEditProfile && (
          <button 
            onClick={onEditProfile}
            className="px-3 py-2 bg-gray-900 text-white uppercase tracking-wider hover:bg-gray-800 transition-transform transform hover:translate-x-1 border-l-2 border-teal-400 shadow-md text-sm"
          >
            Edit Profile
          </button>
        )}
      </div>
      
      <div className="mt-6 bg-gray-900 p-4 border-l-2 border-pink-400">
        <p className="text-gray-300">
          {userData?.bio || 'No bio yet'}
        </p>
      </div>
      
      <div className="mt-4 space-y-2">
        <div className="flex justify-between">
          <span className="text-gray-400">Posts</span>
          <span className="text-teal-400 font-bold">{userData?.post_count || '-'}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Comments</span>
          <span className="text-pink-400 font-bold">{userData?.comment_count || '-'}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Communities</span>
          <span className="text-purple-400 font-bold">{userData?.communities_joined || '-'}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Upvotes</span>
          <span className="text-teal-400 font-bold">{userData?.upvotes_received || '-'}</span>
        </div>
        <div className="flex justify-between">
          <span className="text-gray-400">Downvotes</span>
          <span className="text-pink-400 font-bold">{userData?.downvotes_received || '-'}</span>
        </div>
      </div>
    </div>
  )
}

================
File: src/components/UserPosts.tsx
================
import React from 'react'

interface Post {
  id: string;
  title?: string;
  content: string;
  timestamp?: string;
  likes?: number;
  comments?: number;
  userId?: string;
  username?: string;
  communityId?: string;
  community?: string;
  created_at?: string;
}

interface UserPostsProps {
  username: string;
  posts?: Post[];
}

export default function UserPosts({ username, posts = [] }: UserPostsProps) {
  return (
    <div className="space-y-6">
      {posts.length === 0 ? (
        <div className="text-center py-12 bg-black text-white">
          <span className="text-2xl uppercase font-bold tracking-wider">EMPTY</span>
          <p className="mt-4 text-gray-300">No posts yet.</p>
        </div>
      ) : (
        posts.map((post, index) => (
          <div 
            key={post.id}
            className={`bg-white p-6 shadow-md transform relative ${index % 2 === 0 ? 'rotate-0.5' : '-rotate-0.5'}`}
          >
            <div className={`absolute top-0 left-0 w-1 h-full ${
              index % 3 === 0 ? 'bg-teal-400' : 
              index % 3 === 1 ? 'bg-pink-400' : 
              'bg-purple-400'
            }`}></div>
            
            <div className="flex justify-between items-start">
              <div>
                <h3 className="font-bold text-xl">{post.title || 'Untitled Post'}</h3>
                <div className="flex items-center space-x-2 text-xs text-gray-500 mt-1">
                  <span>Posted {post.timestamp || post.created_at || 'recently'}</span>
                  {post.community && (
                    <>
                      <span></span>
                      <span>in r/{post.community}</span>
                    </>
                  )}
                </div>
              </div>
            </div>
            
            <p className="mt-4 text-gray-800">{post.content}</p>
            
            <div className="mt-4 flex items-center space-x-6 text-sm">
              <div className="flex items-center space-x-1">
                <span className="text-pink-500"></span>
                <span>{post.likes || 0} likes</span>
              </div>
              <div className="flex items-center space-x-1">
                <span className="text-teal-500"></span>
                <span>{post.comments || 0} comments</span>
              </div>
            </div>
          </div>
        ))
      )}
    </div>
  )
}

================
File: src/context/AuthContext.tsx
================
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';

// Define the User type
interface User {
  id: string;
  username: string;
  email: string;
  role: string;
  bio?: string;
  avatar_url?: string;
  post_count?: number;
  comment_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
  last_active?: string;
}

// Define the AuthContext type
interface AuthContextType {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (username: string, password: string) => Promise<void>;
  register: (username: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  loading: boolean;
  error: string | null;
}

// Create the AuthContext
export const AuthContext = createContext<AuthContextType>({
  user: null,
  token: null,
  isAuthenticated: false,
  login: async () => {},
  register: async () => {},
  logout: () => {},
  loading: false,
  error: null
});

// API base URL
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001';

// AuthProvider component
export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [token, setToken] = useState<string | null>(localStorage.getItem('token'));
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [initializing, setInitializing] = useState<boolean>(true);

  // Check if user is authenticated
  const isAuthenticated = !!token && !!user;

  // Load user from token on mount
  useEffect(() => {
    const loadUser = async () => {
      if (!token) {
        setInitializing(false);
        return;
      }

      try {
        const response = await fetch(`${API_BASE_URL}/api/auth/me`, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const userData = await response.json();
          setUser(userData);
        } else {
          // Token is invalid or expired
          localStorage.removeItem('token');
          setToken(null);
        }
      } catch (error) {
        console.error('Failed to load user:', error);
      } finally {
        setInitializing(false);
      }
    };

    loadUser();
  }, [token]);

  // Login function
  const login = async (username: string, password: string) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ username, password })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Login failed');
      }

      const data = await response.json();
      
      // Save token to localStorage
      localStorage.setItem('token', data.token);
      
      // Update state
      setToken(data.token);
      setUser(data.user);
    } catch (error: any) {
      setError(error.message);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Register function
  const register = async (username: string, email: string, password: string) => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`${API_BASE_URL}/api/auth/register`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ username, email, password })
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Registration failed');
      }

      // After registration, automatically log in
      await login(username, password);
    } catch (error: any) {
      setError(error.message);
      throw error;
    } finally {
      setLoading(false);
    }
  };

  // Logout function
  const logout = () => {
    localStorage.removeItem('token');
    setToken(null);
    setUser(null);
  };

  // Create the context value
  const contextValue: AuthContextType = {
    user,
    token,
    isAuthenticated,
    login,
    register,
    logout,
    loading,
    error
  };

  // Render the provider
  return (
    <AuthContext.Provider value={contextValue}>
      {!initializing && children}
    </AuthContext.Provider>
  );
};

// Custom hook to use the AuthContext
export const useAuth = () => useContext(AuthContext);

================
File: src/context/CommunityContext.tsx
================
import { createContext, useContext, useState, ReactNode } from 'react';
import { Community } from "../types";

type CommunityContextType = {
  communities: Community[];
  currentCommunity: Community | null;
  loading: boolean;
  error: string | null;
  setCommunities: (communities: Community[]) => void;
  setCurrentCommunity: (community: Community) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
};

const CommunityContext = createContext<CommunityContextType>({
  communities: [],
  currentCommunity: null,
  loading: false,
  error: null,
  setCommunities: () => {},
  setCurrentCommunity: () => {},
  setLoading: () => {},
  setError: () => {},
});

export const CommunityProvider = ({ children }: { children: ReactNode }) => {
  const [communities, setCommunities] = useState<Community[]>([]);
  const [currentCommunity, setCurrentCommunity] = useState<Community | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  return (
    <CommunityContext.Provider
      value={{
        communities,
        currentCommunity,
        loading,
        error,
        setCommunities,
        setCurrentCommunity,
        setLoading,
        setError,
      }}
    >
      {children}
    </CommunityContext.Provider>
  );
};

export const useCommunity = () => {
  const context = useContext(CommunityContext);
  console.log('CommunityContext initialized with types:', context);
  return context;
};

================
File: src/debug/ModeratorDebug.tsx
================
import React, { useEffect, useState } from 'react';
import { getCommunityMembers } from '../api/communities';

interface Props {
  communityId: string;
}

/**
 * This is a debug component that we can place in the UI to see what's 
 * happening with the moderator data
 */
export default function ModeratorDebug({ communityId }: Props) {
  const [rawData, setRawData] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true);
        
        // Get raw members data to see what's in it
        const members = await getCommunityMembers(communityId);
        setRawData(members);
        
        // Look specifically at members with role = 'moderator' or 'admin'
        const mods = members.filter((member: any) => 
          member.role === 'moderator' || member.role === 'admin'
        );
        
        console.log('Raw members data:', members);
        console.log('Moderator data:', mods);
        
      } catch (err) {
        console.error('Error fetching data:', err);
        setError('Failed to fetch data');
      } finally {
        setLoading(false);
      }
    }
    
    fetchData();
  }, [communityId]);
  
  return (
    <div className="bg-black text-white p-4 max-w-lg rounded-lg">
      <h3 className="text-xl font-bold mb-2">Moderator Debug</h3>
      
      {loading && <p>Loading...</p>}
      {error && <p className="text-red-500">{error}</p>}
      
      {rawData && (
        <div>
          <h4 className="text-lg font-semibold mt-2">Raw Member Data Structure</h4>
          <pre className="text-xs bg-gray-900 p-2 rounded overflow-auto max-h-40 mt-1">
            {JSON.stringify(rawData[0] || {}, null, 2)}
          </pre>
          
          <h4 className="text-lg font-semibold mt-4">Moderators</h4>
          <ul className="mt-1">
            {rawData
              .filter((m: any) => m.role === 'moderator' || m.role === 'admin')
              .map((mod: any, i: number) => (
                <li key={i} className="border-b border-gray-700 py-1">
                  <span className="text-blue-400">ID:</span> {mod.user_id}<br/>
                  <span className="text-blue-400">Username:</span> {mod.username || 'Not available'}<br/>
                  <span className="text-blue-400">Role:</span> {mod.role}
                </li>
              ))
            }
          </ul>
        </div>
      )}
    </div>
  );
}

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Wireframe Styles */
.wireframe-border {
  border: 1px solid rgba(0,0,0,0.15);
}

.wireframe-shadow {
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.wireframe-input {
  @apply border border-gray-300 outline-none focus:border-gray-500 transition-all duration-200;
}

.wireframe-link {
  text-decoration: none;
  position: relative;
  transition: all 0.2s ease;
}

.wireframe-link::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 1px;
  bottom: -2px;
  left: 0;
  background-color: rgba(0,0,0,0.6);
  visibility: hidden;
  transform: scaleX(0);
  transition: all 0.2s ease;
}

.wireframe-link:hover::after {
  visibility: visible;
  transform: scaleX(1);
}

.wireframe-divider {
  border-bottom: 1px solid rgba(0,0,0,0.15);
}

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { RouterProvider } from 'react-router-dom'
import { router } from './routes'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <RouterProvider router={router} />
  </StrictMode>
)

================
File: src/pages/Communities.tsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import CommunitySearch from '../components/CommunitySearch';
import CommunityList from '../components/CommunityList';
import CreateCommunityModal from '../components/CreateCommunityModal';
import CommunityDiscoverySidebar from '../components/CommunityDiscoverySidebar';
import { getCommunities } from '../api/communities';
import { useAuth } from '../context/AuthContext';
import JoinCommunityButton from '../components/JoinCommunityButton';

interface Community {
  id: string;
  name: string;
  description: string;
  created_at: string;
  updated_at: string;
  privacy?: 'public' | 'private';
}

export default function Communities() {
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [communities, setCommunities] = useState<Community[]>([]);
  const [allCommunities, setAllCommunities] = useState<Community[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isSearching, setIsSearching] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [expandedCommunityId, setExpandedCommunityId] = useState<string | null>(null);
  const [communitySearchTerms, setCommunitySearchTerms] = useState<Record<string, string>>({});
  const [sortBy, setSortBy] = useState<'trending' | 'new' | 'popular' | 'active'>('trending');
  const [filterBy, setFilterBy] = useState<'all' | 'public' | 'private'>('all');
  const [viewMode, setViewMode] = useState<'list' | 'compact'>('list');
  const navigate = useNavigate();
  const { isAuthenticated, token } = useAuth();
  
  // Function to toggle community expansion
  const toggleCommunityExpansion = (communityId: string) => {
    setExpandedCommunityId(expandedCommunityId === communityId ? null : communityId);
  };
  
  // Function to update a community's search term
  const updateCommunitySearchTerm = (communityId: string, term: string) => {
    setCommunitySearchTerms(prev => ({
      ...prev,
      [communityId]: term
    }));
  };
  
  // Sort communities based on selected criteria
  const sortCommunities = (sortType: 'trending' | 'new' | 'popular' | 'active') => {
    setSortBy(sortType);
    
    let sorted = [...allCommunities];
    
    switch (sortType) {
      case 'new':
        // Sort by creation date (newest first)
        sorted = sorted.sort((a, b) => 
          new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
        );
        break;
      case 'popular':
        // For a real app, this would be based on member count
        // Here we'll use the index for demo purposes
        sorted = sorted.sort((a, b) => {
          const aIndex = parseInt(a.id) || 0;
          const bIndex = parseInt(b.id) || 0;
          return (bIndex * 42 + 12) - (aIndex * 42 + 12);
        });
        break;
      case 'active':
        // For a real app, this would be based on recent posts
        // Here we'll use the id for demo purposes
        sorted = sorted.sort((a, b) => {
          const aIndex = parseInt(a.id) || 0;
          const bIndex = parseInt(b.id) || 0;
          return (bIndex * 17 + 8) - (aIndex * 17 + 8);
        });
        break;
      default: // 'trending'
        // In a real app, this would be a complex algorithm
        // For demo, we'll shuffle a bit using both creation date and id
        sorted = sorted.sort((a, b) => {
          const dateA = new Date(a.created_at).getTime();
          const dateB = new Date(b.created_at).getTime();
          const idA = parseInt(a.id) || 0;
          const idB = parseInt(b.id) || 0;
          
          return (dateB + idB) - (dateA + idA);
        });
    }
    
    // Apply filtering
    applyFilters(sorted);
  };
  
  // Filter communities based on selected criteria
  const filterCommunities = (filterType: 'all' | 'public' | 'private') => {
    setFilterBy(filterType);
    applyFilters([...allCommunities]);
  };
  
  // Apply current filters to the communities
  const applyFilters = (communitiesToFilter: Community[]) => {
    let filtered = communitiesToFilter;
    
    // Apply privacy filter
    if (filterBy !== 'all') {
      filtered = filtered.filter(community => 
        filterBy === 'private' ? community.privacy === 'private' : community.privacy !== 'private'
      );
    }
    
    setCommunities(filtered);
  };

  const fetchCommunities = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await getCommunities();
      setAllCommunities(data);
      
      // Apply current sorting and filtering
      let processedData = [...data];
      
      // Sort based on current sortBy value
      switch (sortBy) {
        case 'new':
          processedData.sort((a, b) => 
            new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
          );
          break;
        case 'popular':
          processedData.sort((a, b) => {
            const aIndex = parseInt(a.id) || 0;
            const bIndex = parseInt(b.id) || 0;
            return (bIndex * 42 + 12) - (aIndex * 42 + 12);
          });
          break;
        case 'active':
          processedData.sort((a, b) => {
            const aIndex = parseInt(a.id) || 0;
            const bIndex = parseInt(b.id) || 0;
            return (bIndex * 17 + 8) - (aIndex * 17 + 8);
          });
          break;
        default: // 'trending'
          processedData.sort((a, b) => {
            const dateA = new Date(a.created_at).getTime();
            const dateB = new Date(b.created_at).getTime();
            const idA = parseInt(a.id) || 0;
            const idB = parseInt(b.id) || 0;
            
            return (dateB + idB) - (dateA + idA);
          });
      }
      
      // Apply filter
      if (filterBy !== 'all') {
        processedData = processedData.filter(community => 
          filterBy === 'private' ? community.privacy === 'private' : community.privacy !== 'private'
        );
      }
      
      setCommunities(processedData);
    } catch (err) {
      console.error('Failed to fetch communities:', err);
      setError('Failed to load communities');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchCommunities();
  }, []);

  const handleCommunityCreated = (communityId: string) => {
    // Refresh the communities list
    fetchCommunities();

    // Navigate to the new community page
    navigate(`/community/${communityId}`);
  };

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!searchTerm.trim()) {
      return;
    }

    try {
      setIsSearching(true);

      const results = await getCommunities(searchTerm);
      setCommunities(results);
    } catch (error: unknown) {
      if (error instanceof Error) {
        setError(error.message);
      } else {
        setError('An unexpected error occurred');
      }
    } finally {
      setIsSearching(false);
    }
  };

    // Join functionality is now handled by the JoinCommunityButton component

  return (
    <div className="w-full font-mono bg-gray-50">
      {/* Filter/Sorting bar - always visible */}
      <div className="w-full bg-black text-white py-2 px-4 flex items-center justify-between sticky top-0 z-20 shadow-md">
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-2 text-sm">
            <span className="text-gray-400">Sort:</span>
            <select 
              className="bg-gray-800 text-white border-none rounded px-2 py-1 text-xs cursor-pointer"
              value={sortBy}
              onChange={(e) => sortCommunities(e.target.value as 'trending' | 'new' | 'popular' | 'active')}
            >
              <option value="trending">Trending</option>
              <option value="new">Newest</option>
              <option value="popular">Most Popular</option>
              <option value="active">Most Active</option>
            </select>
          </div>
          
          <div className="hidden md:flex items-center space-x-2">
            <span className="text-gray-400 text-sm">Filter:</span>
            <div className="flex space-x-1">
              <button 
                className={`px-2 py-1 rounded text-xs transition-colors ${
                  filterBy === 'all' ? 'bg-teal-600 text-white' : 'bg-gray-800 hover:bg-gray-700'
                }`}
                onClick={() => filterCommunities('all')}
              >
                All
              </button>
              <button 
                className={`px-2 py-1 rounded text-xs transition-colors ${
                  filterBy === 'public' ? 'bg-teal-600 text-white' : 'bg-gray-800 hover:bg-gray-700'
                }`}
                onClick={() => filterCommunities('public')}
              >
                Public
              </button>
              <button 
                className={`px-2 py-1 rounded text-xs transition-colors ${
                  filterBy === 'private' ? 'bg-teal-600 text-white' : 'bg-gray-800 hover:bg-gray-700'
                }`}
                onClick={() => filterCommunities('private')}
              >
                Private
              </button>
            </div>
          </div>
        </div>
        
        <div className="flex items-center space-x-2 text-sm">
          {/* View toggle - list vs. compact */}
          <div className="hidden md:flex items-center mr-2 border-r border-gray-700 pr-3">
            <span className="text-gray-400 text-xs mr-1">View:</span>
            <div className="flex">
              <button 
                className={`px-2 py-1 rounded-l text-xs flex items-center justify-center transition-colors border-r border-gray-700 ${
                  viewMode === 'list' ? 'bg-teal-600 text-white' : 'bg-gray-800 hover:bg-gray-700'
                }`}
                title="List view"
                onClick={() => setViewMode('list')}
              >
                <span>List</span>
              </button>
              <button 
                className={`px-2 py-1 rounded-r text-xs flex items-center justify-center transition-colors ${
                  viewMode === 'compact' ? 'bg-teal-600 text-white' : 'bg-gray-800 hover:bg-gray-700'
                }`}
                title="Compact view"
                onClick={() => setViewMode('compact')}
              >
                <span>Compact</span>
              </button>
            </div>
          </div>
          
          <button 
            className="bg-gray-800 hover:bg-gray-700 px-3 py-1 rounded text-xs transition-colors flex items-center"
            onClick={() => fetchCommunities()}
          >
            <span className="mr-1"></span> Refresh
          </button>
        </div>
      </div>

      {/* Full width layout */}
      <div className="flex w-full">
        {/* Left Sidebar - fixed width on desktop */}
        <div className="hidden md:block w-64 xl:w-72 flex-shrink-0 border-r border-gray-200 h-screen overflow-y-auto sticky top-10">
          <div className="p-4">
            {/* Search bar - compact but prominent in sidebar */}
            <form onSubmit={handleSearch} className="mb-4">
              <div className="relative">
                <input
                  type="text"
                  placeholder="Search communities..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full p-2 text-sm bg-white text-black border-2 border-teal-400 rounded focus:outline-none focus:ring-2 focus:ring-teal-500"
                  disabled={isSearching}
                />
                <button 
                  type="submit" 
                  className="absolute right-0 top-0 bottom-0 px-3 bg-teal-400 text-black font-bold text-sm uppercase tracking-wide hover:bg-teal-300 transition-colors rounded-r"
                  disabled={isSearching || !searchTerm.trim()}
                >
                  {isSearching ? '...' : 'Go'}
                </button>
              </div>
            </form>
            
            {/* Your Communities Section */}
            <div className="bg-gray-100 p-3 mb-4 border-l-2 border-teal-400">
              <div className="flex items-center justify-between mb-2">
                <h3 className="font-bold text-sm uppercase">Your Communities</h3>
                <button 
                  className="text-xs font-medium text-teal-600 hover:text-teal-800"
                  onClick={() => alert('This will show all your communities')}
                >
                  See All
                </button>
              </div>
              
              {isAuthenticated ? (
                <div className="max-h-32 overflow-y-auto">
                  {/* Placeholder for user communities - would come from API */}
                  {[1, 2, 3].map((num) => (
                    <div key={num} className="flex items-center py-1.5 border-b border-gray-200 last:border-0">
                      <div 
                        className="w-6 h-6 rounded-full flex items-center justify-center text-white text-xs mr-2"
                        style={{ backgroundColor: num % 3 === 0 ? '#2dd4bf' : num % 3 === 1 ? '#f472b6' : '#a78bfa' }}
                      >
                        {String.fromCharCode(64 + num)}
                      </div>
                      <span className="text-sm hover:text-teal-600 cursor-pointer">Sample Community {num}</span>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-xs text-gray-500 italic">
                  Sign in to see your communities
                </div>
              )}
            </div>
            
            {/* Create Community Button */}
            <button
              onClick={() => setShowCreateModal(true)}
              className="w-full px-4 py-2.5 bg-black text-white text-sm font-bold uppercase hover:bg-gray-800 transition-colors mb-4 rounded-sm flex items-center justify-center shadow"
            >
              <span className="mr-2">+</span> Create Community
            </button>
            
            <CommunityDiscoverySidebar />
          </div>
        </div>
        
        {/* Main Content Area - expands to fill available width */}
        <div className="flex-grow min-h-screen">
          {/* Mobile only create button */}
          <div className="md:hidden w-full p-4 flex justify-end">
            <button
              onClick={() => setShowCreateModal(true)}
              className="px-4 py-2 bg-black text-white text-sm font-bold uppercase rounded-sm shadow-md flex items-center"
            >
              <span className="mr-1">+</span> Create
            </button>
          </div>
          
          {/* Mobile search */}
          <form onSubmit={handleSearch} className="md:hidden mx-4 mt-4 mb-2">
            <div className="flex items-center">
              <input
                type="text"
                placeholder="Search communities..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="flex-1 p-2 text-sm bg-gray-800 text-white border-2 border-teal-400 focus:outline-none focus:ring-1 focus:ring-teal-400"
                disabled={isSearching}
              />
              <button 
                type="submit" 
                className="px-3 py-2 bg-teal-400 text-black font-bold text-xs uppercase tracking-wider hover:bg-teal-300"
                disabled={isSearching || !searchTerm.trim()}
              >
                {isSearching ? '...' : 'Search'}
              </button>
            </div>
          </form>
        
          {/* Status indicators */}
          {error && (
            <div className="bg-red-50 border-l-4 border-red-400 text-red-700 p-3 mx-4 mt-4 text-sm">
              <span className="font-bold">ERROR:</span> {error}
            </div>
          )}
          
          {(isLoading || isSearching) && (
            <div className="bg-gray-100 p-4 m-4 rounded shadow-inner">
              <div className="flex items-center justify-center space-x-2">
                <div className="w-2 h-2 bg-teal-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                <div className="w-2 h-2 bg-pink-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                <span className="ml-2 text-sm text-gray-600">{isSearching ? 'Searching communities...' : 'Loading communities...'}</span>
              </div>
            </div>
          )}
          
          {/* Community List with stacked horizontal layout */}
          {!isLoading && !isSearching && (
            <div className="mx-4 my-4">
              {communities.length === 0 ? (
                <div className="text-center py-12 bg-white border border-gray-200 rounded shadow-md">
                  <span className="text-xl uppercase font-bold tracking-wider text-gray-700">No Communities Found</span>
                  <p className="mt-2 text-gray-500">Try creating a new community or adjusting your search.</p>
                </div>
              ) : (
                <div className="flex flex-col space-y-2">
                  {communities.map((community, index) => {
                    const isExpanded = expandedCommunityId === community.id;
                    const communitySearchTerm = communitySearchTerms[community.id] || '';
                    const communityColor = index % 3 === 0 ? '#2dd4bf' : index % 3 === 1 ? '#f472b6' : '#a78bfa';
                    
                    // Compact View
                    if (viewMode === 'compact') {
                      return (
                        <div key={community.id}>
                          <div 
                            className="w-full bg-white shadow-sm hover:shadow-md transition-shadow border-l-4 rounded-sm overflow-hidden flex items-center cursor-pointer"
                            style={{ borderLeftColor: communityColor }}
                            onClick={() => toggleCommunityExpansion(community.id)}
                          >
                            <div 
                              className="w-8 h-8 rounded-full flex items-center justify-center text-white ml-2"
                              style={{ backgroundColor: communityColor }}
                            >
                              <span className="text-xs font-bold">{community.name.substring(0, 2).toUpperCase()}</span>
                            </div>
                            
                            <div className="flex-grow p-2 pl-3">
                              <div className="flex items-center">
                                <span className="font-bold text-sm hover:text-teal-600 transition-colors">
                                  {community.name}
                                </span>
                                
                                {community.privacy === 'private' && (
                                  <span className="ml-2 text-xs bg-gray-100 px-1 py-0.5 text-pink-600 font-medium rounded-full">
                                    P
                                  </span>
                                )}
                                
                                <span className="mx-2 text-gray-400"></span>
                                
                                <span className="text-xs text-gray-500">
                                  <span className="font-medium">{index * 42 + 12}</span> members
                                </span>
                              </div>
                            </div>
                            
                            <div className="flex items-center space-x-2">
                              {/* Expansion indicator */}
                              <span className="text-gray-500 text-sm pr-2">
                                {isExpanded ? '' : ''}
                              </span>
                            </div>
                            
                            <div className="flex items-center pr-2 space-x-2" onClick={(e) => e.stopPropagation()}>
                              <Link 
                                to={`/community/${community.id}`} 
                                className="text-xs text-teal-600 hover:underline"
                              >
                                View
                              </Link>
                              
                              <JoinCommunityButton 
                                communityId={community.id}
                                variant="compact"
                                className="px-2 py-0.5 text-white text-xs uppercase tracking-wider rounded-sm bg-black hover:bg-gray-800 transition-colors"
                                onJoin={() => fetchCommunities()}
                              />
                            </div>
                          </div>
                          
                          {/* Expanded Content for Compact View */}
                          {viewMode === 'compact' && isExpanded && (
                            <div className="mt-1 mb-1 ml-10 mr-2 p-3 bg-gray-50 rounded border border-gray-200">
                              <p className="text-sm text-gray-600 mb-3">{community.description}</p>
                              
                              {/* Community-specific search bar */}
                              <div className="mb-3">
                                <div className="relative">
                                  <input
                                    type="text"
                                    placeholder={`Search in ${community.name}...`}
                                    value={communitySearchTerm}
                                    onChange={(e) => updateCommunitySearchTerm(community.id, e.target.value)}
                                    className="w-full p-2 text-sm bg-white border border-gray-200 rounded focus:outline-none focus:border-teal-400"
                                  />
                                  <button 
                                    className="absolute right-0 top-0 h-full px-3 text-gray-600 hover:text-teal-600"
                                  >
                                    
                                  </button>
                                </div>
                                
                                {/* Search results - only show when search term exists */}
                                {communitySearchTerm.trim().length > 0 && (
                                  <div className="mt-2 bg-white border border-gray-200 rounded">
                                    <div className="p-2 border-b border-gray-100 flex justify-between items-center">
                                      <span className="text-xs font-medium">Search Results</span>
                                      <span className="text-xs text-gray-500">Max 10 results</span>
                                    </div>
                                    
                                    {/* For now, show placeholder results based on search term */}
                                    {Array.from({ length: Math.min(communitySearchTerm.length + 1, 10) }).map((_, resultIndex) => (
                                      <div key={resultIndex} className="py-2 px-2 border-b border-gray-100 last:border-0">
                                        <div className="flex items-start">
                                          <div 
                                            className="w-2 h-2 rounded-full mt-1.5 mr-2 flex-shrink-0"
                                            style={{ backgroundColor: index % 3 === 0 ? '#2dd4bf' : index % 3 === 1 ? '#f472b6' : '#a78bfa' }}
                                          ></div>
                                          <div>
                                            <h5 className="text-sm font-medium">
                                              {communitySearchTerm} result #{resultIndex + 1}
                                            </h5>
                                            <p className="text-xs text-gray-500 mt-0.5">
                                              Posted by User{resultIndex + 100}  {resultIndex + 1} days ago
                                            </p>
                                            <p className="text-xs mt-1 text-gray-700">
                                              Post containing search term "{communitySearchTerm}"
                                            </p>
                                          </div>
                                        </div>
                                      </div>
                                    ))}
                                    
                                    {/* Empty state when no results */}
                                    {communitySearchTerm.length > 0 && communitySearchTerm.length < 1 && (
                                      <div className="p-3 text-center text-xs text-gray-500">
                                        No results found for "{communitySearchTerm}"
                                      </div>
                                    )}
                                    
                                    {/* Link to view all results */}
                                    <div className="p-2 bg-gray-50 text-center">
                                      <Link to={`/community/${community.id}?search=${encodeURIComponent(communitySearchTerm)}`} className="text-xs text-teal-600 hover:underline">
                                        View all results 
                                      </Link>
                                    </div>
                                  </div>
                                )}
                              </div>
                              
                              {/* Quick Stats */}
                              <div className="flex items-center gap-3 text-xs mb-2">
                                <span className="text-gray-500">
                                  <span className="font-medium">{index * 17 + 8}</span> posts
                                </span>
                                <span className="text-gray-500">
                                  Created: <span className="font-medium">{community.created_at ? new Date(community.created_at).toLocaleDateString() : 'recently'}</span>
                                </span>
                              </div>
                              
                              <Link 
                                to={`/community/${community.id}`} 
                                className="text-xs text-teal-600 hover:underline"
                              >
                                View full community 
                              </Link>
                            </div>
                          )}
                        </div>
                      );
                    }
                    
                    // Standard List View
                    return (
                      <div 
                        key={community.id} 
                        className="w-full bg-white shadow-sm hover:shadow-md transition-shadow border-l-4 rounded-sm overflow-hidden"
                        style={{ borderLeftColor: communityColor }}
                      >
                        <div className="p-3">
                          {/* Community Header with Join Button */}
                          <div className="flex items-center justify-between cursor-pointer" onClick={() => toggleCommunityExpansion(community.id)}>
                            <div className="flex items-center">
                              {/* Community Icon/Avatar */}
                              <div 
                                className="w-10 h-10 rounded-full flex items-center justify-center text-white mr-3"
                                style={{ backgroundColor: communityColor }}
                              >
                                <span className="text-sm font-bold">{community.name.substring(0, 2).toUpperCase()}</span>
                              </div>
                              
                              <div>
                                <div className="flex items-center">
                                  <span className="font-bold text-base hover:text-teal-600 transition-colors">
                                    {community.name}
                                  </span>
                                  
                                  {/* Privacy tag */}
                                  {community.privacy === 'private' && (
                                    <span className="ml-2 text-xs bg-gray-100 px-2 py-0.5 text-pink-600 font-medium rounded-full">
                                      PRIVATE
                                    </span>
                                  )}
                                  
                                  {/* Expansion indicator */}
                                  <span className="ml-2 text-gray-500 text-sm">
                                    {isExpanded ? '' : ''}
                                  </span>
                                </div>
                                
                                {/* Community Description */}
                                <p className="text-sm text-gray-700 line-clamp-2 mt-1">{community.description}</p>
                                
                                {/* Community Stats Row */}
                                <div className="mt-2 flex flex-wrap items-center gap-3 text-xs">
                                  <span className="text-gray-500">
                                    <span className="font-medium">{index * 42 + 12}</span> members
                                  </span>
                                  <span className="text-gray-500">
                                    <span className="font-medium">{index * 17 + 8}</span> posts
                                  </span>
                                  <span className="text-gray-500">
                                    Created: <span className="font-medium">{community.created_at ? new Date(community.created_at).toLocaleDateString() : 'recently'}</span>
                                  </span>
                                </div>
                              </div>
                            </div>
                            
                            <div onClick={(e) => e.stopPropagation()}>
                              <JoinCommunityButton 
                                communityId={community.id}
                                variant="compact"
                                className="bg-black hover:bg-gray-800 text-white text-xs uppercase tracking-wider rounded-sm"
                                onJoin={() => fetchCommunities()}
                              />
                            </div>
                          </div>
                          
                          {/* Expanded Community Content */}
                          {isExpanded && (
                            <div className="mt-3 pt-3 border-t border-gray-200">
                              {/* Community-specific search bar */}
                              <div className="mb-3">
                                <div className="relative">
                                  <input
                                    type="text"
                                    placeholder={`Search in ${community.name}...`}
                                    value={communitySearchTerm}
                                    onChange={(e) => updateCommunitySearchTerm(community.id, e.target.value)}
                                    className="w-full p-2 text-sm bg-gray-50 border border-gray-200 rounded focus:outline-none focus:border-teal-400"
                                  />
                                  <button 
                                    className="absolute right-0 top-0 h-full px-3 text-gray-600 hover:text-teal-600"
                                  >
                                    
                                  </button>
                                </div>

                                {/* Search results - only show when search term exists */}
                                {communitySearchTerm.trim().length > 0 && (
                                  <div className="mt-2 bg-white border border-gray-200 rounded">
                                    <div className="p-2 border-b border-gray-100 flex justify-between items-center">
                                      <span className="text-xs font-medium">Search Results</span>
                                      <span className="text-xs text-gray-500">Max 10 results</span>
                                    </div>
                                    
                                    {/* For now, show placeholder results based on search term */}
                                    {Array.from({ length: Math.min(communitySearchTerm.length + 1, 10) }).map((_, resultIndex) => (
                                      <div key={resultIndex} className="py-2 px-2 border-b border-gray-100 last:border-0">
                                        <div className="flex items-start">
                                          <div 
                                            className="w-2 h-2 rounded-full mt-1.5 mr-2 flex-shrink-0"
                                            style={{ backgroundColor: index % 3 === 0 ? '#2dd4bf' : index % 3 === 1 ? '#f472b6' : '#a78bfa' }}
                                          ></div>
                                          <div>
                                            <h5 className="text-sm font-medium">
                                              {communitySearchTerm} result #{resultIndex + 1}
                                            </h5>
                                            <p className="text-xs text-gray-500 mt-0.5">
                                              Posted by User{resultIndex + 100}  {resultIndex + 1} days ago
                                            </p>
                                            <p className="text-xs mt-1 text-gray-700">
                                              Post containing search term "{communitySearchTerm}"
                                            </p>
                                          </div>
                                        </div>
                                      </div>
                                    ))}
                                    
                                    {/* Empty state when no results */}
                                    {communitySearchTerm.length > 0 && communitySearchTerm.length < 1 && (
                                      <div className="p-3 text-center text-xs text-gray-500">
                                        No results found for "{communitySearchTerm}"
                                      </div>
                                    )}
                                    
                                    {/* Link to view all results */}
                                    <div className="p-2 bg-gray-50 text-center">
                                      <Link to={`/community/${community.id}?search=${encodeURIComponent(communitySearchTerm)}`} className="text-xs text-teal-600 hover:underline">
                                        View all results 
                                      </Link>
                                    </div>
                                  </div>
                                )}
                              </div>
                              
                              {/* Placeholder for community posts */}
                              <div className="bg-gray-50 rounded p-2">
                                <div className="flex justify-between items-center mb-2">
                                  <h4 className="text-sm font-medium">Recent Posts</h4>
                                  <Link to={`/community/${community.id}`} className="text-xs text-teal-600 hover:underline">
                                    View All
                                  </Link>
                                </div>
                                
                                {/* Sample posts */}
                                {[...Array(3)].map((_, postIndex) => (
                                  <div key={postIndex} className="py-2 border-b border-gray-100 last:border-0">
                                    <div className="flex items-start">
                                      <div 
                                        className="w-2 h-2 rounded-full mt-1.5 mr-2 flex-shrink-0"
                                        style={{ backgroundColor: communityColor }}
                                      ></div>
                                      <div>
                                        <h5 className="text-sm font-medium">Sample post title {postIndex + 1}</h5>
                                        <p className="text-xs text-gray-500 mt-0.5">Posted by User{postIndex + 100}  {postIndex + 1} hours ago</p>
                                        <p className="text-xs mt-1">This is a sample post description. Click to view the full post.</p>
                                      </div>
                                    </div>
                                  </div>
                                ))}
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      {showCreateModal && (
        <CreateCommunityModal
          onClose={() => setShowCreateModal(false)}
          onSuccess={handleCommunityCreated}
        />
      )}
    </div>
  );
}

================
File: src/pages/Community.tsx
================
import React, { useState } from 'react'
import { useParams } from 'react-router-dom'
import CommunityHeader from '../components/CommunityHeader'
import PostList from '../components/PostList'
import CommunityRules from '../components/CommunityRules'
import CommunityAbout from '../components/CommunityAbout'
import CommunitySettings from '../components/CommunitySettings'
import ActivityHistory from '../components/ActivityHistory'
import CreatePostModal from '../components/CreatePostModal'
import { useAuth } from '../context/AuthContext'
import ModeratorDebug from '../debug/ModeratorDebug'

export default function Community() {
  const { id } = useParams()
  const [showCreateModal, setShowCreateModal] = useState(false)
  const { isAuthenticated } = useAuth()

  const handlePostCreated = () => {
    // Refresh the page or update the post list
    window.location.reload()
  }

  return (
    <div className="w-full max-w-[98%] xl:max-w-[1800px] mx-auto px-2 py-8 font-mono">
      <CommunityHeader communityId={id || ''} />
      
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-8 mt-2">
        <div className="lg:col-span-3">
          {/* Create Post Button - Anti-design style with color accents */}
          {isAuthenticated && (
            <button
              onClick={() => setShowCreateModal(true)}
              className="w-full p-6 bg-black text-white mb-8 hover:bg-gray-900 flex items-center justify-center transform hover:skew-y-1 transition-transform shadow-lg relative overflow-hidden group"
            >
              <span className="font-bold text-xl uppercase tracking-widest relative z-10">
                + CREATE <span className="text-teal-400">POST</span>
              </span>
              <span className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500 transform translate-x-0 group-hover:translate-y-1 transition-transform"></span>
            </button>
          )}
          
          {/* Latest Posts - Anti-design style with color accents */}
          <div className="bg-gray-100 p-8 mb-8 relative transform -rotate-0.5 shadow-lg">
            <div className="absolute -top-6 left-8 bg-black text-white px-4 py-1 transform rotate-2 shadow-md">
              <span className="text-purple-400">COMMUNITY</span> POSTS
            </div>
            <PostList communityId={id} />
          </div>
        </div>
        
        <div className="lg:col-span-1 space-y-8">
          {/* Community Info Sections - Anti-design style with color accents */}
          <div className="bg-gray-100 p-6 transform rotate-0.5 shadow-md">
            <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
              About
              <span className="absolute bottom-0 left-0 w-full h-1 bg-teal-400"></span>
            </h2>
            <CommunityAbout communityId={id || ''} />
          </div>
          
          <div className="bg-gray-100 p-6 transform -rotate-0.5 shadow-md">
            <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
              Rules
              <span className="absolute bottom-0 left-0 w-full h-1 bg-pink-400"></span>
            </h2>
            <CommunityRules communityId={id || ''} />
          </div>
          
          <div className="bg-gray-100 p-6 transform rotate-0.5 shadow-md">
            <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
              Settings
              <span className="absolute bottom-0 left-0 w-full h-1 bg-purple-400"></span>
            </h2>
            <CommunitySettings communityId={id || ''} />
          </div>
          
          <div className="bg-gray-100 p-6 transform -rotate-0.5 shadow-md">
            <h2 className="font-bold mb-4 uppercase tracking-tight text-xl relative inline-block">
              Activity
              <span className="absolute bottom-0 left-0 w-full h-1 bg-yellow-400"></span>
            </h2>
            <div className="max-h-[400px] overflow-y-auto">
              <ActivityHistory communityId={id || ''} limit={10} />
            </div>
          </div>
          
          {/* Debug component - remove when not needed */}
          <ModeratorDebug communityId={id || ''} />
        </div>
      </div>

      {showCreateModal && (
        <CreatePostModal 
          onClose={() => setShowCreateModal(false)} 
          communityId={id}
          onSuccess={handlePostCreated}
        />
      )}
    </div>
  )
}

================
File: src/pages/CommunityModeration.tsx
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, useSearchParams } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import ModeratorDashboard from '../components/ModeratorDashboard';
import { isUserModerator } from '../api/moderation';
import { getCommunity, getPendingJoinRequests, approveJoinRequest, rejectJoinRequest } from '../api/communities';

interface JoinRequest {
  id: string;
  user_id: string;
  community_id: string;
  status: 'pending' | 'approved' | 'rejected';
  requested_at: string;
  updated_at: string;
  username?: string;
}

const CommunityModeration: React.FC = () => {
  const { communityId } = useParams<{ communityId: string }>();
  const { user, token } = useAuth();
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const activeTab = searchParams.get('tab') || 'dashboard';
  
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [isModerator, setIsModerator] = useState<boolean>(false);
  const [community, setCommunity] = useState<any>(null);
  const [joinRequests, setJoinRequests] = useState<JoinRequest[]>([]);
  const [joinRequestsLoading, setJoinRequestsLoading] = useState<boolean>(false);
  const [processingRequestIds, setProcessingRequestIds] = useState<Record<string, boolean>>({});
  
  useEffect(() => {
    // If not logged in, redirect to login
    if (!user || !token) {
      navigate('/login', { state: { from: `/community/${communityId}/moderation` } });
      return;
    }
    
    // Check if user is a moderator
    checkModeratorStatus();
    loadCommunity();
    
    // If on join-requests tab, load the join requests
    if (activeTab === 'join-requests') {
      loadJoinRequests();
    }
  }, [communityId, user, token, activeTab]);
  
  const checkModeratorStatus = async () => {
    if (!communityId || !user || !token) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // Check if user is a moderator
      const result = await fetch(`http://localhost:3001/api/communities/${communityId}/members/${user.id}`, {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (result.ok) {
        const member = await result.json();
        setIsModerator(member.role === 'moderator' || member.role === 'admin');
      } else {
        setIsModerator(false);
      }
    } catch (err) {
      console.error('Error checking moderator status:', err);
      setError('Failed to check moderator status.');
      setIsModerator(false);
    } finally {
      setLoading(false);
    }
  };
  
  const loadCommunity = async () => {
    if (!communityId) return;
    
    try {
      const communityData = await getCommunity(communityId);
      setCommunity(communityData);
    } catch (err) {
      console.error('Error loading community:', err);
      setError('Failed to load community information.');
    }
  };
  
  const loadJoinRequests = async () => {
    if (!communityId || !token) return;
    
    try {
      setJoinRequestsLoading(true);
      const requests = await getPendingJoinRequests(communityId, token);
      setJoinRequests(requests);
    } catch (error) {
      console.error('Error loading join requests:', error);
    } finally {
      setJoinRequestsLoading(false);
    }
  };
  
  const handleApproveJoinRequest = async (requestId: string) => {
    if (!communityId || !token) return;
    
    try {
      // Mark this request as processing
      setProcessingRequestIds(prev => ({ ...prev, [requestId]: true }));
      
      await approveJoinRequest(communityId, requestId, token);
      
      // Remove this request from the list
      setJoinRequests(prev => prev.filter(req => req.id !== requestId));
    } catch (error) {
      console.error('Error approving join request:', error);
      alert('Failed to approve join request');
    } finally {
      // Clear the processing state
      setProcessingRequestIds(prev => ({ ...prev, [requestId]: false }));
    }
  };
  
  const handleRejectJoinRequest = async (requestId: string) => {
    if (!communityId || !token) return;
    
    try {
      // Mark this request as processing
      setProcessingRequestIds(prev => ({ ...prev, [requestId]: true }));
      
      await rejectJoinRequest(communityId, requestId, token);
      
      // Remove this request from the list
      setJoinRequests(prev => prev.filter(req => req.id !== requestId));
    } catch (error) {
      console.error('Error rejecting join request:', error);
      alert('Failed to reject join request');
    } finally {
      // Clear the processing state
      setProcessingRequestIds(prev => ({ ...prev, [requestId]: false }));
    }
  };
  
  if (loading) {
    return (
      <div className="container mx-auto p-4">
        <div className="flex justify-center">
          <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-500"></div>
        </div>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="container mx-auto p-4">
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
          {error}
        </div>
      </div>
    );
  }
  
  if (!isModerator) {
    return (
      <div className="container mx-auto p-4">
        <div className="bg-yellow-100 border border-yellow-400 text-yellow-700 px-4 py-3 rounded">
          You do not have permission to access the moderation dashboard for this community.
        </div>
        <div className="mt-4">
          <button 
            className="text-blue-500 hover:text-blue-700"
            onClick={() => navigate(`/community/${communityId}`)}
          >
            Return to Community
          </button>
        </div>
      </div>
    );
  }
  
  return (
    <div className="container mx-auto p-4">
      {community && (
        <div className="mb-4">
          <h1 className="text-3xl font-bold mb-2">Moderating r/{community.name}</h1>
          <button 
            className="text-blue-500 hover:text-blue-700 mb-4"
            onClick={() => navigate(`/community/${communityId}`)}
          >
            Return to Community
          </button>
          
          {/* Tabs */}
          <div className="flex border-b mb-6">
            <button 
              className={`px-4 py-2 font-medium ${activeTab === 'dashboard' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-500'}`}
              onClick={() => navigate(`/community/${communityId}/moderation?tab=dashboard`)}
            >
              Dashboard
            </button>
            <button 
              className={`px-4 py-2 font-medium ${activeTab === 'queue' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-500'}`}
              onClick={() => navigate(`/community/${communityId}/moderation?tab=queue`)}
            >
              Content Queue
            </button>
            <button 
              className={`px-4 py-2 font-medium ${activeTab === 'join-requests' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-500'}`}
              onClick={() => {
                navigate(`/community/${communityId}/moderation?tab=join-requests`);
                loadJoinRequests();
              }}
            >
              Join Requests
            </button>
          </div>
        </div>
      )}
      
      {/* Content based on active tab */}
      {activeTab === 'join-requests' ? (
        <div>
          <h2 className="text-xl font-semibold mb-4">Pending Join Requests</h2>
          
          {joinRequestsLoading ? (
            <p className="text-gray-600">Loading join requests...</p>
          ) : joinRequests.length === 0 ? (
            <p className="text-gray-600">No pending join requests</p>
          ) : (
            <div className="space-y-4">
              {joinRequests.map(request => (
                <div key={request.id} className="bg-white shadow rounded-lg p-4 border-l-4 border-blue-500">
                  <div className="flex justify-between items-center">
                    <div>
                      <p className="font-semibold">
                        {request.username || `User ${request.user_id.substring(0, 8)}...`}
                      </p>
                      <p className="text-sm text-gray-500">
                        Requested {new Date(request.requested_at).toLocaleString()}
                      </p>
                    </div>
                    <div className="flex space-x-2">
                      <button
                        className={`px-4 py-1 rounded bg-green-500 text-white hover:bg-green-600 ${
                          processingRequestIds[request.id] ? 'opacity-50 cursor-not-allowed' : ''
                        }`}
                        onClick={() => handleApproveJoinRequest(request.id)}
                        disabled={processingRequestIds[request.id]}
                      >
                        {processingRequestIds[request.id] ? 'Processing...' : 'Approve'}
                      </button>
                      <button
                        className={`px-4 py-1 rounded bg-red-500 text-white hover:bg-red-600 ${
                          processingRequestIds[request.id] ? 'opacity-50 cursor-not-allowed' : ''
                        }`}
                        onClick={() => handleRejectJoinRequest(request.id)}
                        disabled={processingRequestIds[request.id]}
                      >
                        {processingRequestIds[request.id] ? 'Processing...' : 'Reject'}
                      </button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      ) : (
        // For other tabs, use the existing ModeratorDashboard component
        communityId && <ModeratorDashboard communityId={communityId} />
      )}
    </div>
  );
};

export default CommunityModeration;

================
File: src/pages/Home.tsx
================
import React, { useState, useEffect } from 'react'
import { Link } from 'react-router-dom'
import PostList from '../components/PostList'
import Sidebar from '../components/Sidebar'
import CreatePostModal from '../components/CreatePostModal'
import CommunityDiscovery from '../components/CommunityDiscovery'
import { useAuth } from '../context/AuthContext'
import { getCommunities } from '../api/communities'

export default function Home() {
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [trendingCommunities, setTrendingCommunities] = useState([])
  const [loading, setLoading] = useState(true)
  const [activeTab, setActiveTab] = useState<'trending' | 'all' | 'following'>('trending')
  const [viewMode, setViewMode] = useState<'card' | 'compact'>('card')
  const { isAuthenticated, user } = useAuth()

  useEffect(() => {
    const fetchTrendingCommunities = async () => {
      try {
        setLoading(true)
        const communities = await getCommunities()
        // For now, just use the first few communities as "trending"
        setTrendingCommunities(communities.slice(0, 3))
      } catch (error) {
        console.error('Failed to fetch trending communities:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchTrendingCommunities()
  }, [])

  return (
    <div className="w-full max-w-[98%] xl:max-w-[1800px] mx-auto px-2 font-mono bg-gray-50">
      {/* Header with welcome message - only shown when authenticated */}
      {isAuthenticated && (
        <div className="w-full bg-black text-white shadow-md sticky top-0 z-30">
          <div className="flex items-center justify-between p-3">
            {/* Left: Welcome message */}
            <div className="font-bold uppercase">
              Welcome, <span className="text-teal-400">{user?.username}</span>!
            </div>
            
            {/* Right: User actions */}
            <div className="flex items-center space-x-2">
              {/* User profile and settings buttons */}
              <div className="hidden md:flex items-center space-x-2">
                <Link
                  to="/profile"
                  className="px-2 py-1 text-xs bg-gray-800 hover:bg-gray-700 rounded-sm transition-colors uppercase"
                >
                  Profile
                </Link>
                <Link
                  to="/settings"
                  className="px-2 py-1 text-xs bg-gray-800 hover:bg-gray-700 rounded-sm transition-colors uppercase"
                >
                  Settings
                </Link>
              </div>
              
              {/* Mobile-only post button */}
              <button
                onClick={() => setShowCreateModal(true)}
                className="md:hidden px-3 py-1 bg-teal-500 text-white text-xs uppercase tracking-wider rounded-sm hover:bg-teal-400 transition-colors flex items-center"
              >
                <span className="mr-1">+</span> Post
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Welcome Banner - Only when not authenticated */}
      {!isAuthenticated && (
        <div className="bg-black text-white p-6 my-4 relative transform -rotate-1 shadow-lg">
          <div className="absolute top-0 right-0 bg-white text-black px-4 py-1 text-xl uppercase tracking-widest transform rotate-3 shadow-md">
            <span className="text-teal-500">WEL</span>
            <span className="text-pink-500">COME</span>
          </div>
          <h1 className="text-3xl font-bold mb-3 uppercase tracking-tight">
            <span className="text-teal-400">Join</span> communities. <span className="text-pink-400">Share</span> ideas. Be <span className="text-purple-400">yourself</span>.
          </h1>
          <p className="text-white text-lg ml-6 border-l-4 border-teal-400 pl-4">
            Rumfor is where communities thrive. Find your people.
          </p>
        </div>
      )}

      <div className="flex flex-col lg:flex-row lg:space-x-6 mt-4">
        {/* Left Sidebar - User activity and communities */}
        <div className="w-full lg:w-72 flex-shrink-0 order-1 md:order-1">
          {/* User Activity Section - No title, more styled */}
          {isAuthenticated && (
            <div className="space-y-4 mb-4">
              <div className="bg-white shadow-md border-l-4 border-teal-400 p-4 transform -rotate-1 skew-y-0.5 relative">
                <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-white to-transparent"></div>
                <div className="space-y-2">
                  <Link 
                    to="/profile/posts" 
                    className="block text-sm font-medium hover:text-teal-600 flex items-center p-2 hover:bg-gray-50 hover:translate-x-1 transition-all rounded-sm transform hover:-rotate-0.5"
                  >
                    <span className="w-3 h-3 rounded-full bg-teal-400 mr-2"></span> Your Posts
                  </Link>
                  <Link 
                    to="/profile/comments" 
                    className="block text-sm font-medium hover:text-pink-600 flex items-center p-2 hover:bg-gray-50 hover:translate-x-1 transition-all rounded-sm transform hover:rotate-0.5"
                  >
                    <span className="w-3 h-3 rounded-full bg-pink-400 mr-2"></span> Your Comments
                  </Link>
                  <Link 
                    to="/profile/votes" 
                    className="block text-sm font-medium hover:text-purple-600 flex items-center p-2 hover:bg-gray-50 hover:translate-x-1 transition-all rounded-sm transform hover:-rotate-0.5"
                  >
                    <span className="w-3 h-3 rounded-full bg-purple-400 mr-2"></span> Your Votes
                  </Link>
                  <Link 
                    to="/profile" 
                    className="block text-xs text-teal-600 font-medium hover:underline mt-2 pl-5 transform hover:translate-x-1 transition-all"
                  >
                    View full profile 
                  </Link>
                </div>
              </div>
              
              <div className="bg-white shadow-md border-l-4 border-pink-400 p-4 transform rotate-1 skew-y-0.5 relative">
                <div className="absolute top-0 right-0 w-full h-1 bg-gradient-to-l from-pink-400 via-white to-transparent"></div>
                <div className="space-y-2">
                  {/* Placeholder for user communities */}
                  {[1, 2, 3].map(num => (
                    <Link 
                      key={num}
                      to={`/community/${num}`}
                      className="block text-sm font-medium hover:text-pink-600 flex items-center p-2 hover:bg-gray-50 hover:translate-x-1 transition-all rounded-sm"
                    >
                      <div
                        className="w-6 h-6 rounded-full flex items-center justify-center text-white mr-2 flex-shrink-0 shadow transform hover:scale-110 transition-transform"
                        style={{ backgroundColor: num % 3 === 0 ? '#2dd4bf' : num % 3 === 1 ? '#f472b6' : '#a78bfa' }}
                      >
                        <span className="text-xs font-bold">{String.fromCharCode(64 + num)}</span>
                      </div>
                      <span className="truncate">Sample Community {num}</span>
                    </Link>
                  ))}
                  <Link 
                    to="/communities" 
                    className="block text-xs text-pink-600 font-medium hover:underline mt-2 pl-5 transform hover:translate-x-1 transition-all"
                  >
                    View all your communities 
                  </Link>
                </div>
              </div>
            </div>
          )}
          
          {/* New Communities compact list */}
          <div className="bg-white shadow-md border-l-4 border-teal-400 p-4 transform -rotate-1.5 mb-4 relative">
            <div className="absolute top-0 left-8 right-8 h-1 bg-gradient-to-r from-transparent via-teal-400 to-transparent"></div>
            <div className="space-y-2">
              {/* Reuse trending communities sorted by newest */}
              {trendingCommunities.slice(0, 5).map((community: any, index: number) => (
                <Link 
                  key={`new-community-${community.id}`}
                  to={`/community/${community.id}`}
                  className="block text-sm font-medium hover:text-teal-600 flex items-center p-2 hover:bg-gray-50 hover:translate-x-1 transition-all rounded-sm transform hover:rotate-0.5"
                >
                  <span className="w-3 h-3 rounded-full bg-teal-400 mr-2 transform hover:scale-125 transition-transform"></span> 
                  {community.name}
                </Link>
              ))}
              {loading && <div className="text-sm text-gray-500 pl-5">Loading communities...</div>}
              {!loading && trendingCommunities.length === 0 && (
                <div className="text-sm text-gray-500 pl-5">No communities found</div>
              )}
              <Link 
                to="/communities?sort=new" 
                className="block text-xs text-teal-600 font-medium hover:underline mt-1 pl-5 transform hover:translate-x-1 transition-all"
              >
                See more new communities 
              </Link>
            </div>
          </div>

          {/* Trending Communities compact list */}
          <div className="bg-white shadow-md border-l-4 border-pink-400 p-4 transform rotate-1 mb-4 relative">
            <div className="absolute top-0 left-8 right-8 h-1 bg-gradient-to-r from-transparent via-pink-400 to-transparent"></div>
            <div className="space-y-2">
              {trendingCommunities.slice(0, 5).map((community: any, index: number) => (
                <Link 
                  key={`trending-community-${community.id}`}
                  to={`/community/${community.id}`}
                  className="block text-sm font-medium hover:text-pink-600 flex items-center p-2 hover:bg-gray-50 hover:translate-x-1 transition-all rounded-sm transform hover:-rotate-0.5"
                >
                  <span className="w-3 h-3 rounded-full bg-pink-400 mr-2 transform hover:scale-125 transition-transform"></span> 
                  {community.name}
                </Link>
              ))}
              {loading && <div className="text-sm text-gray-500 pl-5">Loading communities...</div>}
              {!loading && trendingCommunities.length === 0 && (
                <div className="text-sm text-gray-500 pl-5">No communities found</div>
              )}
              <Link 
                to="/communities?sort=trending" 
                className="block text-xs text-pink-600 font-medium hover:underline mt-1 pl-5 transform hover:translate-x-1 transition-all"
              >
                See more trending communities 
              </Link>
            </div>
          </div>

          {/* Trending Posts compact list */}
          <div className="bg-white shadow-md border-l-4 border-purple-400 p-4 transform -rotate-1 mb-4 relative">
            <div className="absolute top-0 left-8 right-8 h-1 bg-gradient-to-r from-transparent via-purple-400 to-transparent"></div>
            <div className="space-y-2">
              {/* Load the top 5 trending posts from the API via PostList component using CSS to make it compact */}
              <div className="transform scale-90 origin-top-left overflow-hidden -mt-1 -ml-2">
                <PostList 
                  communityId={null} 
                  postType="trending"
                  maxPosts={5}
                  compact={true}
                />
              </div>
              <button 
                onClick={() => setActiveTab('trending')} 
                className="block text-xs text-purple-600 font-medium hover:underline mt-1 pl-5 transform hover:translate-x-1 transition-all"
              >
                See more trending posts 
              </button>
            </div>
          </div>
        </div>
        
        {/* Main Content Area - Middle column */}
        <div className="flex-grow order-3 lg:order-2">
          {/* Trending Communities - Horizontal scrollable row */}
          <div className="bg-white shadow-sm rounded-sm mb-4 p-4 transform rotate-0.5 overflow-hidden">
            <div className="flex justify-end mb-3">
              <Link to="/communities" className="text-xs text-teal-600 hover:underline">
                View All 
              </Link>
            </div>
            
            <div className="flex space-x-3 overflow-x-auto pb-2 -mx-1 px-1">
              {loading ? (
                <div className="flex-grow text-center py-8 text-sm bg-gray-50">Loading...</div>
              ) : (
                trendingCommunities.map((community: any, index: number) => (
                  <Link 
                    key={community.id} 
                    to={`/community/${community.id}`}
                    className={`flex-shrink-0 w-48 bg-white border hover:shadow-md transition-shadow rounded-sm overflow-hidden flex flex-col ${
                      index % 3 === 0 ? 'border-t-2 border-teal-400' : 
                      index % 3 === 1 ? 'border-t-2 border-pink-400' : 
                      'border-t-2 border-purple-400'
                    }`}
                  >
                    <div className="p-3 flex items-center">
                      <div 
                        className="w-8 h-8 rounded-full flex items-center justify-center text-white mr-2"
                        style={{ backgroundColor: index % 3 === 0 ? '#2dd4bf' : index % 3 === 1 ? '#f472b6' : '#a78bfa' }}
                      >
                        <span className="text-xs font-bold">{community.name.substring(0, 2).toUpperCase()}</span>
                      </div>
                      <div className="flex-grow">
                        <div className="font-bold text-sm">{community.name}</div>
                        <div className="text-xs text-gray-500">{index * 42 + 12} members</div>
                      </div>
                    </div>
                    <div className="p-2 bg-gray-50 text-xs border-t text-gray-700">
                      <p className="line-clamp-2">{community.description}</p>
                    </div>
                  </Link>
                ))
              )}
            </div>
          </div>
          
          {/* Content Tab Navigation - Stylized with integrated dropdown */}
          <div className="flex items-center justify-between mb-4 relative overflow-hidden bg-white shadow-sm rounded-t transform -rotate-0.5">
            <div className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-400"></div>
            
            <div className="flex items-center">
              <button 
                className={`px-5 py-3 text-sm font-bold uppercase tracking-wider transition-all relative overflow-hidden ${
                  activeTab === 'trending' 
                    ? 'text-white transform -skew-x-2' 
                    : 'text-gray-500 hover:text-gray-700 hover:-translate-y-0.5'
                }`}
                onClick={() => setActiveTab('trending')}
              >
                {activeTab === 'trending' && (
                  <div className="absolute inset-0 bg-teal-500 -z-10 transform skew-x-12"></div>
                )}
                <span className="relative z-10">Trending Posts</span>
                {activeTab === 'trending' && <span className="absolute top-0 right-0 w-2 h-2 rounded-full bg-white"></span>}
              </button>
              
              <button 
                className={`px-5 py-3 text-sm font-bold uppercase tracking-wider transition-all relative overflow-hidden ${
                  activeTab === 'all' 
                    ? 'text-white transform skew-x-2' 
                    : 'text-gray-500 hover:text-gray-700 hover:-translate-y-0.5'
                }`}
                onClick={() => setActiveTab('all')}
              >
                {activeTab === 'all' && (
                  <div className="absolute inset-0 bg-pink-500 -z-10 transform -skew-x-12"></div>
                )}
                <span className="relative z-10">Latest Posts</span>
                {activeTab === 'all' && <span className="absolute top-0 right-0 w-2 h-2 rounded-full bg-white"></span>}
              </button>
              
              {isAuthenticated && (
                <button 
                  className={`px-5 py-3 text-sm font-bold uppercase tracking-wider transition-all relative overflow-hidden ${
                    activeTab === 'following' 
                      ? 'text-white transform -skew-x-2' 
                      : 'text-gray-500 hover:text-gray-700 hover:-translate-y-0.5'
                  }`}
                  onClick={() => setActiveTab('following')}
                >
                  {activeTab === 'following' && (
                    <div className="absolute inset-0 bg-purple-500 -z-10 transform skew-x-12"></div>
                  )}
                  <span className="relative z-10">Following</span>
                  {activeTab === 'following' && <span className="absolute top-0 right-0 w-2 h-2 rounded-full bg-white"></span>}
                </button>
              )}
            </div>
            
            {/* Sort options - different options based on active tab - now aligned with tabs */}
            <div className="flex items-center text-xs p-3 relative z-10">
              {activeTab === 'trending' && (
                <select className="bg-gray-100 border-none rounded py-1 px-2 text-xs">
                  <option>Hot</option>
                  <option>Top Today</option>
                  <option>Top This Week</option>
                  <option>Top This Month</option>
                </select>
              )}
              
              {activeTab === 'all' && (
                <select className="bg-gray-100 border-none rounded py-1 px-2 text-xs">
                  <option>New</option>
                  <option>Rising</option>
                  <option>Controversial</option>
                </select>
              )}
              
              {activeTab === 'following' && (
                <select className="bg-gray-100 border-none rounded py-1 px-2 text-xs">
                  <option>Recent</option>
                  <option>Top</option>
                </select>
              )}
            </div>
          </div>
          
          {/* Post Content */}
          <div className="bg-white shadow-sm rounded-sm p-4 mb-4 transform -rotate-0.5">
            
            {/* Descriptive text */}
            <div className="mb-4 text-xs text-gray-500 italic border-l-2 pl-2">
              {activeTab === 'trending' && (
                <p>Popular posts from all communities, sorted by votes and engagement</p>
              )}
              {activeTab === 'all' && (
                <p>Latest posts from all communities in chronological order</p>
              )}
              {activeTab === 'following' && (
                <p>Recent posts from communities you follow</p>
              )}
            </div>
            
            {/* Posts with optimized layout based on viewMode */}
            <div className={viewMode === 'compact' ? 'space-y-1' : 'space-y-4'}>
              <PostList 
                communityId={null} 
                postType={activeTab}
              />
            </div>
          </div>
        </div>
        
        {/* Right Sidebar */}
        <div className="w-full lg:w-72 flex-shrink-0 order-2 lg:order-3 mb-4 lg:mb-0">
          {/* Post creation options */}
          {isAuthenticated && (
            <div className="mb-4 space-y-2">
              <button
                onClick={() => setShowCreateModal(true)}
                className="w-full px-3 py-2 bg-black text-white text-sm font-bold uppercase shadow hover:bg-gray-900 transition-colors flex items-center justify-center transform -rotate-0.5 border-b-2 border-teal-400"
              >
                <span className="mr-1">+</span> Create Post
              </button>
            </div>
          )}
          
          
          {/* Content preferences & tools - not duplicating profile functionality */}
          {isAuthenticated && (
            <div className="bg-black text-white p-4 transform -rotate-1 skew-y-1 shadow-md mb-4 relative border-l-4 border-pink-400">
              <div className="space-y-2">
                <Link 
                  to="/bookmarks"
                  className="w-full text-left p-2 text-sm rounded-sm bg-gray-900 hover:bg-gray-800 hover:translate-x-1 transition-all flex items-center transform hover:rotate-0.5"
                >
                  <span className="w-3 h-3 rounded-full bg-pink-400 mr-2 animate-pulse"></span>
                  Bookmarked Posts
                </Link>
                <Link 
                  to="/notifications"
                  className="w-full text-left p-2 text-sm rounded-sm bg-gray-900 hover:bg-gray-800 hover:translate-x-1 transition-all flex items-center transform hover:-rotate-0.5"
                >
                  <span className="w-3 h-3 rounded-full bg-teal-400 mr-2 animate-pulse"></span>
                  Notifications
                </Link>
                <button 
                  className="w-full text-left p-2 text-sm rounded-sm bg-gray-900 hover:bg-gray-800 hover:translate-x-1 transition-all flex items-center transform hover:rotate-0.5"
                  onClick={() => {
                    // This would toggle a dark mode or theme preference
                    alert('Theme preference would be toggled here');
                  }}
                >
                  <span className="w-3 h-3 rounded-full bg-purple-400 mr-2 animate-pulse"></span>
                  Toggle Theme
                </button>
              </div>
            </div>
          )}
          
          {/* About section - no title but more styled */}
          <div className="bg-black text-white p-4 transform rotate-0.5 skew-x-1 shadow-md mb-4 relative overflow-hidden border-r-4 border-purple-400">
            <div className="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500"></div>
            <p className="text-sm pl-2 relative z-10">
              <span className="text-teal-400 font-bold">RUMFOR</span> is a community platform where you can join communities, share posts, and connect with others.
            </p>
            <div className="absolute -bottom-8 -right-8 w-16 h-16 bg-gray-900 rounded-full opacity-30"></div>
          </div>
        </div>
      </div>

      {showCreateModal && (
        <CreatePostModal onClose={() => setShowCreateModal(false)} />
      )}
    </div>
  )
}

================
File: src/pages/Login.tsx
================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function Login() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [formError, setFormError] = useState<string | null>(null);
  const { login, loading, error } = useAuth();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Reset form error
    setFormError(null);
    
    // Validate form
    if (!username.trim()) {
      setFormError('Username is required');
      return;
    }
    
    if (!password) {
      setFormError('Password is required');
      return;
    }
    
    try {
      await login(username, password);
      // Redirect to home page after successful login
      navigate('/');
    } catch (error) {
      // Error is handled by the AuthContext
      console.error('Login failed:', error);
    }
  };

  return (
    <div className="w-full font-mono">
      <div className="w-full bg-black text-white py-6 px-4 mb-6 transform -rotate-0.5 shadow-md flex items-end justify-between">
        <div>
          <h1 className="text-4xl font-bold uppercase tracking-tight relative inline-block">
            <span className="text-teal-400">LOG</span>
            <span>IN</span>
            <span className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-teal-400 via-pink-400 to-purple-500"></span>
          </h1>
          <p className="text-gray-300 mt-2 ml-6 border-l-2 border-pink-400 pl-4">
            Enter your credentials to access your account
          </p>
        </div>
        <div className="hidden md:block relative w-20 h-20">
          <div className="absolute -top-2 -right-2 w-10 h-10 bg-teal-400 rounded-full opacity-50"></div>
          <div className="absolute bottom-0 left-0 w-12 h-12 bg-pink-400 rounded-full opacity-40"></div>
        </div>
      </div>
      
      <div className="max-w-sm mx-auto">
        {(formError || error) && (
          <div className="bg-black text-white p-3 mb-4 transform rotate-0.5 shadow-md">
            <span className="text-pink-400 font-bold uppercase">ERROR:</span> {formError || error}
          </div>
        )}
        
        <div className="bg-black text-white p-6 shadow-lg rounded-sm border-t-2 border-teal-400">
          <form className="space-y-4" onSubmit={handleSubmit}>
            <div>
              <label htmlFor="username" className="block text-sm font-bold uppercase tracking-wider text-teal-400 mb-1">
                Username
              </label>
              <input
                id="username"
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Enter your username"
                className="w-full p-3 bg-gray-900 text-white border-l-2 border-teal-400 focus:outline-none focus:ring-1 focus:ring-teal-400 placeholder-gray-500 transition-all"
                disabled={loading}
              />
            </div>
            
            <div className="mt-2">
              <label htmlFor="password" className="block text-sm font-bold uppercase tracking-wider text-pink-400 mb-1">
                Password
              </label>
              <input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Enter your password"
                className="w-full p-3 bg-gray-900 text-white border-l-2 border-pink-400 focus:outline-none focus:ring-1 focus:ring-pink-400 placeholder-gray-500 transition-all"
                disabled={loading}
              />
            </div>
            
            <div className="pt-2">
              <button
                type="submit"
                className="w-full px-6 py-3 bg-gradient-to-r from-teal-600 to-teal-500 text-white uppercase tracking-wider transform hover:translate-y-[-2px] transition-all shadow-md relative overflow-hidden group font-bold"
                disabled={loading}
              >
                {loading ? 'LOGGING IN...' : 'LOGIN'}
              </button>
            </div>
          </form>
          
          <div className="mt-6 text-center">
            <p className="text-gray-400 text-sm">
              Don't have an account?{' '}
              <Link to="/register" className="text-teal-400 hover:text-teal-300 font-bold uppercase inline-flex items-center group">
                Register here
                <span className="ml-1 transform translate-x-0 group-hover:translate-x-1 transition-transform"></span>
              </Link>
            </p>
          </div>
        </div>
        
        <div className="mt-4 bg-gray-900 p-3 border-l-4 border-pink-400 text-white text-xs text-center transform rotate-0.5">
          <span className="uppercase font-bold text-pink-400">TIP:</span>{' '}
          <span className="text-gray-300">Need an account to get started? Register to join our community!</span>
        </div>
      </div>
    </div>
  );
}

================
File: src/pages/PostDetail.tsx
================
import React, { useState, useEffect } from 'react'
import { useParams, Link } from 'react-router-dom'
import Post from '../components/Post'
import CommentSection from '../components/CommentSection'
import ActivityHistory from '../components/ActivityHistory'
import { getPost } from '../api/posts'
import { useAuth } from '../context/AuthContext'

export default function PostDetail() {
  const { postId } = useParams()
  const [post, setPost] = useState<any>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const { token } = useAuth()

  useEffect(() => {
    const fetchPostDetails = async () => {
      if (!postId) return

      try {
        setLoading(true)
        const data = await getPost(postId, token)
        setPost(data)
        setError(null)
      } catch (err) {
        console.error('Error fetching post details:', err)
        setError('Failed to load post details')
      } finally {
        setLoading(false)
      }
    }

    fetchPostDetails()
  }, [postId, token])

  // Show loading state
  if (loading) {
    return (
      <div className="max-w-6xl mx-auto px-4 py-6">
        <div className="animate-pulse bg-white p-6 shadow-md mb-6">
          <div className="h-6 bg-gray-200 rounded w-3/4 mb-4"></div>
          <div className="h-4 bg-gray-200 rounded w-full mb-2"></div>
          <div className="h-4 bg-gray-200 rounded w-full mb-2"></div>
          <div className="h-4 bg-gray-200 rounded w-2/3"></div>
        </div>
      </div>
    )
  }

  // Show error state
  if (error) {
    return (
      <div className="max-w-6xl mx-auto px-4 py-6">
        <div className="bg-white p-6 border-l-4 border-red-500 shadow-md mb-6">
          <div className="flex items-center">
            <svg className="w-6 h-6 text-red-500 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span className="font-medium">{error}</span>
          </div>
        </div>
      </div>
    )
  }

  // Return layout if post is loaded successfully
  return (
    <div className="max-w-6xl mx-auto px-4 py-6">
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        <div className="lg:col-span-3">
          <Post postId={postId || ''} />
          <CommentSection postId={postId || ''} />
        </div>
        <div className="hidden lg:block">
          {post && post.community_id && (
            <div className="bg-white p-4 shadow-md mb-4 border-l-4 border-teal-400">
              <h3 className="font-bold text-lg mb-2">About This Community</h3>
              <Link 
                to={`/community/${post.community_id}`}
                className="block font-medium text-teal-600 hover:underline"
              >
                {post.community_name || 'View Community'}
              </Link>
              <p className="text-sm text-gray-600 mt-2">
                {post.community_description || 'Join the discussion in this community.'}
              </p>
            </div>
          )}
          
          <div className="bg-white p-4 shadow-md mb-4 border-l-4 border-pink-400">
            <h3 className="font-bold text-lg mb-2">Community Rules</h3>
            <ol className="list-decimal list-inside text-sm text-gray-600">
              <li className="mb-1">Be respectful to others</li>
              <li className="mb-1">No spam or self-promotion</li>
              <li className="mb-1">Stay on topic</li>
            </ol>
          </div>
          
          <div className="bg-white p-4 shadow-md border-l-4 border-purple-400">
            <h3 className="font-bold text-lg mb-2">Post Activity</h3>
            <div className="max-h-[300px] overflow-y-auto">
              <ActivityHistory postId={postId || ''} limit={5} />
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

================
File: src/pages/Profile.tsx
================
import React, { useState, useEffect } from 'react'
import { useParams } from 'react-router-dom'
import UserInfo from '../components/UserInfo'
import UserPosts from '../components/UserPosts'
import ProfileActions from '../components/ProfileActions'
import EditProfileModal from '../components/EditProfileModal'
import ActivityHistory from '../components/ActivityHistory'
import { useAuth } from '../context/AuthContext'
import { getPosts } from '../api/posts'
import { getUserById, getUserByUsername } from '../api/users'

interface ProfileProps {
  isUser?: boolean;
}

interface Post {
  id: string;
  title?: string;
  content: string;
  userId?: string;
  username?: string;
  communityId?: string;
  community?: string;
  created_at?: string;
  likes?: number;
  comments?: number;
}

export default function Profile({ isUser }: ProfileProps) {
  const { username } = useParams()
  const { user, token } = useAuth()
  const [activeTab, setActiveTab] = useState<'profile' | 'community' | 'activity'>('profile')
  const [profilePosts, setProfilePosts] = useState<Post[]>([])
  const [communityPosts, setCommunityPosts] = useState<Post[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [userData, setUserData] = useState<any>(user)
  const [showEditModal, setShowEditModal] = useState(false)
  
  // Fetch posts when component mounts
  useEffect(() => {
    const fetchData = async () => {
      setLoading(true)
      setError(null)
      
      try {
        // If viewing own profile, use the authenticated user data
        if (isUser && user) {
          setUserData(user)
          
          // Fetch posts for the current user
          const posts = await getPosts(null, token)
          
          // For now, we'll just show all posts in the profile tab
          // In a real implementation, you'd filter these based on whether they're profile or community posts
          setProfilePosts(posts)
        } 
        // If viewing someone else's profile
        else if (username) {
          // Fetch user data by username
          try {
            // First, get all users
            const response = await fetch('http://localhost:3001/api/users')
            const users = await response.json()
            
            // Find the user with the matching username
            const matchedUser = users.find((user: any) => user.username === username)
            
            if (!matchedUser) {
              throw new Error('User not found')
            }
            
            setUserData(matchedUser)
            
            // Fetch posts for this user
            const posts = await getPosts(null, token)
            // Filter posts by this user
            const userPosts = posts.filter((post: Post) => post.userId === matchedUser.id)
            setProfilePosts(userPosts)
          } catch (err) {
            console.error('Failed to fetch user data:', err)
            setError('User not found')
          }
        }
      } catch (err) {
        console.error('Failed to fetch posts:', err)
        setError('Failed to load posts')
      } finally {
        setLoading(false)
      }
    }
    
    fetchData()
  }, [isUser, user, username, token])

  return (
    <div className="w-full font-mono">
      <div className="flex flex-col md:flex-row gap-8">
        {/* Left Sidebar - User Info */}
        <div className="w-full md:w-[300px] flex-shrink-0">
          <UserInfo 
            username={userData?.username || ''} 
            userData={userData}
            isCurrentUser={isUser}
            onEditProfile={() => setShowEditModal(true)}
          />
          
          {isUser && (
            <div className="mt-6">
              <ProfileActions onEditProfile={() => setShowEditModal(true)} />
            </div>
          )}
          
          {/* Edit Profile Modal */}
          {showEditModal && (
            <EditProfileModal
              onClose={() => setShowEditModal(false)}
              onSuccess={() => {
                setShowEditModal(false)
                // Refresh user data
                if (user) {
                  setUserData(user)
                }
              }}
            />
          )}
          
          {/* Communities Section */}
          <div className="mt-6 bg-black text-white p-6 transform -rotate-0.5 shadow-md">
            <h2 className="font-bold uppercase tracking-tight text-xl relative inline-block mb-4">
              <span className="text-teal-400">COMMUNITIES</span>
              <span className="absolute bottom-0 left-0 w-full h-1 bg-teal-400"></span>
            </h2>
            
            <div className="text-center py-4 text-gray-400">
              <p>No communities yet</p>
            </div>
          </div>
        </div>
        
        {/* Main Content - Posts */}
        <div className="flex-grow">
          {/* Tabs */}
          <div className="flex mb-6">
            <button 
              className={`flex-1 py-3 px-4 uppercase font-bold tracking-wider ${
                activeTab === 'profile' 
                  ? 'bg-black text-white border-b-2 border-teal-400' 
                  : 'bg-gray-200 text-gray-700'
              }`}
              onClick={() => setActiveTab('profile')}
            >
              Profile Posts
            </button>
            <button 
              className={`flex-1 py-3 px-4 uppercase font-bold tracking-wider ${
                activeTab === 'community' 
                  ? 'bg-black text-white border-b-2 border-pink-400' 
                  : 'bg-gray-200 text-gray-700'
              }`}
              onClick={() => setActiveTab('community')}
            >
              Community Posts
            </button>
            <button 
              className={`flex-1 py-3 px-4 uppercase font-bold tracking-wider ${
                activeTab === 'activity' 
                  ? 'bg-black text-white border-b-2 border-purple-400' 
                  : 'bg-gray-200 text-gray-700'
              }`}
              onClick={() => setActiveTab('activity')}
            >
              Activity
            </button>
          </div>
          
          {/* Content based on active tab */}
          {activeTab === 'profile' ? (
            <>
              {loading ? (
                <div className="text-center py-12 text-2xl uppercase tracking-widest animate-pulse">
                  Loading posts...
                </div>
              ) : error ? (
                <div className="bg-black text-white p-4 mb-6">
                  <span className="text-pink-400 font-bold uppercase">ERROR:</span> {error}
                </div>
              ) : profilePosts.length === 0 ? (
                <div className="text-center py-12 bg-black text-white">
                  <span className="text-2xl uppercase font-bold tracking-wider">EMPTY</span>
                  <p className="mt-4 text-gray-300">No profile posts yet.</p>
                </div>
              ) : (
                <UserPosts username={userData?.username || ''} posts={profilePosts} />
              )}
            </>
          ) : activeTab === 'community' ? (
            <>
              {loading ? (
                <div className="text-center py-12 text-2xl uppercase tracking-widest animate-pulse">
                  Loading posts...
                </div>
              ) : error ? (
                <div className="bg-black text-white p-4 mb-6">
                  <span className="text-pink-400 font-bold uppercase">ERROR:</span> {error}
                </div>
              ) : communityPosts.length === 0 ? (
                <div className="text-center py-12 bg-black text-white">
                  <span className="text-2xl uppercase font-bold tracking-wider">EMPTY</span>
                  <p className="mt-4 text-gray-300">No community posts yet.</p>
                </div>
              ) : (
                <UserPosts username={userData?.username || ''} posts={communityPosts} />
              )}
            </>
          ) : (
            // Activity tab
            <ActivityHistory 
              userId={userData?.id} 
              showFilters={true} 
            />
          )}
        </div>
      </div>
    </div>
  )
}

================
File: src/pages/Register.tsx
================
import React, { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

export default function Register() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [formError, setFormError] = useState<string | null>(null);
  const [passwordStrength, setPasswordStrength] = useState<string>('');
  const { register, loading, error } = useAuth();
  const navigate = useNavigate();

  // Check password strength
  const checkPasswordStrength = (password: string) => {
    if (!password) {
      setPasswordStrength('');
      return;
    }

    const hasUppercase = /[A-Z]/.test(password);
    const hasLowercase = /[a-z]/.test(password);
    const hasNumber = /[0-9]/.test(password);
    const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
    const isLongEnough = password.length >= 8;

    const strength = [hasUppercase, hasLowercase, hasNumber, hasSpecial, isLongEnough].filter(Boolean).length;

    if (strength < 2) {
      setPasswordStrength('weak');
    } else if (strength < 4) {
      setPasswordStrength('medium');
    } else {
      setPasswordStrength('strong');
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Reset form error
    setFormError(null);
    
    // Validate form
    if (!username.trim()) {
      setFormError('Username is required');
      return;
    }
    
    if (!email.trim()) {
      setFormError('Email is required');
      return;
    }
    
    if (!password) {
      setFormError('Password is required');
      return;
    }
    
    if (password !== confirmPassword) {
      setFormError('Passwords do not match');
      return;
    }
    
    // Check password strength
    const hasUppercase = /[A-Z]/.test(password);
    const hasLowercase = /[a-z]/.test(password);
    const hasNumber = /[0-9]/.test(password);
    const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
    const isLongEnough = password.length >= 8;
    
    if (!isLongEnough || !hasUppercase || !hasLowercase || !hasNumber || !hasSpecial) {
      setFormError('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
      return;
    }
    
    try {
      await register(username, email, password);
      // Redirect to home page after successful registration
      navigate('/');
    } catch (error) {
      // Error is handled by the AuthContext
      console.error('Registration failed:', error);
    }
  };

  return (
    <div className="w-full font-mono">
      <div className="w-full bg-black text-white py-6 px-4 mb-6 transform rotate-0.5 shadow-md flex items-end justify-between">
        <div>
          <h1 className="text-4xl font-bold uppercase tracking-tight relative inline-block">
            <span className="text-pink-400">REG</span>
            <span>IS</span>
            <span className="text-teal-400">TER</span>
            <span className="absolute bottom-0 left-0 w-full h-1 bg-gradient-to-r from-pink-400 via-teal-400 to-purple-500"></span>
          </h1>
          <p className="text-gray-300 mt-2 ml-6 border-l-2 border-teal-400 pl-4">
            Create a new account to join the community
          </p>
        </div>
        <div className="hidden md:block relative w-20 h-20">
          <div className="absolute -top-2 -right-2 w-12 h-12 bg-pink-400 rounded-full opacity-40"></div>
          <div className="absolute bottom-0 left-0 w-10 h-10 bg-teal-400 rounded-full opacity-50"></div>
        </div>
      </div>
      
      <div className="max-w-sm mx-auto">
        {(formError || error) && (
          <div className="bg-black text-white p-3 mb-4 transform -rotate-0.5 shadow-md">
            <span className="text-pink-400 font-bold uppercase">ERROR:</span> {formError || error}
          </div>
        )}
        
        <div className="bg-black text-white p-6 shadow-lg rounded-sm border-t-2 border-pink-400">
          <form className="space-y-4" onSubmit={handleSubmit}>
            <div>
              <label htmlFor="username" className="block text-sm font-bold uppercase tracking-wider text-teal-400 mb-1">
                Username
              </label>
              <input
                id="username"
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Choose a username"
                className="w-full p-3 bg-gray-900 text-white border-l-2 border-teal-400 focus:outline-none focus:ring-1 focus:ring-teal-400 placeholder-gray-500 transition-all"
                disabled={loading}
              />
            </div>
            
            <div className="mt-2">
              <label htmlFor="email" className="block text-sm font-bold uppercase tracking-wider text-pink-400 mb-1">
                Email
              </label>
              <input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                className="w-full p-3 bg-gray-900 text-white border-l-2 border-pink-400 focus:outline-none focus:ring-1 focus:ring-pink-400 placeholder-gray-500 transition-all"
                disabled={loading}
              />
            </div>
            
            <div className="mt-2">
              <label htmlFor="password" className="block text-sm font-bold uppercase tracking-wider text-purple-400 mb-1">
                Password
              </label>
              <input
                id="password"
                type="password"
                value={password}
                onChange={(e) => {
                  setPassword(e.target.value);
                  checkPasswordStrength(e.target.value);
                }}
                placeholder="Create a password"
                className="w-full p-3 bg-gray-900 text-white border-l-2 border-purple-400 focus:outline-none focus:ring-1 focus:ring-purple-400 placeholder-gray-500 transition-all"
                disabled={loading}
              />
              {passwordStrength && (
                <div className="mt-2">
                  <div className="flex items-center">
                    <div className="text-xs mr-2 text-gray-300">Strength:</div>
                    <div className="h-1.5 flex-grow rounded-sm overflow-hidden">
                      <div className={`h-full ${
                        passwordStrength === 'weak' ? 'w-1/3 bg-red-500' : 
                        passwordStrength === 'medium' ? 'w-2/3 bg-yellow-500' : 
                        'w-full bg-green-500'
                      } transition-all duration-300`}></div>
                    </div>
                  </div>
                </div>
              )}
            </div>
            
            <div className="mt-2">
              <label htmlFor="confirmPassword" className="block text-sm font-bold uppercase tracking-wider text-teal-400 mb-1">
                Confirm Password
              </label>
              <input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                placeholder="Confirm your password"
                className="w-full p-3 bg-gray-900 text-white border-l-2 border-teal-400 focus:outline-none focus:ring-1 focus:ring-teal-400 placeholder-gray-500 transition-all"
                disabled={loading}
              />
            </div>
            
            <div className="pt-2">
              <button
                type="submit"
                className="w-full px-6 py-3 bg-gradient-to-r from-pink-600 to-pink-500 text-white uppercase tracking-wider transform hover:translate-y-[-2px] transition-all shadow-md relative overflow-hidden font-bold"
                disabled={loading}
              >
                {loading ? 'REGISTERING...' : 'REGISTER'}
              </button>
            </div>
          </form>
          
          <div className="mt-5 text-center">
            <p className="text-gray-400 text-sm">
              Already have an account?{' '}
              <Link to="/login" className="text-pink-400 hover:text-pink-300 font-bold uppercase inline-flex items-center group">
                Login here
                <span className="ml-1 transform translate-x-0 group-hover:translate-x-1 transition-transform"></span>
              </Link>
            </p>
          </div>
        </div>
        
        <div className="mt-4 px-4">
          <p className="text-xs text-gray-500 bg-gray-100 p-3 rounded-sm">
            <span className="text-pink-500 font-bold">Note:</span> Password must be at least 8 characters and include 
            uppercase, lowercase, number, and special character for security.
          </p>
        </div>
      </div>
    </div>
  );
}

================
File: src/routes/index.tsx
================
import { createBrowserRouter } from 'react-router-dom'
import App from '../App'
import Home from '../pages/Home'
import Communities from '../pages/Communities'
import Community from '../pages/Community'
import Profile from '../pages/Profile'
import Login from '../pages/Login'
import Register from '../pages/Register'
import PostDetail from '../pages/PostDetail'
import CommunityModeration from '../pages/CommunityModeration'

export const router = createBrowserRouter([
  {
    path: '/',
    element: <App />,
    children: [
      { index: true, element: <Home /> },
      { path: 'communities', element: <Communities /> },
      { path: 'community/:id', element: <Community /> },
      { path: 'community/:communityId/moderation', element: <CommunityModeration /> },
      { path: 'profile', element: <Profile isUser={true} /> },
      { path: 'profile/:username', element: <Profile isUser={false} /> },
      { path: 'login', element: <Login /> },
      { path: 'register', element: <Register /> },
      { path: 'post/:postId', element: <PostDetail /> },
    ],
  },
])

================
File: src/types.ts
================
export interface Community {
  __typename?: 'Community';
  id: string;
  name: string;
  description: string;
  createdAt: string;
  updatedAt: string;
  membersCount: number;
  postsCount: number;
  rules?: CommunityRule[];
  moderators?: string[];
  bannerImage?: string;
  iconImage?: string;
}

export interface CommunityRule {
  id: string;
  title: string;
  description: string;
}

export interface CreateCommunityInput {
  name: string;
  description: string;
  rules?: CommunityRule[];
  bannerImage?: string;
  iconImage?: string;
}

export interface UpdateCommunityInput {
  name?: string;
  description?: string;
  rules?: CommunityRule[];
  bannerImage?: string;
  iconImage?: string;
}

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'craigslist-blue': '#007bff',
        'craigslist-gray': '#f8f9fa',
      },
    },
  },
  plugins: [],
}

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": ["vite.config.ts"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
  optimizeDeps: {
    exclude: ['lucide-react'],
  },
})

================
File: vite.config.ts.timestamp-1740451079238-bcbb258007fe8.mjs
================
// vite.config.ts
import { defineConfig } from "file:///C:/Users/sadow/Desktop/rumfor/git_project_bolt-vite-react-ts-template.git_(fork)_gu70k0/node_modules/vite/dist/node/index.js";
import react from "file:///C:/Users/sadow/Desktop/rumfor/git_project_bolt-vite-react-ts-template.git_(fork)_gu70k0/node_modules/@vitejs/plugin-react/dist/index.mjs";
import path from "path";
var __vite_injected_original_dirname = "C:\\Users\\sadow\\Desktop\\rumfor\\git_project_bolt-vite-react-ts-template.git_(fork)_gu70k0";
var vite_config_default = defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__vite_injected_original_dirname, "src")
    }
  },
  optimizeDeps: {
    exclude: ["lucide-react"]
  }
});
export {
  vite_config_default as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidml0ZS5jb25maWcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxVc2Vyc1xcXFxzYWRvd1xcXFxEZXNrdG9wXFxcXHJ1bWZvclxcXFxnaXRfcHJvamVjdF9ib2x0LXZpdGUtcmVhY3QtdHMtdGVtcGxhdGUuZ2l0Xyhmb3JrKV9ndTcwazBcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFVzZXJzXFxcXHNhZG93XFxcXERlc2t0b3BcXFxccnVtZm9yXFxcXGdpdF9wcm9qZWN0X2JvbHQtdml0ZS1yZWFjdC10cy10ZW1wbGF0ZS5naXRfKGZvcmspX2d1NzBrMFxcXFx2aXRlLmNvbmZpZy50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovVXNlcnMvc2Fkb3cvRGVza3RvcC9ydW1mb3IvZ2l0X3Byb2plY3RfYm9sdC12aXRlLXJlYWN0LXRzLXRlbXBsYXRlLmdpdF8oZm9yaylfZ3U3MGswL3ZpdGUuY29uZmlnLnRzXCI7aW1wb3J0IHsgZGVmaW5lQ29uZmlnIH0gZnJvbSAndml0ZSdcbmltcG9ydCByZWFjdCBmcm9tICdAdml0ZWpzL3BsdWdpbi1yZWFjdCdcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5cbi8vIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xuICBwbHVnaW5zOiBbcmVhY3QoKV0sXG4gIHJlc29sdmU6IHtcbiAgICBhbGlhczoge1xuICAgICAgJ0AnOiBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnc3JjJyksXG4gICAgfSxcbiAgfSxcbiAgb3B0aW1pemVEZXBzOiB7XG4gICAgZXhjbHVkZTogWydsdWNpZGUtcmVhY3QnXSxcbiAgfSxcbn0pXG4iXSwKICAibWFwcGluZ3MiOiAiO0FBQW1jLFNBQVMsb0JBQW9CO0FBQ2hlLE9BQU8sV0FBVztBQUNsQixPQUFPLFVBQVU7QUFGakIsSUFBTSxtQ0FBbUM7QUFLekMsSUFBTyxzQkFBUSxhQUFhO0FBQUEsRUFDMUIsU0FBUyxDQUFDLE1BQU0sQ0FBQztBQUFBLEVBQ2pCLFNBQVM7QUFBQSxJQUNQLE9BQU87QUFBQSxNQUNMLEtBQUssS0FBSyxRQUFRLGtDQUFXLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0Y7QUFBQSxFQUNBLGNBQWM7QUFBQSxJQUNaLFNBQVMsQ0FBQyxjQUFjO0FBQUEsRUFDMUI7QUFDRixDQUFDOyIsCiAgIm5hbWVzIjogW10KfQo=



================================================================
End of Codebase
================================================================
