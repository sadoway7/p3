This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
backend/.env
backend/.env.backup
backend/activity-handler.js
backend/api/activity.js
backend/api/activity.ts
backend/api/auth.js
backend/api/auth.js.new
backend/api/auth.ts
backend/api/auth.ts.new
backend/api/comments.js
backend/api/comments.js.new
backend/api/comments.ts
backend/api/communities.js
backend/api/communities.js.new
backend/api/communities.js.new.part2
backend/api/communities.ts
backend/api/communities.ts.new
backend/api/community_fix.js
backend/api/community/community-core.js
backend/api/community/community-members.js
backend/api/community/community-requests.js
backend/api/community/community-rules.js
backend/api/community/community-search.js
backend/api/community/community-settings.js
backend/api/community/index.js
backend/api/community/README.md
backend/api/moderation.ts
backend/api/moderation.ts.new
backend/api/posts_enhanced.js
backend/api/posts.js
backend/api/posts.js.new
backend/api/posts.ts
backend/api/users.ts
backend/api/votes.js
backend/api/votes.js.new
backend/api/votes.ts
backend/check-community.js
backend/check-tables.js
backend/db/add_admin_user.js
backend/db/apply_auth_schema.js
backend/db/apply_comments_schema.js
backend/db/apply_community_updates.js
backend/db/apply_moderator_schema.js
backend/db/apply_new_schema.js
backend/db/apply_user_auth_schema.js
backend/db/apply_user_statistics_schema.js
backend/db/apply_votes_schema.js
backend/db/comments_schema_updates.sql
backend/db/community_schema_updates.sql
backend/db/connection.d.ts
backend/db/connection.js
backend/db/connection.ts
backend/db/fetch_usernames.js
backend/db/fix_community_api.js
backend/db/fixed_schema.sql
backend/db/generate_sample_data.js
backend/db/init_schema.js
backend/db/init.js
backend/db/migrate_data.js
backend/db/migrate_database.bat
backend/db/moderator_schema_updates.sql
backend/db/new_schema.sql
backend/db/README_DATABASE_REFACTORING.md
backend/db/schema.sql
backend/db/seed_communities.js
backend/db/simple_schema.sql
backend/db/update_auth_files.js
backend/db/update_connection.js
backend/db/user_auth_schema.sql
backend/db/user_statistics_schema.sql
backend/db/votes_schema_update.sql
backend/fix_moderator_usernames.js
backend/fix-table-names.js
backend/index.js
backend/index.ts
backend/middleware/activity.js
backend/middleware/auth.js
backend/middleware/moderation.js
backend/middleware/moderation.js.new
backend/package.json
backend/routes/activity.js
backend/routes/auth.js
backend/routes/auth.js.new
backend/routes/comments.js
backend/routes/comments.js.new
backend/routes/communities.js
backend/routes/communities.js.new
backend/routes/moderation.js
backend/routes/moderation.js.new
backend/routes/posts.js
backend/routes/posts.js.new
backend/routes/users.js
backend/routes/votes.js
backend/routes/votes.js.new
backend/test-api.js
backend/testServer.js
backend/tsconfig.json
backend/types/index.ts
eslint.config.js
index.html
package.json
postcss.config.js
REFACTORING.md
src/api/activities.ts
src/api/comments.ts
src/api/communities.ts
src/api/compatibility.ts
src/api/mockData.ts
src/api/moderation.ts
src/api/posts.ts
src/api/users.ts
src/api/votes.ts
src/App.tsx
src/components/ActivityHistory.tsx
src/components/ActivityHistory.tsxold
src/components/CommentItem.tsx
src/components/CommentSection.tsx
src/components/CommunityAbout.tsx
src/components/CommunityCard.tsx
src/components/CommunityDiscovery.tsx
src/components/CommunityDiscoverySidebar.tsx
src/components/CommunityHeader.tsx
src/components/CommunityInfo.tsx
src/components/CommunityList.tsx
src/components/CommunityModControls.tsx
src/components/CommunityRules.tsx
src/components/CommunitySearch.tsx
src/components/CommunitySettings.tsx
src/components/CommunitySidebar.tsx
src/components/CreateCommunityModal.tsx
src/components/CreatePostModal.tsx
src/components/EditProfileModal.tsx
src/components/ModeratorDashboard.tsx
src/components/Navbar.tsx
src/components/Post.tsx
src/components/PostCreationForm.tsx
src/components/PostItem.tsx
src/components/PostList.tsx
src/components/ProfileActions.tsx
src/components/Sidebar.tsx
src/components/UserInfo.tsx
src/components/UserPosts.tsx
src/context/AuthContext.tsx
src/context/CommunityContext.tsx
src/debug/ModeratorDebug.tsx
src/index.css
src/main.tsx
src/pages/Communities.tsx
src/pages/Community.tsx
src/pages/CommunityModeration.tsx
src/pages/Home.tsx
src/pages/Login.tsx
src/pages/PostDetail.tsx
src/pages/Profile.tsx
src/pages/Register.tsx
src/routes/index.tsx
src/types.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
vite.config.ts.timestamp-1740451079238-bcbb258007fe8.mjs

================================================================
Files
================================================================

================
File: .gitignore
================
# Logs
logs
ARCHIVED
.git_disabled
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
ARCHIVED
.git_disabled

================
File: backend/.env
================
API_KEY=AIzaSyCqBgYt00ik2BzpxDKz2b6aNHK6yt2cdeE
DB_HOST=68.146.102.33
DB_PORT=3306
DB_USER=rumfornew2
DB_PASSWORD=Oswald1986!
DB_NAME=rumfornew2
JWT_SECRET=rumfor-secret-key-for-jwt-authentication

================
File: backend/.env.backup
================
API_KEY=AIzaSyCqBgYt00ik2BzpxDKz2b6aNHK6yt2cdeE
DB_HOST=192.168.0.139
DB_PORT=3306
DB_USER=root
DB_PASSWORD=Oswald1986!
DB_NAME=rumfor1
JWT_SECRET=rumfor-secret-key-for-jwt-authentication

================
File: backend/activity-handler.js
================
const router = express.Router();
require('dotenv').config();
const pool = mysql.createPool({
  port: Number(process.env.DB_PORT),
router.get('/community/:communityId', async (req, res) => {
    const limit = parseInt(req.query.limit || '10', 10);
    const offset = parseInt(req.query.offset || '0', 10);
    res.json([]);
    console.error('Error fetching community activities:', error);
    res.status(500).json({ error: 'Failed to fetch community activities' });

================
File: backend/api/activity.js
================
async function getUserActivities(userId, options = {}) {
    conn = await pool.getConnection();
      queryParams.push(activityType);
      queryParams.push(actionType);
      queryParams.push(entityType);
      queryParams.push(startDate);
      queryParams.push(endDate);
    queryParams.push(parseInt(limit), parseInt(offset));
    const activities = await conn.query(query, queryParams);
    if (Array.isArray(activities)) {
            const entityDetails = await getEntityDetails(conn, activity.entity_id, activity.entity_type);
            console.error(`Error fetching details for ${activity.entity_type}:${activity.entity_id}`, detailsError);
      console.warn("Expected activities array but received:", typeof activities);
    console.error("Error fetching user activities:", error);
    if (conn) conn.release();
async function getCommunityActivities(communityId, options = {}) {
    console.error("Error fetching community activities:", error);
async function getPostActivities(postId, options = {}) {
    const activities = await conn.query(query, [postId, postId, parseInt(limit), parseInt(offset)]);
    console.error("Error fetching post activities:", error);
async function getActivityTypes() {
    const activityTypes = await conn.query(
    console.error("Error fetching activity types:", error);
async function getActionTypes() {
    const actionTypes = await conn.query(
    console.error("Error fetching action types:", error);
async function logActivity(activityData) {
    console.warn("Attempted to log activity without user ID:", activityData);
    const [activityTypeRecord] = await conn.query(
      console.warn(`Activity type '${activityType}' not found, creating it.`);
      const activityTypeId = uuidv4();
      await conn.query(
    const [actionTypeRecord] = await conn.query(
      console.warn(`Action type '${actionType}' not found, creating it.`);
      const actionTypeId = uuidv4();
    const activityId = uuidv4();
        metadata ? JSON.stringify(metadata) : null,
    const [activity] = await conn.query(
    console.error("Error logging activity:", error);
async function getEntityDetails(conn, entityId, entityType) {
        const [post] = await conn.query(
        const [comment] = await conn.query(
        const [community] = await conn.query(
        const [user] = await conn.query(
    console.error(`Error getting ${entityType} details:`, error);

================
File: backend/api/activity.ts
================
interface ActivityRow {
export async function getUserActivities(userId: string, options: ActivityOptions = {}): Promise<Activity[]> {
export async function getCommunityActivities(communityId: string, options: ActivityOptions = {}): Promise<Activity[]> {
export async function getPostActivities(postId: string, options: ActivityOptions = {}): Promise<Activity[]> {
export async function getActivityTypes(): Promise<ActivityType[]> {
export async function getActionTypes(): Promise<ActionType[]> {
export async function logActivity(activityData: ActivityData): Promise<Activity | null> {
async function getEntityDetails(conn: any, entityId: string, entityType: string): Promise<any | null> {

================
File: backend/api/auth.js
================
const isStrongPassword = (password) => {
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
const register = async (userData) => {
    if (!isStrongPassword(password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    conn = await pool.getConnection();
    await conn.beginTransaction();
      const [existingUsers] = await conn.query(
      if (Array.isArray(existingUsers) && existingUsers.length > 0) {
        if (existingUsers.some(user => user.username === username)) {
          throw new Error('Username already exists');
        if (existingUsers.some(user => user.email === email)) {
          throw new Error('Email already exists');
        throw new Error('Username or email already exists');
      const salt = await bcrypt.genSalt(10);
      const password_hash = await bcrypt.hash(password, salt);
      const id = uuidv4();
      const now = new Date();
      await conn.query(
      await conn.commit();
      const [results] = await conn.query(
      const newUser = Array.isArray(results) && results.length > 0 ? results[0] : null;
        throw new Error('Failed to retrieve created user');
      logActivity({
      }).catch(error => {
        console.error("Error logging registration activity:", error);
      await conn.rollback();
    console.error("Error registering user:", error);
    if (conn) conn.release();
const login = async (credentials) => {
    const [users] = await conn.query(
    const user = Array.isArray(users) && users.length > 0 ? users[0] : null;
      throw new Error('Invalid username or password');
    const isMatch = await bcrypt.compare(password, user.password_hash);
      [new Date(), user.id]
    const token = jwt.sign(
      console.error("Error logging login activity:", error);
    console.error("Error logging in:", error);
const getCurrentUser = async (userId) => {
      throw new Error('User not found');
      [new Date(), userId]
    console.error("Error getting current user:", error);
const verifyToken = (token) => {
    return jwt.verify(token, JWT_SECRET);
    throw new Error('Invalid token');
const logout = async (userId) => {
    await logActivity({
    console.error("Error logging out:", error);

================
File: backend/api/auth.js.new
================
// Updated auth.js for the new database schema
const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');
const { logActivity } = require('./activity.js');

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Password validation
const isStrongPassword = (password) => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// Register a new user
const register = async (userData) => {
  const { username, email, password } = userData;
  let conn;
  
  try {
    // Validate password strength
    if (!isStrongPassword(password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [username, email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const salt = await bcrypt.genSalt(10);
    const password_hash = await bcrypt.hash(password, salt);
    
    // Create a new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, username, email, password_hash, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Return user without password
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username, email },
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Login a user
const login = async (credentials) => {
  const { username, password } = credentials;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [user] = await conn.query(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [username]
    );
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Check password
    const isMatch = await bcrypt.compare(password, user.password_hash);
    if (!isMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id, 
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: '1d' }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get current user
const getCurrentUser = async (userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [user] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Verify JWT token
const verifyToken = (token) => {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (error) {
    throw new Error('Invalid token');
  }
};

// Logout (just for activity logging)
const logout = async (userId) => {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
};

module.exports = {
  register,
  login,
  getCurrentUser,
  verifyToken,
  logout
};

================
File: backend/api/auth.ts
================
interface User {
  date_of_birth?: Date;
  cake_day?: Date;
  created_at: Date;
  updated_at: Date;
  last_active?: Date;
const isStrongPassword = (password: string): boolean => {
export async function register(userData: { username: string; email: string; password: string }) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
      throw new Error('Username or email already exists');
    const now = new Date();
export async function login(credentials: { username: string; password: string }) {
      throw new Error('Invalid username or password');
      [new Date(), user.id]
export async function getCurrentUser(userId: string) {
      throw new Error('User not found');
      [new Date(), userId]
export function verifyToken(token: string) {
    throw new Error('Invalid token');
export async function logout(userId: string) {

================
File: backend/api/auth.ts.new
================
// Updated auth.ts for the new database schema
import { v4 as uuidv4 } from 'uuid';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { logActivity } from './activity';
import pool from '../db/connection';

dotenv.config();

// JWT secret key
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
// Token expiration (1 day)
const TOKEN_EXPIRATION = '1d';

// User interface
interface User {
  id: string;
  username: string;
  email: string;
  password_hash?: string;
  role: string;
  first_name?: string;
  last_name?: string;
  display_name?: string;
  date_of_birth?: Date;
  bio?: string;
  avatar_url?: string;
  profile_banner_url?: string;
  website?: string;
  location?: string;
  is_verified?: boolean;
  status?: string;
  cake_day?: Date;
  created_at: Date;
  updated_at: Date;
  last_active?: Date;
  karma?: number;
  posts_count?: number;
  comments_count?: number;
  upvotes_received?: number;
  downvotes_received?: number;
  upvotes_given?: number;
  downvotes_given?: number;
  communities_joined?: number;
}

// Password validation
const isStrongPassword = (password: string): boolean => {
  // At least 8 characters
  if (password.length < 8) return false;
  
  // Check for uppercase, lowercase, number, and special character
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);
  
  return hasUppercase && hasLowercase && hasNumber && hasSpecial;
};

// User registration
export async function register(userData: { username: string; email: string; password: string }) {
  let conn;
  try {
    // Validate password strength
    if (!isStrongPassword(userData.password)) {
      throw new Error('Password must be at least 8 characters and include uppercase, lowercase, number, and special character');
    }
    
    conn = await pool.getConnection();
    
    // Start transaction
    await conn.beginTransaction();
    
    // Check if username or email already exists
    const [existingUser] = await conn.query(
      "SELECT * FROM user WHERE username = ? OR email = ?",
      [userData.username, userData.email]
    );
    
    if (existingUser) {
      throw new Error('Username or email already exists');
    }
    
    // Hash the password
    const saltRounds = 10;
    const hashedPassword = await bcrypt.hash(userData.password, saltRounds);
    
    // Create new user
    const id = uuidv4();
    const now = new Date();
    
    await conn.query(
      `INSERT INTO user (
        id, username, email, password_hash, role, 
        created_at, updated_at, cake_day, last_active
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, userData.username, userData.email, hashedPassword, 'user', now, now, now, now]
    );
    
    // Create user statistics record
    await conn.query(
      `INSERT INTO user_statistic (
        user_id, karma, posts_count, comments_count, 
        upvotes_received, downvotes_received, upvotes_given, 
        downvotes_given, communities_joined, created_at, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, 0, 0, 0, 0, 0, 0, 0, 0, now, now]
    );
    
    // Create user settings record
    await conn.query(
      `INSERT INTO user_setting (
        user_id, email_notifications, push_notifications, 
        theme, content_filter, allow_followers, 
        display_online_status, language, timezone, updated_at
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, true, true, 'light', 'standard', true, true, 'en', 'UTC', now]
    );
    
    // Commit transaction
    await conn.commit();
    
    // Get the created user (without password)
    const [newUser] = await conn.query(
      `SELECT u.id, u.username, u.email, u.role, u.created_at, u.updated_at,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [id]
    );
    
    // Log activity
    try {
      await logActivity({
        userId: id,
        activityType: 'USER',
        actionType: 'REGISTER',
        entityId: id,
        entityType: 'user',
        metadata: { username: userData.username, email: userData.email },
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging registration activity:", error);
      // Don't throw, just log the error
    }
    
    return { user: newUser };
  } catch (error) {
    // Rollback transaction on error
    if (conn) {
      try {
        await conn.rollback();
      } catch (rollbackError) {
        console.error("Error rolling back transaction:", rollbackError);
      }
    }
    
    console.error("Error registering user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// User login
export async function login(credentials: { username: string; password: string }) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by username
    const [user] = await conn.query<User[]>(
      `SELECT u.*, s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.username = ?`,
      [credentials.username]
    );
    
    if (!user) {
      throw new Error('Invalid username or password');
    }
    
    // Compare passwords
    const passwordMatch = await bcrypt.compare(credentials.password, user.password_hash || '');
    
    if (!passwordMatch) {
      throw new Error('Invalid username or password');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), user.id]
    );
    
    // Generate JWT token
    const token = jwt.sign(
      { 
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role
      },
      JWT_SECRET,
      { expiresIn: TOKEN_EXPIRATION }
    );
    
    // Log activity
    try {
      await logActivity({
        userId: user.id,
        activityType: 'USER',
        actionType: 'LOGIN',
        entityId: user.id,
        entityType: 'user',
        metadata: null,
        ipAddress: null,
        userAgent: null
      });
    } catch (error) {
      console.error("Error logging login activity:", error);
      // Don't throw, just log the error
    }
    
    // Return user info and token (without password)
    const { password_hash, ...userWithoutPassword } = user;
    
    return {
      user: userWithoutPassword,
      token
    };
  } catch (error) {
    console.error("Error logging in:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get current user from token
export async function getCurrentUser(userId: string) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Find user by ID with statistics
    const [user] = await conn.query<User[]>(
      `SELECT u.id, u.username, u.email, u.role, u.first_name, u.last_name,
        u.display_name, u.bio, u.avatar_url, u.profile_banner_url, u.website,
        u.location, u.is_verified, u.status, u.cake_day, u.created_at, 
        u.updated_at, u.last_active,
        s.karma, s.posts_count, s.comments_count, s.upvotes_received, 
        s.downvotes_received, s.upvotes_given, s.downvotes_given, 
        s.communities_joined
      FROM user u
      LEFT JOIN user_statistic s ON u.id = s.user_id
      WHERE u.id = ?`,
      [userId]
    );
    
    if (!user) {
      throw new Error('User not found');
    }
    
    // Update last_active timestamp
    await conn.query(
      "UPDATE user SET last_active = ? WHERE id = ?",
      [new Date(), userId]
    );
    
    return user;
  } catch (error) {
    console.error("Error getting current user:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Middleware to verify JWT token
export function verifyToken(token: string) {
  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    return decoded;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// Logout (just for activity logging)
export async function logout(userId: string) {
  try {
    // Log activity
    await logActivity({
      userId,
      activityType: 'USER',
      actionType: 'LOGOUT',
      entityId: userId,
      entityType: 'user',
      metadata: null,
      ipAddress: null,
      userAgent: null
    });
    
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    throw error;
  }
}

================
File: backend/api/comments.js
================
const getPostComments = async (postId) => {
    conn = await pool.getConnection();
    const comments = await conn.query(`
    console.error("Error fetching post comments:", error);
    if (conn) conn.release();
const getComment = async (commentId) => {
    const [comment] = await conn.query(`
    console.error("Error fetching comment:", error);
const createComment = async (userId, commentData) => {
    await conn.beginTransaction();
      const [post] = await conn.query(
        throw new Error('Post not found');
        const [parentComment] = await conn.query(
          throw new Error('Parent comment not found');
      const id = uuidv4();
        values.push(parent_comment_id);
      await conn.query(query, values);
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'CREATE');
      await conn.query(
          uuidv4(),
          JSON.stringify({
      const [newComment] = await conn.query(`
      await conn.commit();
      await conn.rollback();
    console.error("Error creating comment:", error);
const updateComment = async (commentId, userId, content) => {
      const [comment] = await conn.query(
        throw new Error('You can only update your own comments');
      const actionId = await getActionId(conn, 'UPDATE');
      const [updatedComment] = await conn.query(`
    console.error("Error updating comment:", error);
const deleteComment = async (commentId, userId) => {
        const [moderator] = await conn.query(
          throw new Error('You can only delete your own comments or comments in communities you moderate');
      const findReplies = async (parentId, replyIds = []) => {
        const replies = await conn.query(
          replyIds.push(reply.id);
          await findReplies(reply.id, replyIds);
      const replyIds = await findReplies(commentId);
      const actionId = await getActionId(conn, 'DELETE');
          const [reply] = await conn.query(
        const placeholders = replyIds.map(() => '?').join(',');
    console.error("Error deleting comment:", error);
const getCommentReplies = async (commentId) => {
    const replies = await conn.query(`
    console.error("Error fetching comment replies:", error);
const getThreadedComments = async (postId) => {
    const commentsWithReplies = comments.map(comment => ({
    const commentMap = new Map();
    commentsWithReplies.forEach(comment => {
      commentMap.set(comment.id, comment);
        const parent = commentMap.get(comment.parent_comment_id);
          parent.replies.push(comment);
          rootComments.push(comment);
    console.error("Error fetching threaded comments:", error);
const getUserComments = async (userId) => {
    console.error("Error fetching user comments:", error);
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
async function getActionId(conn, actionName) {
  const [action] = await conn.query(

================
File: backend/api/comments.js.new
================
// JavaScript version of comments.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all comments for a post
const getPostComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching post comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get a specific comment
const getComment = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [comment] = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.id = ?
    `, [commentId]);
    
    return comment || null;
  } catch (error) {
    console.error("Error fetching comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Create a new comment
const createComment = async (userId, commentData) => {
  const { content, post_id, parent_comment_id } = commentData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if post exists
      const [post] = await conn.query(
        "SELECT * FROM post WHERE id = ?",
        [post_id]
      );
      
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if parent comment exists if provided
      if (parent_comment_id) {
        const [parentComment] = await conn.query(
          "SELECT * FROM comment WHERE id = ?",
          [parent_comment_id]
        );
        
        if (!parentComment) {
          throw new Error('Parent comment not found');
        }
      }
      
      // Create the comment
      const id = uuidv4();
      
      let query = "INSERT INTO comment (id, content, user_id, post_id";
      let values = [id, content, userId, post_id];
      
      if (parent_comment_id) {
        query += ", parent_comment_id) VALUES (?, ?, ?, ?, ?)";
        values.push(parent_comment_id);
      } else {
        query += ") VALUES (?, ?, ?, ?)";
      }
      
      await conn.query(query, values);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'CREATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          id,
          'comment',
          JSON.stringify({
            post_id: post_id,
            parent_comment_id: parent_comment_id || null
          })
        ]
      );
      
      // Get the created comment with username
      const [newComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      return newComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Update a comment
const updateComment = async (commentId, userId, content) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return null;
      }
      
      if (comment.user_id !== userId) {
        throw new Error('You can only update your own comments');
      }
      
      // Update the comment
      await conn.query(
        "UPDATE comment SET content = ? WHERE id = ?",
        [content, commentId]
      );
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Get the updated comment with username
      const [updatedComment] = await conn.query(`
        SELECT c.*, u.username
        FROM comment c
        LEFT JOIN user u ON c.user_id = u.id
        WHERE c.id = ?
      `, [commentId]);
      
      // Commit the transaction
      await conn.commit();
      
      return updatedComment;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Delete a comment
const deleteComment = async (commentId, userId) => {
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if comment exists and belongs to the user
      const [comment] = await conn.query(
        "SELECT * FROM comment WHERE id = ?",
        [commentId]
      );
      
      if (!comment) {
        return false;
      }
      
      // Check if user is the comment author or a moderator of the community
      if (comment.user_id !== userId) {
        // Get the post to find the community
        const [post] = await conn.query(
          "SELECT community_id FROM post WHERE id = ?",
          [comment.post_id]
        );
        
        if (!post) {
          throw new Error('Post not found');
        }
        
        // Check if user is a moderator
        const [moderator] = await conn.query(
          "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
          [post.community_id, userId]
        );
        
        if (!moderator) {
          throw new Error('You can only delete your own comments or comments in communities you moderate');
        }
      }
      
      // Find all replies to this comment recursively
      const findReplies = async (parentId, replyIds = []) => {
        const replies = await conn.query(
          "SELECT id FROM comment WHERE parent_comment_id = ?",
          [parentId]
        );
        
        for (const reply of replies) {
          replyIds.push(reply.id);
          await findReplies(reply.id, replyIds);
        }
        
        return replyIds;
      };
      
      const replyIds = await findReplies(commentId);
      
      // Log activity for the main comment
      const activityTypeId = await getActivityTypeId(conn, 'COMMENT');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          commentId,
          'comment',
          JSON.stringify({
            post_id: comment.post_id,
            parent_comment_id: comment.parent_comment_id || null
          })
        ]
      );
      
      // Delete all replies
      if (replyIds.length > 0) {
        // Log activity for each reply
        for (const replyId of replyIds) {
          const [reply] = await conn.query(
            "SELECT * FROM comment WHERE id = ?",
            [replyId]
          );
          
          if (reply) {
            await conn.query(
              `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
               VALUES (?, ?, ?, ?, ?, ?, ?)`,
              [
                uuidv4(),
                userId,
                activityTypeId,
                actionId,
                replyId,
                'comment',
                JSON.stringify({
                  post_id: reply.post_id,
                  parent_comment_id: reply.parent_comment_id || null
                })
              ]
            );
          }
        }
        
        const placeholders = replyIds.map(() => '?').join(',');
        await conn.query(
          `DELETE FROM comment WHERE id IN (${placeholders})`,
          replyIds
        );
      }
      
      // Delete the comment
      await conn.query(
        "DELETE FROM comment WHERE id = ?",
        [commentId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      return true;
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting comment:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get replies to a comment
const getCommentReplies = async (commentId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const replies = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.parent_comment_id = ?
      ORDER BY c.created_at ASC
    `, [commentId]);
    
    return replies;
  } catch (error) {
    console.error("Error fetching comment replies:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get threaded comments for a post
const getThreadedComments = async (postId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get all comments for the post with usernames
    const comments = await conn.query(`
      SELECT c.*, u.username
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      WHERE c.post_id = ?
      ORDER BY c.created_at ASC
    `, [postId]);
    
    // Add replies array to each comment
    const commentsWithReplies = comments.map(comment => ({
      ...comment,
      username: comment.username || 'Anonymous',
      replies: []
    }));
    
    // Create a map for quick lookup
    const commentMap = new Map();
    commentsWithReplies.forEach(comment => {
      commentMap.set(comment.id, comment);
    });
    
    // Organize into a tree structure
    const rootComments = [];
    
    commentsWithReplies.forEach(comment => {
      if (comment.parent_comment_id) {
        const parent = commentMap.get(comment.parent_comment_id);
        if (parent) {
          parent.replies.push(comment);
        } else {
          rootComments.push(comment);
        }
      } else {
        rootComments.push(comment);
      }
    });
    
    return rootComments;
  } catch (error) {
    console.error("Error fetching threaded comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Get user comments
const getUserComments = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const comments = await conn.query(`
      SELECT c.*, u.username, p.title as post_title, p.community_id
      FROM comment c
      LEFT JOIN user u ON c.user_id = u.id
      LEFT JOIN post p ON c.post_id = p.id
      WHERE c.user_id = ?
      ORDER BY c.created_at DESC
    `, [userId]);
    
    return comments;
  } catch (error) {
    console.error("Error fetching user comments:", error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPostComments,
  getComment,
  createComment,
  updateComment,
  deleteComment,
  getCommentReplies,
  getThreadedComments,
  getUserComments
};

================
File: backend/api/comments.ts
================
export interface Comment {
    created_at: Date;
    updated_at: Date;
export interface CommentInput {
export async function getPostComments(postId: string): Promise<Comment[]> {
        throw new Error('Failed to fetch comments');
export async function getComment(commentId: string): Promise<Comment | null> {
        throw new Error('Failed to fetch comment');
export async function createComment(userId: string, commentData: CommentInput): Promise<Comment> {
        throw new Error('Failed to create comment');
export async function updateComment(
            throw new Error('You can only update your own comments');
export async function deleteComment(commentId: string, userId: string): Promise<boolean> {
            throw new Error('You can only delete your own comments');
export async function getCommentReplies(commentId: string): Promise<Comment[]> {
        throw new Error('Failed to fetch comment replies');
export interface ThreadedComment extends Comment {
export async function getThreadedComments(postId: string): Promise<ThreadedComment[]> {
        const commentMap = new Map<string, ThreadedComment>();
        comments.forEach((comment: ThreadedComment) => {
        throw new Error('Failed to fetch threaded comments');

================
File: backend/api/communities.js
================
console.warn(

================
File: backend/api/communities.js.new
================
llconst mariadb = require('mariadb');
const { v4: uuidv4 } = require('uuid');
const dotenv = require('dotenv');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../.env') });

const pool = mariadb.createPool({
  host: process.env.DB_HOST,
  port: Number(process.env.DB_PORT),
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  connectionLimit: 5
});

// Community CRUD operations
const getCommunities = async () => {
  let conn;
  try {
    conn = await pool.getConnection();
    const communities = await conn.query("SELECT * FROM community");
    return communities;
  } catch (error) {
    console.error("Error fetching communities:", error);
    throw new Error('Failed to fetch communities');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunity = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    return community || null;
  } catch (error) {
    console.error("Error fetching community:", error);
    throw new Error('Failed to fetch community');
  } finally {
    if (conn) conn.end();
  }
};

const createCommunity = async (communityData) => {
  const { name, description, privacy, icon_url, banner_url, theme_color, creator_id } = communityData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Include all fields in the insert
    await conn.query(
      `INSERT INTO community (
        id, name, description, privacy, icon_url, banner_url, theme_color
      ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        id, 
        name, 
        description, 
        privacy || 'public',
        icon_url || null,
        banner_url || null,
        theme_color || null
      ]
    );
    
    // Create default settings for the community
    await conn.query(
      `INSERT INTO community_setting (
        community_id, allow_post_images, allow_post_links, allow_post_videos,
        allow_polls, require_post_flair, show_in_discovery,
        join_method, content_filter_level
      ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
      [id]
    );
    
    // Log activity if creator_id is provided
    if (creator_id) {
      const activityId = uuidv4();
      await conn.query(
        `INSERT INTO activity (
          id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
        ) VALUES (
          ?, ?, 
          (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
          (SELECT id FROM action WHERE name = 'CREATE'),
          ?, 'community', NOW()
        )`,
        [activityId, creator_id, id]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
    return newCommunity;
  } catch (error) {
    console.error("Error creating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create community');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunity = async (communityId, communityData, userId) => {
  const { name, description, privacy, icon_url, banner_url, theme_color } = communityData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (name !== undefined) {
      updates.push("name = ?");
      values.push(name);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (privacy !== undefined) {
      updates.push("privacy = ?");
      values.push(privacy);
    }
    
    if (icon_url !== undefined) {
      updates.push("icon_url = ?");
      values.push(icon_url);
    }
    
    if (banner_url !== undefined) {
      updates.push("banner_url = ?");
      values.push(banner_url);
    }
    
    if (theme_color !== undefined) {
      updates.push("theme_color = ?");
      values.push(theme_color);
    }
    
    if (updates.length === 0) {
      // No fields to update
      return await getCommunity(communityId);
    }
    
    // Add the ID to the values array
    values.push(communityId);
    
    await conn.query(
      `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return await getCommunity(communityId);
  } catch (error) {
    console.error("Error updating community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunity = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction to ensure all related data is deleted
    await conn.beginTransaction();
    
    // Delete community settings
    await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
    
    // Delete community rules
    await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
    
    // Delete community members
    await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
    
    // Delete join requests
    await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
    
    // Log activity before deleting the community
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Delete the community itself
    const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community');
  } finally {
    if (conn) conn.end();
  }
};

// Community Rules operations
const getCommunityRules = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const rules = await conn.query(
      "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
      [communityId]
    );
    return rules;
  } catch (error) {
    console.error("Error fetching community rules:", error);
    throw new Error('Failed to fetch community rules');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityRule = async (communityId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the highest position to determine the next position
    const [positionResult] = await conn.query(
      "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
      [communityId]
    );
    const nextPosition = (positionResult.maxPosition || 0) + 1;
    
    await conn.query(
      "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
      [id, communityId, title, description, position || nextPosition]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [id]
    );
    return newRule;
  } catch (error) {
    console.error("Error adding community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community rule');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityRule = async (ruleId, ruleData, userId) => {
  const { title, description, position } = ruleData;
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Build the update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (title !== undefined) {
      updates.push("title = ?");
      values.push(title);
    }
    
    if (description !== undefined) {
      updates.push("description = ?");
      values.push(description);
    }
    
    if (position !== undefined) {
      updates.push("position = ?");
      values.push(position);
    }
    
    if (updates.length === 0) {
      // No fields to update
      const [rule] = await conn.query(
        "SELECT * FROM community_rule WHERE id = ?",
        [ruleId]
      );
      return rule || null;
    }
    
    // Add the ID to the values array
    values.push(ruleId);
    
    await conn.query(
      `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
      values
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_rule', NOW()
      )`,
      [activityId, userId, ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [updatedRule] = await conn.query(
      "SELECT * FROM community_rule WHERE id = ?",
      [ruleId]
    );
    return updatedRule || null;
  } catch (error) {
    console.error("Error updating community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community rule');
  } finally {
    if (conn) conn.end();
  }
};

const deleteCommunityRule = async (ruleId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the rule to log its community_id
    const [rule] = await conn.query(
      "SELECT community_id FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    if (!rule) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_rule', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        ruleId, 
        JSON.stringify({ community_id: rule.community_id })
      ]
    );
    
    // Delete the rule
    const result = await conn.query(
      "DELETE FROM community_rule WHERE id = ?",
      [ruleId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting community rule:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete community rule');
  } finally {
    if (conn) conn.end();
  }
};

// Community Settings operations
const getCommunitySettings = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get settings from the community_setting table
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    // If settings don't exist, create default settings
    if (!settings) {
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
        [communityId]
      );
      
      const [newSettings] = await conn.query(
        "SELECT * FROM community_setting WHERE community_id = ?",
        [communityId]
      );
      return newSettings;
    }
    
    return settings;
  } catch (error) {
    console.error("Error fetching community settings:", error);
    throw new Error('Failed to fetch community settings');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunitySettings = async (communityId, settingsData, userId) => {
  const { 
    allow_post_images, 
    allow_post_links, 
    allow_post_videos,
    allow_polls,
    require_post_flair,
    show_in_discovery,
    join_method,
    content_filter_level
  } = settingsData;
  
  let conn;
  
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if settings exist
    const [existingSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (!existingSettings) {
      // Create settings if they don't exist
      await conn.query(
        `INSERT INTO community_setting (
          community_id, allow_post_images, allow_post_links, allow_post_videos,
          allow_polls, require_post_flair, show_in_discovery,
          join_method, content_filter_level
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
        [
          communityId,
          allow_post_images !== undefined ? allow_post_images : true,
          allow_post_links !== undefined ? allow_post_links : true,
          allow_post_videos !== undefined ? allow_post_videos : true,
          allow_polls !== undefined ? allow_polls : true,
          require_post_flair !== undefined ? require_post_flair : false,
          show_in_discovery !== undefined ? show_in_discovery : true,
          join_method !== undefined ? join_method : 'auto_approve',
          content_filter_level !== undefined ? content_filter_level : 'none'
        ]
      );
    } else {
      // Build the update query dynamically based on provided fields
      const updates = [];
      const values = [];
      
      if (allow_post_images !== undefined) {
        updates.push("allow_post_images = ?");
        values.push(allow_post_images);
      }
      
      if (allow_post_links !== undefined) {
        updates.push("allow_post_links = ?");
        values.push(allow_post_links);
      }
      
      if (allow_post_videos !== undefined) {
        updates.push("allow_post_videos = ?");
        values.push(allow_post_videos);
      }
      
      if (allow_polls !== undefined) {
        updates.push("allow_polls = ?");
        values.push(allow_polls);
      }
      
      if (require_post_flair !== undefined) {
        updates.push("require_post_flair = ?");
        values.push(require_post_flair);
      }
      
      if (show_in_discovery !== undefined) {
        updates.push("show_in_discovery = ?");
        values.push(show_in_discovery);
      }
      
      if (join_method !== undefined) {
        updates.push("join_method = ?");
        values.push(join_method);
      }
      
      if (content_filter_level !== undefined) {
        updates.push("content_filter_level = ?");
        values.push(content_filter_level);
      }
      
      if (updates.length > 0) {
        // Add the community ID to the values array
        values.push(communityId);
        
        await conn.query(
          `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
          values
        );
      }
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_setting', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated settings
    const [updatedSettings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    return updatedSettings;
  } catch (error) {
    console.error("Error updating community settings:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community settings');
  } finally {
    if (conn) conn.end();
  }
};

// Community Members operations
const getCommunityMembers = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const members = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ?",
      [communityId]
    );
    return members;
  } catch (error) {
    console.error("Error fetching community members:", error);
    throw new Error('Failed to fetch community members');
  } finally {
    if (conn) conn.end();
  }
};

const getCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
};

const addCommunityMember = async (communityId, userId, role = 'member') => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if the member already exists
    const [existingMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    if (existingMember) {
      // If the member already exists, update their role if different
      if (existingMember.role !== role) {
        await conn.query(
          "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
          [role, communityId, userId]
        );
      }
      
      // Commit the transaction
      await conn.commit();
      
      return existingMember;
    }
    
    // Add the new member
    await conn.query(
      "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
      [communityId, userId, role]
    );
    
    // Update user statistics
    await conn.query(
      `UPDATE user_statistic 
       SET communities_joined = communities_joined + 1
       WHERE user_id = ?`,
      [userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        ?, 'community', NOW()
      )`,
      [activityId, userId, communityId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return newMember;
  } catch (error) {
    console.error("Error adding community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to add community member');
  } finally {
    if (conn) conn.end();
  }
};

const updateCommunityMemberRole = async (communityId, userId, role, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Update the member's role
    await conn.query(
      "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
      [role, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_member', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        userId, 
        JSON.stringify({ 
          community_id: communityId,
          user_id: userId,
          new_role: role
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated member
    const [updatedMember] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    return updatedMember || null;
  } catch (error) {
    console.error("Error updating community member role:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update community member role');
  } finally {
    if (conn) conn.end();
  }
};

const removeCommunityMember = async (communityId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Log activity before removing the member
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        ?, 'community', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        communityId, 
        JSON.stringify({ community_id: communityId })
      ]
    );
    
    // Remove the member
    const result = await conn.query(
      "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    
    // Update user statistics
    if (result.affectedRows > 0) {
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = GREATEST(communities_joined - 1, 0)
         WHERE user_id = ?`,
        [userId]
      );
    }
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error removing community member:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to remove community member');
  } finally {
    if (conn) conn.end();
  }
};

// Community Join Request operations
const getJoinRequests = async (communityId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
};

const getJoinRequest = async (requestId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
};

const createJoinRequest = async (communityId, userId) => {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
};

const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestI

================
File: backend/api/communities.js.new.part2
================
const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request || request.status !== 'pending') {
      // Only pending requests can be updated
      await conn.rollback();
      return null;
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
      [status, requestId]
    );
    
    // If approved, add the user as a community member
    if (status === 'approved') {
      await conn.query(
        "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, 'member') " +
        "ON DUPLICATE KEY UPDATE role = 'member'",
        [request.community_id, request.user_id]
      );
      
      // Update user statistics
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = communities_joined + 1
         WHERE user_id = ?`,
        [request.user_id]
      );
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id,
          status: status
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest || null;
  } catch (error) {
    console.error("Error updating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request');
  } finally {
    if (conn) conn.end();
  }
};

const deleteJoinRequest = async (requestId, userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the request to log its details
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Delete the request
    const result = await conn.query(
      "DELETE FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete join request');
  } finally {
    if (conn) conn.end();
  }
};

const getUserJoinRequests = async (userId, status) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE user_id = ?";
    const params = [userId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching user join requests:", error);
    throw new Error('Failed to fetch user join requests');
  } finally {
    if (conn) conn.end();
  }
};

// Enhanced community information
const getCommunityAbout = async (communityId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get the community
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return null;
    }
    
    // Get the member count
    const [memberCountResult] = await conn.query(
      "SELECT COUNT(*) as memberCount FROM community_member WHERE community_id = ?",
      [communityId]
    );
    const memberCount = memberCountResult.memberCount || 0;
    
    // Get the post count
    const [postCountResult] = await conn.query(
      "SELECT COUNT(*) as postCount FROM post WHERE community_id = ?",
      [communityId]
    );
    const postCount = postCountResult.postCount || 0;
    
    // Get the moderators
    const moderators = await conn.query(
      "SELECT user_id FROM community_member WHERE community_id = ? AND role IN ('moderator', 'admin')",
      [communityId]
    );
    const moderatorIds = moderators.map(mod => mod.user_id);
    
    // Return the enhanced community information
    return {
      ...community,
      memberCount,
      postCount,
      moderators: moderatorIds
    };
  } catch (error) {
    console.error("Error fetching community about:", error);
    throw new Error('Failed to fetch community about');
  } finally {
    if (conn) conn.end();
  }
};

const getUserCommunities = async (userId) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get the communities the user is a member of
    const communities = await conn.query(
      `SELECT c.* 
       FROM community c
       JOIN community_member cm ON c.id = cm.community_id
       WHERE cm.user_id = ?`,
      [userId]
    );
    
    return communities;
  } catch (error) {
    console.error("Error fetching user communities:", error);
    throw new Error('Failed to fetch user communities');
  } finally {
    if (conn) conn.end();
  }
};

const searchCommunities = async (searchTerm) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Search for communities by name or description
    const communities = await conn.query(
      `SELECT * FROM community 
       WHERE name LIKE ? OR description LIKE ?`,
      [`%${searchTerm}%`, `%${searchTerm}%`]
    );
    
    return communities;
  } catch (error) {
    console.error("Error searching communities:", error);
    throw new Error('Failed to search communities');
  } finally {
    if (conn) conn.end();
  }
};

// Export all functions
module.exports = {
  getCommunities,
  getCommunity,
  createCommunity,
  updateCommunity,
  deleteCommunity,
  getCommunityRules,
  addCommunityRule,
  updateCommunityRule,
  deleteCommunityRule,
  getCommunitySettings,
  updateCommunitySettings,
  getCommunityMembers,
  getCommunityMember,
  addCommunityMember,
  updateCommunityMemberRole,
  removeCommunityMember,
  getJoinRequests,
  getJoinRequest,
  createJoinRequest,
  updateJoinRequestStatus,
  deleteJoinRequest,
  getUserJoinRequests,
  getCommunityAbout,
  getUserCommunities,
  searchCommunities
};

================
File: backend/api/communities.ts
================
export interface Community {
    created_at: Date;
    updated_at: Date;
export interface CommunityInput {
export interface CommunityRule {
export interface CommunityRuleInput {
export interface CommunitySettings {
export interface CommunitySettingsInput {
export interface CommunityMember {
    joined_at: Date;
export interface JoinRequest {
    requested_at: Date;
export async function getCommunities(): Promise<Community[]> {
        throw new Error('Failed to fetch communities');
export async function getCommunity(communityId: string): Promise<Community | null> {
        throw new Error('Failed to fetch community');
export async function createCommunity(communityData: CommunityInput): Promise<Community> {
        throw new Error('Failed to create community');
export async function updateCommunity(communityId: string, communityData: Partial<CommunityInput>, userId: string): Promise<Community | null> {
        throw new Error('Failed to update community');
export async function deleteCommunity(communityId: string, userId: string): Promise<boolean> {
        throw new Error('Failed to delete community');
export async function getCommunityRules(communityId: string): Promise<CommunityRule[]> {
        throw new Error('Failed to fetch community rules');
export async function addCommunityRule(communityId: string, ruleData: CommunityRuleInput, userId: string): Promise<CommunityRule> {
        throw new Error('Failed to add community rule');
export async function updateCommunityRule(ruleId: string, ruleData: Partial<CommunityRuleInput>, userId: string): Promise<CommunityRule | null> {
        throw new Error('Failed to update community rule');
export async function deleteCommunityRule(ruleId: string, userId: string): Promise<boolean> {
        throw new Error('Failed to delete community rule');
export async function getCommunitySettings(communityId: string): Promise<CommunitySettings | null> {
        throw new Error('Failed to fetch community settings');
export async function updateCommunitySettings(communityId: string, settingsData: CommunitySettingsInput, userId: string): Promise<CommunitySettings | null> {
        throw new Error('Failed to update community settings');
export async function getCommunityMembers(communityId: string): Promise<CommunityMember[]> {
        throw new Error('Failed to fetch community members');
export async function addCommunityMember(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin' = 'member'): Promise<CommunityMember> {
            joined_at: new Date()
        throw new Error('Failed to add community member');
export async function updateCommunityMemberRole(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin', updatedBy: string): Promise<CommunityMember | null> {
        throw new Error('Failed to update community member role');
export async function removeCommunityMember(communityId: string, userId: string): Promise<boolean> {
        throw new Error('Failed to remove community member');
export async function getCommunityMember(communityId: string, userId: string): Promise<CommunityMember | null> {
        throw new Error('Failed to fetch community member');
export async function getJoinRequests(communityId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
        throw new Error('Failed to fetch join requests');
export async function createJoinRequest(communityId: string, userId: string): Promise<JoinRequest> {
            throw new Error('User is already a member of this community');
            throw new Error('Join request already exists');
export async function updateJoinRequest(requestId: string, status: 'approved' | 'rejected', moderatorId: string): Promise<JoinRequest | null> {
        throw new Error('Failed to update join request');
export async function getCommunityAbout(communityId: string): Promise<any | null> {
        const creationDate = new Date(community.created_at);
        throw new Error('Failed to fetch community about');
export async function getUserCommunities(userId: string): Promise<Community[]> {
        throw new Error('Failed to fetch user communities');
export async function searchCommunities(query: string): Promise<Community[]> {
        throw new Error('Failed to search communities');

================
File: backend/api/communities.ts.new
================
// backend/api/communities.ts
import { v4 as uuidv4 } from 'uuid';
import mariadb from 'mariadb';
import dotenv from 'dotenv';

dotenv.config();

const pool = mariadb.createPool({
    host: process.env.DB_HOST,
    port: Number(process.env.DB_PORT),
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    connectionLimit: 5
});

export interface Community {
    id: string;
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityInput {
    name: string;
    description: string;
    privacy?: 'public' | 'private';
    icon_url?: string;
    banner_url?: string;
    theme_color?: string;
    creator_id?: string;
}

export interface CommunityRule {
    id: string;
    community_id: string;
    title: string;
    description: string;
    position: number;
    created_at: Date;
    updated_at: Date;
}

export interface CommunityRuleInput {
    title: string;
    description: string;
    position?: number;
}

export interface CommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    allow_post_videos: boolean;
    allow_polls: boolean;
    require_post_flair: boolean;
    show_in_discovery: boolean;
    join_method: 'auto_approve' | 'requires_approval' | 'invite_only';
    content_filter_level: 'none' | 'low' | 'medium' | 'high';
    updated_at: Date;
}

export interface CommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    allow_post_videos?: boolean;
    allow_polls?: boolean;
    require_post_flair?: boolean;
    show_in_discovery?: boolean;
    join_method?: 'auto_approve' | 'requires_approval' | 'invite_only';
    content_filter_level?: 'none' | 'low' | 'medium' | 'high';
}

export interface CommunityMember {
    community_id: string;
    user_id: string;
    role: 'member' | 'moderator' | 'admin';
    joined_at: Date;
}

export interface JoinRequest {
    id: string;
    community_id: string;
    user_id: string;
    status: 'pending' | 'approved' | 'rejected';
    requested_at: Date;
    updated_at: Date;
}

// Community CRUD operations
export async function getCommunities(): Promise<Community[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const communities = await conn.query("SELECT * FROM community");
        return communities;
    } catch (error) {
        console.error("Error fetching communities:", error);
        throw new Error('Failed to fetch communities');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunity(communityId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query("SELECT * FROM community WHERE id = ?", [communityId]);
        return community || null;
    } catch (error) {
        console.error("Error fetching community:", error);
        throw new Error('Failed to fetch community');
    } finally {
        if (conn) conn.end();
    }
}

export async function createCommunity(communityData: CommunityInput): Promise<Community> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Include all fields in the insert
        await conn.query(
            `INSERT INTO community (
                id, name, description, privacy, icon_url, banner_url, theme_color
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [
                id, 
                communityData.name, 
                communityData.description, 
                communityData.privacy || 'public',
                communityData.icon_url || null,
                communityData.banner_url || null,
                communityData.theme_color || null
            ]
        );
        
        // Create default settings for the community
        await conn.query(
            `INSERT INTO community_setting (
                community_id, allow_post_images, allow_post_links, allow_post_videos,
                allow_polls, require_post_flair, show_in_discovery,
                join_method, content_filter_level
            ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
            [id]
        );
        
        // Log activity if creator_id is provided
        if (communityData.creator_id) {
            const activityId = uuidv4();
            await conn.query(
                `INSERT INTO activity (
                    id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
                ) VALUES (
                    ?, ?, 
                    (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                    (SELECT id FROM action WHERE name = 'CREATE'),
                    ?, 'community', NOW()
                )`,
                [activityId, communityData.creator_id, id]
            );
        }
        
        // Commit the transaction
        await conn.commit();
        
        const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
        return newCommunity;
    } catch (error) {
        console.error("Error creating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to create community');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunity(communityId: string, communityData: Partial<CommunityInput>, userId: string): Promise<Community | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (communityData.name !== undefined) {
            updates.push("name = ?");
            values.push(communityData.name);
        }
        
        if (communityData.description !== undefined) {
            updates.push("description = ?");
            values.push(communityData.description);
        }
        
        if (communityData.privacy !== undefined) {
            updates.push("privacy = ?");
            values.push(communityData.privacy);
        }
        
        if (communityData.icon_url !== undefined) {
            updates.push("icon_url = ?");
            values.push(communityData.icon_url);
        }
        
        if (communityData.banner_url !== undefined) {
            updates.push("banner_url = ?");
            values.push(communityData.banner_url);
        }
        
        if (communityData.theme_color !== undefined) {
            updates.push("theme_color = ?");
            values.push(communityData.theme_color);
        }
        
        if (updates.length === 0) {
            // No fields to update
            return await getCommunity(communityId);
        }
        
        // Add the ID to the values array
        values.push(communityId);
        
        await conn.query(
            `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return await getCommunity(communityId);
    } catch (error) {
        console.error("Error updating community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunity(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction to ensure all related data is deleted
        await conn.beginTransaction();
        
        // Delete community settings
        await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
        
        // Delete community rules
        await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
        
        // Delete community members
        await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
        
        // Delete join requests
        await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
        
        // Log activity before deleting the community
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Delete the community itself
        const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community');
    } finally {
        if (conn) conn.end();
    }
}

// Community Rules operations
export async function getCommunityRules(communityId: string): Promise<CommunityRule[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const rules = await conn.query(
            "SELECT * FROM community_rule WHERE community_id = ? ORDER BY position ASC",
            [communityId]
        );
        return rules;
    } catch (error) {
        console.error("Error fetching community rules:", error);
        throw new Error('Failed to fetch community rules');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityRule(communityId: string, ruleData: CommunityRuleInput, userId: string): Promise<CommunityRule> {
    let conn;
    try {
        const id = uuidv4();
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the highest position to determine the next position
        const [positionResult] = await conn.query(
            "SELECT MAX(position) as maxPosition FROM community_rule WHERE community_id = ?",
            [communityId]
        );
        const nextPosition = (positionResult.maxPosition || 0) + 1;
        
        await conn.query(
            "INSERT INTO community_rule (id, community_id, title, description, position) VALUES (?, ?, ?, ?, ?)",
            [id, communityId, ruleData.title, ruleData.description, ruleData.position || nextPosition]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'CREATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, id]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [id]
        );
        return newRule;
    } catch (error) {
        console.error("Error adding community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityRule(ruleId: string, ruleData: Partial<CommunityRuleInput>, userId: string): Promise<CommunityRule | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Build the update query dynamically based on provided fields
        const updates: string[] = [];
        const values: any[] = [];
        
        if (ruleData.title !== undefined) {
            updates.push("title = ?");
            values.push(ruleData.title);
        }
        
        if (ruleData.description !== undefined) {
            updates.push("description = ?");
            values.push(ruleData.description);
        }
        
        if (ruleData.position !== undefined) {
            updates.push("position = ?");
            values.push(ruleData.position);
        }
        
        if (updates.length === 0) {
            // No fields to update
            const [rule] = await conn.query(
                "SELECT * FROM community_rule WHERE id = ?",
                [ruleId]
            );
            return rule || null;
        }
        
        // Add the ID to the values array
        values.push(ruleId);
        
        await conn.query(
            `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
            values
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_rule', NOW()
            )`,
            [activityId, userId, ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [updatedRule] = await conn.query(
            "SELECT * FROM community_rule WHERE id = ?",
            [ruleId]
        );
        return updatedRule || null;
    } catch (error) {
        console.error("Error updating community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community rule');
    } finally {
        if (conn) conn.end();
    }
}

export async function deleteCommunityRule(ruleId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Get the rule to log its community_id
        const [rule] = await conn.query(
            "SELECT community_id FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        if (!rule) {
            return false;
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_RULE'),
                (SELECT id FROM action WHERE name = 'DELETE'),
                ?, 'community_rule', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                ruleId, 
                JSON.stringify({ community_id: rule.community_id })
            ]
        );
        
        // Delete the rule
        const result = await conn.query(
            "DELETE FROM community_rule WHERE id = ?",
            [ruleId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error deleting community rule:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to delete community rule');
    } finally {
        if (conn) conn.end();
    }
}

// Community Settings operations
export async function getCommunitySettings(communityId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get settings from the community_setting table
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        // If settings don't exist, create default settings
        if (!settings) {
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, allow_post_videos,
                    allow_polls, require_post_flair, show_in_discovery,
                    join_method, content_filter_level
                ) VALUES (?, TRUE, TRUE, TRUE, TRUE, FALSE, TRUE, 'auto_approve', 'none')`,
                [communityId]
            );
            
            const [newSettings] = await conn.query(
                "SELECT * FROM community_setting WHERE community_id = ?",
                [communityId]
            );
            return newSettings;
        }
        
        return settings;
    } catch (error) {
        console.error("Error fetching community settings:", error);
        throw new Error('Failed to fetch community settings');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunitySettings(communityId: string, settingsData: CommunitySettingsInput, userId: string): Promise<CommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create settings if they don't exist
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, allow_post_images, allow_post_links, allow_post_videos,
                    allow_polls, require_post_flair, show_in_discovery,
                    join_method, content_filter_level
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    settingsData.allow_post_images !== undefined ? settingsData.allow_post_images : true,
                    settingsData.allow_post_links !== undefined ? settingsData.allow_post_links : true,
                    settingsData.allow_post_videos !== undefined ? settingsData.allow_post_videos : true,
                    settingsData.allow_polls !== undefined ? settingsData.allow_polls : true,
                    settingsData.require_post_flair !== undefined ? settingsData.require_post_flair : false,
                    settingsData.show_in_discovery !== undefined ? settingsData.show_in_discovery : true,
                    settingsData.join_method !== undefined ? settingsData.join_method : 'auto_approve',
                    settingsData.content_filter_level !== undefined ? settingsData.content_filter_level : 'none'
                ]
            );
        } else {
            // Build the update query dynamically based on provided fields
            const updates: string[] = [];
            const values: any[] = [];
            
            if (settingsData.allow_post_images !== undefined) {
                updates.push("allow_post_images = ?");
                values.push(settingsData.allow_post_images);
            }
            
            if (settingsData.allow_post_links !== undefined) {
                updates.push("allow_post_links = ?");
                values.push(settingsData.allow_post_links);
            }
            
            if (settingsData.allow_post_videos !== undefined) {
                updates.push("allow_post_videos = ?");
                values.push(settingsData.allow_post_videos);
            }
            
            if (settingsData.allow_polls !== undefined) {
                updates.push("allow_polls = ?");
                values.push(settingsData.allow_polls);
            }
            
            if (settingsData.require_post_flair !== undefined) {
                updates.push("require_post_flair = ?");
                values.push(settingsData.require_post_flair);
            }
            
            if (settingsData.show_in_discovery !== undefined) {
                updates.push("show_in_discovery = ?");
                values.push(settingsData.show_in_discovery);
            }
            
            if (settingsData.join_method !== undefined) {
                updates.push("join_method = ?");
                values.push(settingsData.join_method);
            }
            
            if (settingsData.content_filter_level !== undefined) {
                updates.push("content_filter_level = ?");
                values.push(settingsData.content_filter_level);
            }
            
            if (updates.length > 0) {
                // Add the community ID to the values array
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_SETTING'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_setting', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated settings
        const [updatedSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        return updatedSettings;
    } catch (error) {
        console.error("Error updating community settings:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community settings');
    } finally {
        if (conn) conn.end();
    }
}

// Community Members operations
export async function getCommunityMembers(communityId: string): Promise<CommunityMember[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        const members = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ?",
            [communityId]
        );
        return members;
    } catch (error) {
        console.error("Error fetching community members:", error);
        throw new Error('Failed to fetch community members');
    } finally {
        if (conn) conn.end();
    }
}

export async function addCommunityMember(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin' = 'member'): Promise<CommunityMember> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Check if the member already exists
        const [existingMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingMember) {
            // If the member already exists, update their role if different
            if (existingMember.role !== role) {
                await conn.query(
                    "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
                    [role, communityId, userId]
                );
            }
            
            // Commit the transaction
            await conn.commit();
            
            return existingMember;
        }
        
        // Add the new member
        await conn.query(
            "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, ?)",
            [communityId, userId, role]
        );
        
        // Update user statistics
        await conn.query(
            `UPDATE user_statistic 
             SET communities_joined = communities_joined + 1
             WHERE user_id = ?`,
            [userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'JOIN'),
                ?, 'community', NOW()
            )`,
            [activityId, userId, communityId]
        );
        
        // Commit the transaction
        await conn.commit();
        
        const [newMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        return newMember;
    } catch (error) {
        console.error("Error adding community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to add community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function updateCommunityMemberRole(communityId: string, userId: string, role: 'member' | 'moderator' | 'admin', updatedBy: string): Promise<CommunityMember | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Update the member's role
        await conn.query(
            "UPDATE community_member SET role = ? WHERE community_id = ? AND user_id = ?",
            [role, communityId, userId]
        );
        
        // Log activity
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY_MEMBER'),
                (SELECT id FROM action WHERE name = 'UPDATE'),
                ?, 'community_member', ?, NOW()
            )`,
            [
                activityId, 
                updatedBy, 
                userId, 
                JSON.stringify({ 
                    community_id: communityId,
                    user_id: userId,
                    new_role: role
                })
            ]
        );
        
        // Commit the transaction
        await conn.commit();
        
        // Return the updated member
        const [updatedMember] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        return updatedMember || null;
    } catch (error) {
        console.error("Error updating community member role:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to update community member role');
    } finally {
        if (conn) conn.end();
    }
}

export async function removeCommunityMember(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Start a transaction
        await conn.beginTransaction();
        
        // Log activity before removing the member
        const activityId = uuidv4();
        await conn.query(
            `INSERT INTO activity (
                id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
            ) VALUES (
                ?, ?, 
                (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
                (SELECT id FROM action WHERE name = 'LEAVE'),
                ?, 'community', ?, NOW()
            )`,
            [
                activityId, 
                userId, 
                communityId, 
                JSON.stringify({ community_id: communityId })
            ]
        );
        
        // Remove the member
        const result = await conn.query(
            "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Update user statistics
        if (result.affectedRows > 0) {
            await conn.query(
                `UPDATE user_statistic 
                 SET communities_joined = GREATEST(communities_joined - 1, 0)
                 WHERE user_id = ?`,
                [userId]
            );
        }
        
        // Commit the transaction
        await conn.commit();
        
        return result.affectedRows > 0;
    } catch (error) {
        console.error("Error removing community member:", error);
        if (conn) {
            await conn.rollback();
        }
        throw new Error('Failed to remove community member');
    } finally {
        if (conn) conn.end();
    }
}

export async function getCommunityMember(communityId: string, userId: string): Promise<CommunityMember | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
      "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
      [communityId, userId]
    );
    console.log("Query result:", member);
    return member || null;
  } catch (error) {
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
  } finally {
    if (conn) conn.end();
  }
}

// Community Join Request operations
export async function getJoinRequests(communityId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE community_id = ?";
    const params: any[] = [communityId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
  } finally {
    if (conn) conn.end();
  }
}

export async function getJoinRequest(requestId: string): Promise<JoinRequest | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return request || null;
  } catch (error) {
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function createJoinRequest(communityId: string, userId: string): Promise<JoinRequest> {
  let conn;
  try {
    const id = uuidv4();
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Check if a request already exists
    const [existingRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE community_id = ? AND user_id = ? AND status = 'pending'",
      [communityId, userId]
    );
    
    if (existingRequest) {
      // If a pending request already exists, return it
      await conn.commit();
      return existingRequest;
    }
    
    // Create a new join request
    await conn.query(
      "INSERT INTO community_join_request (id, community_id, user_id, status) VALUES (?, ?, ?, 'pending')",
      [id, communityId, userId]
    );
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        ?, 'community_join_request', NOW()
      )`,
      [activityId, userId, id]
    );
    
    // Commit the transaction
    await conn.commit();
    
    const [newRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [id]
    );
    return newRequest;
  } catch (error) {
    console.error("Error creating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to create join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function updateJoinRequestStatus(
  requestId: string, 
  status: 'approved' | 'rejected', 
  updatedBy: string
): Promise<JoinRequest | null> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the current request to check if it's pending
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request || request.status !== 'pending') {
      // Only pending requests can be updated
      await conn.rollback();
      return null;
    }
    
    // Update the request status
    await conn.query(
      "UPDATE community_join_request SET status = ?, updated_at = NOW() WHERE id = ?",
      [status, requestId]
    );
    
    // If approved, add the user as a community member
    if (status === 'approved') {
      await conn.query(
        "INSERT INTO community_member (community_id, user_id, role) VALUES (?, ?, 'member') " +
        "ON DUPLICATE KEY UPDATE role = 'member'",
        [request.community_id, request.user_id]
      );
      
      // Update user statistics
      await conn.query(
        `UPDATE user_statistic 
         SET communities_joined = communities_joined + 1
         WHERE user_id = ?`,
        [request.user_id]
      );
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'UPDATE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        updatedBy, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id,
          status: status
        })
      ]
    );
    
    // Commit the transaction
    await conn.commit();
    
    // Return the updated request
    const [updatedRequest] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    return updatedRequest || null;
  } catch (error) {
    console.error("Error updating join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to update join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function deleteJoinRequest(requestId: string, userId: string): Promise<boolean> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    // Get the request to log its details
    const [request] = await conn.query(
      "SELECT * FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    if (!request) {
      return false;
    }
    
    // Log activity
    const activityId = uuidv4();
    await conn.query(
      `INSERT INTO activity (
        id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata, created_at
      ) VALUES (
        ?, ?, 
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY_JOIN_REQUEST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        ?, 'community_join_request', ?, NOW()
      )`,
      [
        activityId, 
        userId, 
        requestId, 
        JSON.stringify({ 
          community_id: request.community_id,
          user_id: request.user_id
        })
      ]
    );
    
    // Delete the request
    const result = await conn.query(
      "DELETE FROM community_join_request WHERE id = ?",
      [requestId]
    );
    
    // Commit the transaction
    await conn.commit();
    
    return result.affectedRows > 0;
  } catch (error) {
    console.error("Error deleting join request:", error);
    if (conn) {
      await conn.rollback();
    }
    throw new Error('Failed to delete join request');
  } finally {
    if (conn) conn.end();
  }
}

export async function getUserJoinRequests(userId: string, status?: 'pending' | 'approved' | 'rejected'): Promise<JoinRequest[]> {
  let conn;
  try {
    conn = await pool.getConnection();
    
    let query = "SELECT * FROM community_join_request WHERE user_id = ?";
    const params: any[] = [userId];
    
    if (status) {
      query += " AND status = ?";
      params.push(status);
    }
    
    const requests = await conn.query(query, params);
    return requests;
  } catch (error) {
    console.error("Error fetching user join requests:", error);
    throw new Error('Failed to fetch user join requests');
  } finally {
    if (conn) conn.end();
  }
}

================
File: backend/api/community_fix.js
================
const filePath = path.join(__dirname, 'communities.js');
fs.readFile(filePath, 'utf8', (err, data) => {
    console.error(`Error reading the file: ${err}`);
  if (!regex.test(data)) {
    console.error('Could not find getCommunityAbout function in the file');
  const updatedContent = data.replace(regex, patchedFunction);
  fs.writeFile(filePath, updatedContent, 'utf8', (err) => {
      console.error(`Error writing to the file: ${err}`);
    console.log('Successfully patched communities.js');
console.log('Attempting to patch communities.js file...');

================
File: backend/api/community/community-core.js
================
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
const getCommunities = async () => {
    conn = await pool.getConnection();
    const communities = await conn.query("SELECT * FROM community");
    console.error("Error fetching communities:", error);
    throw new Error('Failed to fetch communities');
    if (conn) conn.end();
const getCommunity = async (communityId) => {
    const [community] = await conn.query(
    console.error("Error fetching community:", error);
    throw new Error('Failed to fetch community');
const createCommunity = async (communityData) => {
    const id = uuidv4();
    await conn.beginTransaction();
    await conn.query(
      const activityId = uuidv4();
    await conn.commit();
    const [newCommunity] = await conn.query("SELECT * FROM community WHERE id = ?", [id]);
    console.error("Error creating community:", error);
      await conn.rollback();
    throw new Error('Failed to create community');
const updateCommunity = async (communityId, communityData, userId) => {
      updates.push("name = ?");
      values.push(name);
      updates.push("description = ?");
      values.push(description);
      updates.push("privacy = ?");
      values.push(privacy);
      updates.push("icon_url = ?");
      values.push(icon_url);
      updates.push("banner_url = ?");
      values.push(banner_url);
      updates.push("theme_color = ?");
      values.push(theme_color);
      return await getCommunity(communityId);
    values.push(communityId);
      `UPDATE community SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
    console.error("Error updating community:", error);
    throw new Error('Failed to update community');
const deleteCommunity = async (communityId, userId) => {
    await conn.query("DELETE FROM community_setting WHERE community_id = ?", [communityId]);
    await conn.query("DELETE FROM community_rule WHERE community_id = ?", [communityId]);
    await conn.query("DELETE FROM community_member WHERE community_id = ?", [communityId]);
    await conn.query("DELETE FROM community_join_request WHERE community_id = ?", [communityId]);
        JSON.stringify({ community_id: communityId })
    const result = await conn.query("DELETE FROM community WHERE id = ?", [communityId]);
    console.error("Error deleting community:", error);
    throw new Error('Failed to delete community');

================
File: backend/api/community/community-members.js
================
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
const getCommunityMembers = async (communityId) => {
    conn = await pool.getConnection();
    const members = await conn.query(
    console.error("Error fetching community members:", error);
    throw new Error('Failed to fetch community members');
    if (conn) conn.end();
const getCommunityMember = async (communityId, userId) => {
    console.log(`Fetching community member: communityId=${communityId}, userId=${userId}`);
    const [member] = await conn.query(
    console.log("Query result:", member);
    console.error("Error fetching community member:", error);
    throw new Error('Failed to fetch community member');
const addCommunityMember = async (communityId, userId, role = 'member') => {
    await conn.beginTransaction();
    const [existingMember] = await conn.query(
        await conn.query(
      await conn.commit();
    const activityId = uuidv4();
    const [newMember] = await conn.query(
    console.error("Error adding community member:", error);
      await conn.rollback();
    throw new Error('Failed to add community member');
const updateCommunityMemberRole = async (communityId, userId, role, updatedBy) => {
        JSON.stringify({ 
    const [updatedMember] = await conn.query(
    console.error("Error updating community member role:", error);
    throw new Error('Failed to update community member role');
const removeCommunityMember = async (communityId, userId) => {
        JSON.stringify({ community_id: communityId })
    const result = await conn.query(
    console.error("Error removing community member:", error);
    throw new Error('Failed to remove community member');

================
File: backend/api/community/community-requests.js
================
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
const getJoinRequests = async (communityId, status) => {
    conn = await pool.getConnection();
      params.push(status);
    const requests = await conn.query(query, params);
    console.error("Error fetching join requests:", error);
    throw new Error('Failed to fetch join requests');
    if (conn) conn.end();
const getJoinRequest = async (requestId) => {
    const [request] = await conn.query(
    console.error("Error fetching join request:", error);
    throw new Error('Failed to fetch join request');
const createJoinRequest = async (communityId, userId) => {
    const id = uuidv4();
    await conn.beginTransaction();
    const [existingRequest] = await conn.query(
      await conn.commit();
    await conn.query(
    const activityId = uuidv4();
    const [newRequest] = await conn.query(
    console.error("Error creating join request:", error);
      await conn.rollback();
    throw new Error('Failed to create join request');
const updateJoinRequestStatus = async (requestId, status, updatedBy) => {
      throw new Error('Join request not found');
      throw new Error('Join request has already been processed');
      await addCommunityMember(request.community_id, request.user_id, 'member');
        JSON.stringify({ 
    const [updatedRequest] = await conn.query(
    console.error("Error updating join request status:", error);
    throw new Error('Failed to update join request status: ' + error.message);

================
File: backend/api/community/community-rules.js
================
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
const getCommunityRules = async (communityId) => {
    conn = await pool.getConnection();
    const rules = await conn.query(
    console.error("Error fetching community rules:", error);
    throw new Error('Failed to fetch community rules');
    if (conn) conn.end();
const addCommunityRule = async (communityId, ruleData, userId) => {
    const id = uuidv4();
    await conn.beginTransaction();
    const [positionResult] = await conn.query(
    await conn.query(
    const activityId = uuidv4();
    await conn.commit();
    const [newRule] = await conn.query(
    console.error("Error adding community rule:", error);
      await conn.rollback();
    throw new Error('Failed to add community rule');
const updateCommunityRule = async (ruleId, ruleData, userId) => {
      updates.push("title = ?");
      values.push(title);
      updates.push("description = ?");
      values.push(description);
      updates.push("position = ?");
      values.push(position);
      const [rule] = await conn.query(
    values.push(ruleId);
      `UPDATE community_rule SET ${updates.join(", ")}, updated_at = NOW() WHERE id = ?`,
    const [updatedRule] = await conn.query(
    console.error("Error updating community rule:", error);
    throw new Error('Failed to update community rule');
const deleteCommunityRule = async (ruleId, userId) => {
        JSON.stringify({ community_id: rule.community_id })
    const result = await conn.query(
    console.error("Error deleting community rule:", error);
    throw new Error('Failed to delete community rule');

================
File: backend/api/community/community-search.js
================
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
const searchCommunities = async (searchTerm, limit = 20, offset = 0) => {
    conn = await pool.getConnection();
    const communities = await conn.query(
    console.error("Error searching communities:", error);
    throw new Error('Failed to search communities');
    if (conn) conn.end();
const getDiscoverableCommunities = async (limit = 20, offset = 0) => {
    console.error("Error fetching discoverable communities:", error);
    throw new Error('Failed to fetch discoverable communities');
const getTrendingCommunities = async (limit = 10) => {
    console.error("Error fetching trending communities:", error);
    throw new Error('Failed to fetch trending communities');
const getRecommendedCommunities = async (userId, limit = 10) => {
    console.error("Error fetching recommended communities:", error);
    throw new Error('Failed to fetch recommended communities');

================
File: backend/api/community/community-settings.js
================
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
const getCommunitySettings = async (communityId) => {
    conn = await pool.getConnection();
    const [settings] = await conn.query(
      await conn.query(
      const [newSettings] = await conn.query(
    console.error("Error fetching community settings:", error);
    throw new Error('Failed to fetch community settings');
    if (conn) conn.end();
const updateCommunitySettings = async (communityId, settingsData, userId) => {
    await conn.beginTransaction();
    const [existingSettings] = await conn.query(
        updates.push("allow_post_images = ?");
        values.push(allow_post_images);
        updates.push("allow_post_links = ?");
        values.push(allow_post_links);
        updates.push("allow_post_videos = ?");
        values.push(allow_post_videos);
        updates.push("allow_polls = ?");
        values.push(allow_polls);
        updates.push("require_post_flair = ?");
        values.push(require_post_flair);
        updates.push("show_in_discovery = ?");
        values.push(show_in_discovery);
        updates.push("join_method = ?");
        values.push(join_method);
        updates.push("content_filter_level = ?");
        values.push(content_filter_level);
        values.push(communityId);
          `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
    const activityId = uuidv4();
    await conn.commit();
    const [updatedSettings] = await conn.query(
    console.error("Error updating community settings:", error);
      await conn.rollback();
    throw new Error('Failed to update community settings');

================
File: backend/api/community/index.js
================


================
File: backend/api/community/README.md
================
# Community API Module

This directory contains the refactored Community API module, which has been split into smaller, more maintainable files.

## Module Structure

- `index.js` - Main entry point that re-exports all functions
- `community-core.js` - Basic CRUD operations for communities
- `community-rules.js` - Community rule management
- `community-settings.js` - Community settings operations
- `community-members.js` - Community member management
- `community-requests.js` - Join request handling
- `community-search.js` - Search and discovery functions

## Usage

### Importing the entire module

```javascript
const communityApi = require('./community');

// Use any function from the module
const communities = await communityApi.getCommunities();
const community = await communityApi.getCommunity(communityId);
```

### Importing specific functions

```javascript
const { getCommunity, createCommunity } = require('./community');

// Use the imported functions
const community = await getCommunity(communityId);
const newCommunity = await createCommunity(communityData);
```

### Importing from specific submodules

```javascript
// Import only the search functions
const communitySearch = require('./community/community-search');

// Use the search functions
const results = await communitySearch.searchCommunities('gaming');
const trending = await communitySearch.getTrendingCommunities();
```

## Database Schema

This module interacts with the following tables:

- `community` - Core community data
- `community_setting` - Community settings
- `community_rule` - Community rules
- `community_member` - Community membership
- `community_join_request` - Join requests
- `activity` - Activity logging
- `activity_type` - Activity type definitions
- `action` - Action type definitions

## Activity Logging

All operations that modify data include activity logging. The activity logs include:

- User who performed the action
- Type of activity (COMMUNITY, COMMUNITY_RULE, etc.)
- Action performed (CREATE, UPDATE, DELETE, etc.)
- Entity affected
- Timestamp
- Additional metadata where relevant

## Error Handling

All functions include proper error handling and will throw descriptive error messages if operations fail. Transactions are used to ensure data consistency, with automatic rollback on failure.

================
File: backend/api/moderation.ts
================
export interface ModeratorPermission {
    created_at: Date;
    updated_at: Date;
export interface ModeratorPermissionInput {
export interface ExtendedCommunitySettings {
export interface ExtendedCommunitySettingsInput {
export interface PostModeration {
export interface ModerationLog {
export interface BannedUser {
interface ModeratorPermissionRow extends RowDataPacket, ModeratorPermission {}
interface CommunitySettingsRow extends RowDataPacket, ExtendedCommunitySettings {}
interface PostModerationRow extends RowDataPacket, PostModeration {}
interface ModerationLogRow extends RowDataPacket, ModerationLog {}
interface BannedUserRow extends RowDataPacket, BannedUser {}
interface UserRow extends RowDataPacket {
export async function isModerator(userId: string, communityId: string): Promise<boolean> {
export async function hasModeratorPermission(
export async function getModeratorPermissions(
export async function updateModeratorPermissions(
    permissions: ModeratorPermissionInput
            throw new Error('User is not a moderator of this community');
        const now = new Date();
export async function getCommunitySettings(communityId: string): Promise<ExtendedCommunitySettings | null> {
export async function updateCommunitySettings(
    settings: ExtendedCommunitySettingsInput,
export async function getPostModerationStatus(postId: string): Promise<PostModeration | null> {
export async function updatePostModerationStatus(
                    throw new Error("Failed to retrieve updated post moderation status");
                    throw new Error("Failed to retrieve created post moderation status");
export async function logModerationAction(
            throw new Error("Failed to retrieve created moderation log");
export async function getModerationLogs(
export async function banUserFromCommunity(
                throw new Error("Failed to retrieve ban record");
export async function isUserBanned(userId: string, communityId: string): Promise<boolean> {
export async function unbanUserFromCommunity(
                throw new Error('User is not banned from this community');

================
File: backend/api/moderation.ts.new
================
// backend/api/moderation.ts
import { v4 as uuidv4 } from 'uuid';
import pool from '../db/connection.js';

// Types
export interface ModeratorPermission {
    community_id: string;
    user_id: string;
    can_manage_settings: boolean;
    can_manage_members: boolean;
    can_manage_posts: boolean;
    can_manage_comments: boolean;
    created_at: Date;
    updated_at: Date;
}

export interface ModeratorPermissionInput {
    can_manage_settings?: boolean;
    can_manage_members?: boolean;
    can_manage_posts?: boolean;
    can_manage_comments?: boolean;
}

export interface ExtendedCommunitySettings {
    community_id: string;
    allow_post_images: boolean;
    allow_post_links: boolean;
    require_post_approval: boolean;
    restricted_words: string | null;
    custom_theme_color: string | null;
    custom_banner_url: string | null;
    minimum_account_age_days: number;
    minimum_karma_required: number;
    updated_at: Date;
}

export interface ExtendedCommunitySettingsInput {
    allow_post_images?: boolean;
    allow_post_links?: boolean;
    require_post_approval?: boolean;
    restricted_words?: string;
    custom_theme_color?: string;
    custom_banner_url?: string;
    minimum_account_age_days?: number;
    minimum_karma_required?: number;
}

export interface PostModeration {
    post_id: string;
    status: 'pending' | 'approved' | 'rejected';
    moderator_id: string | null;
    reason: string | null;
    moderated_at: Date | null;
    created_at: Date;
}

export interface ModerationLog {
    id: string;
    community_id: string;
    moderator_id: string;
    action_type: string;
    target_id: string | null;
    target_type: string | null;
    reason: string | null;
    created_at: Date;
}

export interface BannedUser {
    community_id: string;
    user_id: string;
    reason: string | null;
    banned_by: string;
    ban_expires_at: Date | null;
    created_at: Date;
}

// Helper function to check if a user has moderator permissions
export async function isUserModerator(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [member] = await conn.query(
            "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return member && (member.role === 'moderator' || member.role === 'admin');
    } catch (error) {
        console.error("Error checking moderator status:", error);
        throw new Error('Failed to check moderator status');
    } finally {
        if (conn) conn.release();
    }
}

// Helper function to check specific moderator permissions
export async function hasModeratorPermission(
    communityId: string, 
    userId: string, 
    permission: 'can_manage_settings' | 'can_manage_members' | 'can_manage_posts' | 'can_manage_comments'
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // First check if user is a moderator or admin
        const isModerator = await isUserModerator(communityId, userId);
        if (!isModerator) {
            return false;
        }
        
        // Check for specific permission
        const [permissions] = await conn.query(
            `SELECT ${permission} FROM moderator_permission WHERE community_id = ? AND user_id = ?`,
            [communityId, userId]
        );
        
        // If no specific permissions set, check if admin (admins have all permissions)
        if (!permissions) {
            const [member] = await conn.query(
                "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
            
            return member && member.role === 'admin';
        }
        
        return !!permissions[permission];
    } catch (error) {
        console.error(`Error checking moderator permission (${permission}):`, error);
        throw new Error(`Failed to check moderator permission: ${permission}`);
    } finally {
        if (conn) conn.release();
    }
}

// Moderator Permissions CRUD
export async function getModeratorPermissions(communityId: string, userId: string): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [permissions] = await conn.query(
            "SELECT * FROM moderator_permission WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return permissions || null;
    } catch (error) {
        console.error("Error fetching moderator permissions:", error);
        throw new Error('Failed to fetch moderator permissions');
    } finally {
        if (conn) conn.release();
    }
}

export async function setModeratorPermissions(
    communityId: string, 
    userId: string, 
    permissions: ModeratorPermissionInput
): Promise<ModeratorPermission | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is a moderator or admin
        const [member] = await conn.query(
            "SELECT role FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!member || (member.role !== 'moderator' && member.role !== 'admin')) {
            throw new Error('User is not a moderator or admin of this community');
        }
        
        // Check if permissions already exist
        const [existingPermissions] = await conn.query(
            "SELECT * FROM moderator_permission WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingPermissions) {
            // Update existing permissions
            const updates: string[] = [];
            const values: any[] = [];
            
            if (permissions.can_manage_settings !== undefined) {
                updates.push("can_manage_settings = ?");
                values.push(permissions.can_manage_settings);
            }
            
            if (permissions.can_manage_members !== undefined) {
                updates.push("can_manage_members = ?");
                values.push(permissions.can_manage_members);
            }
            
            if (permissions.can_manage_posts !== undefined) {
                updates.push("can_manage_posts = ?");
                values.push(permissions.can_manage_posts);
            }
            
            if (permissions.can_manage_comments !== undefined) {
                updates.push("can_manage_comments = ?");
                values.push(permissions.can_manage_comments);
            }
            
            if (updates.length > 0) {
                values.push(communityId);
                values.push(userId);
                
                await conn.query(
                    `UPDATE moderator_permission SET ${updates.join(", ")} WHERE community_id = ? AND user_id = ?`,
                    values
                );
            }
        } else {
            // Create new permissions
            await conn.query(
                `INSERT INTO moderator_permission (
                    community_id, 
                    user_id, 
                    can_manage_settings, 
                    can_manage_members, 
                    can_manage_posts, 
                    can_manage_comments
                ) VALUES (?, ?, ?, ?, ?, ?)`,
                [
                    communityId,
                    userId,
                    permissions.can_manage_settings !== undefined ? permissions.can_manage_settings : false,
                    permissions.can_manage_members !== undefined ? permissions.can_manage_members : false,
                    permissions.can_manage_posts !== undefined ? permissions.can_manage_posts : false,
                    permissions.can_manage_comments !== undefined ? permissions.can_manage_comments : false
                ]
            );
        }
        
        // Return the updated permissions
        return await getModeratorPermissions(communityId, userId);
    } catch (error) {
        console.error("Error setting moderator permissions:", error);
        throw new Error('Failed to set moderator permissions');
    } finally {
        if (conn) conn.release();
    }
}

// Enhanced Community Settings CRUD
export async function getEnhancedCommunitySettings(communityId: string): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [settings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!settings) {
            // Create default settings if they don't exist
            await conn.query(
                `INSERT INTO community_setting (
                    community_id, 
                    allow_post_images, 
                    allow_post_links,
                    require_post_approval,
                    minimum_account_age_days,
                    minimum_karma_required
                ) VALUES (?, TRUE, TRUE, FALSE, 0, 0)`,
                [communityId]
            );
            
            const [newSettings] = await conn.query(
                "SELECT * FROM community_setting WHERE community_id = ?",
                [communityId]
            );
            
            return newSettings;
        }
        
        return settings;
    } catch (error) {
        console.error("Error fetching enhanced community settings:", error);
        throw new Error('Failed to fetch enhanced community settings');
    } finally {
        if (conn) conn.release();
    }
}

export async function updateEnhancedCommunitySettings(
    communityId: string, 
    settings: ExtendedCommunitySettingsInput
): Promise<ExtendedCommunitySettings | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if settings exist
        const [existingSettings] = await conn.query(
            "SELECT * FROM community_setting WHERE community_id = ?",
            [communityId]
        );
        
        if (!existingSettings) {
            // Create settings with provided values if they don't exist
            const insertColumns: string[] = ["community_id"];
            const placeholders: string[] = ["?"];
            const values: any[] = [communityId];
            
            // Build dynamic insert query based on provided settings
            Object.entries(settings).forEach(([key, value]) => {
                if (value !== undefined) {
                    insertColumns.push(key);
                    placeholders.push("?");
                    values.push(value);
                }
            });
            
            await conn.query(
                `INSERT INTO community_setting (${insertColumns.join(", ")}) VALUES (${placeholders.join(", ")})`,
                values
            );
        } else {
            // Update existing settings
            const updates: string[] = [];
            const values: any[] = [];
            
            Object.entries(settings).forEach(([key, value]) => {
                if (value !== undefined) {
                    updates.push(`${key} = ?`);
                    values.push(value);
                }
            });
            
            if (updates.length > 0) {
                values.push(communityId);
                
                await conn.query(
                    `UPDATE community_setting SET ${updates.join(", ")}, updated_at = NOW() WHERE community_id = ?`,
                    values
                );
            }
        }
        
        // Return the updated settings
        return await getEnhancedCommunitySettings(communityId);
    } catch (error) {
        console.error("Error updating enhanced community settings:", error);
        throw new Error('Failed to update enhanced community settings');
    } finally {
        if (conn) conn.release();
    }
}

// Post Moderation functions
export async function getPostModerationStatus(postId: string): Promise<PostModeration | null> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const [status] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return status || null;
    } catch (error) {
        console.error("Error fetching post moderation status:", error);
        throw new Error('Failed to fetch post moderation status');
    } finally {
        if (conn) conn.release();
    }
}

export async function addPostToModQueue(postId: string): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if post already in moderation queue
        const [existingModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        if (existingModeration) {
            return existingModeration;
        }
        
        // Add post to moderation queue
        await conn.query(
            "INSERT INTO post_moderation (post_id, status) VALUES (?, 'pending')",
            [postId]
        );
        
        const [newModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return newModeration;
    } catch (error) {
        console.error("Error adding post to moderation queue:", error);
        throw new Error('Failed to add post to moderation queue');
    } finally {
        if (conn) conn.release();
    }
}

export async function moderatePost(
    postId: string, 
    moderatorId: string, 
    action: 'approve' | 'reject', 
    reason?: string
): Promise<PostModeration> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get post information to log the action
        const [post] = await conn.query(
            "SELECT community_id FROM post WHERE id = ?",
            [postId]
        );
        
        if (!post) {
            throw new Error('Post not found');
        }
        
        // Update post moderation status
        await conn.query(
            "UPDATE post_moderation SET status = ?, moderator_id = ?, reason = ?, moderated_at = NOW() WHERE post_id = ?",
            [action === 'approve' ? 'approved' : 'rejected', moderatorId, reason || null, postId]
        );
        
        // Log the moderation action
        await createModerationLog(
            post.community_id,
            moderatorId,
            action === 'approve' ? 'approve_post' : 'reject_post',
            postId,
            'post',
            reason
        );
        
        // Retrieve and return updated moderation status
        const [updatedModeration] = await conn.query(
            "SELECT * FROM post_moderation WHERE post_id = ?",
            [postId]
        );
        
        return updatedModeration;
    } catch (error) {
        console.error("Error moderating post:", error);
        throw new Error('Failed to moderate post');
    } finally {
        if (conn) conn.release();
    }
}

export async function getPendingModQueue(communityId: string): Promise<any[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Get all pending posts for the community
        const pendingPosts = await conn.query(
            `SELECT p.*, pm.status, pm.created_at as queued_at, u.username as author_username
             FROM post p
             JOIN post_moderation pm ON p.id = pm.post_id
             JOIN user u ON p.user_id = u.id
             WHERE p.community_id = ? AND pm.status = 'pending'
             ORDER BY pm.created_at ASC`,
            [communityId]
        );
        
        return pendingPosts;
    } catch (error) {
        console.error("Error fetching pending moderation queue:", error);
        throw new Error('Failed to fetch pending moderation queue');
    } finally {
        if (conn) conn.release();
    }
}

// Moderation Log functions
export async function createModerationLog(
    communityId: string,
    moderatorId: string,
    actionType: string,
    targetId?: string,
    targetType?: string,
    reason?: string
): Promise<ModerationLog> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const id = uuidv4();
        
        await conn.query(
            `INSERT INTO moderation_log (
                id, 
                community_id, 
                moderator_id, 
                action_type, 
                target_id, 
                target_type, 
                reason
            ) VALUES (?, ?, ?, ?, ?, ?, ?)`,
            [id, communityId, moderatorId, actionType, targetId || null, targetType || null, reason || null]
        );
        
        const [log] = await conn.query(
            "SELECT * FROM moderation_log WHERE id = ?",
            [id]
        );
        
        return log;
    } catch (error) {
        console.error("Error creating moderation log:", error);
        throw new Error('Failed to create moderation log');
    } finally {
        if (conn) conn.release();
    }
}

export async function getModerationLogs(communityId: string, limit = 50, offset = 0): Promise<ModerationLog[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const logs = await conn.query(
            `SELECT ml.*, u.username as moderator_username 
             FROM moderation_log ml
             JOIN user u ON ml.moderator_id = u.id
             WHERE ml.community_id = ?
             ORDER BY ml.created_at DESC
             LIMIT ? OFFSET ?`,
            [communityId, limit, offset]
        );
        
        return logs;
    } catch (error) {
        console.error("Error fetching moderation logs:", error);
        throw new Error('Failed to fetch moderation logs');
    } finally {
        if (conn) conn.release();
    }
}

// User banning functions
export async function banUserFromCommunity(
    communityId: string,
    userId: string,
    bannedBy: string,
    reason?: string,
    banDuration?: number // Duration in days, null for permanent
): Promise<BannedUser> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Calculate expiration date if duration provided
        let banExpiresAt = null;
        if (banDuration) {
            const expirationDate = new Date();
            expirationDate.setDate(expirationDate.getDate() + banDuration);
            banExpiresAt = expirationDate;
        }
        
        // Check if user is already banned
        const [existingBan] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (existingBan) {
            // Update existing ban
            await conn.query(
                "UPDATE banned_user SET reason = ?, banned_by = ?, ban_expires_at = ? WHERE community_id = ? AND user_id = ?",
                [reason || null, bannedBy, banExpiresAt, communityId, userId]
            );
        } else {
            // Create new ban
            await conn.query(
                "INSERT INTO banned_user (community_id, user_id, reason, banned_by, ban_expires_at) VALUES (?, ?, ?, ?, ?)",
                [communityId, userId, reason || null, bannedBy, banExpiresAt]
            );
            
            // Remove user from community members if they're a member
            await conn.query(
                "DELETE FROM community_member WHERE community_id = ? AND user_id = ?",
                [communityId, userId]
            );
        }
        
        // Log the ban action
        await createModerationLog(
            communityId,
            bannedBy,
            'ban_user',
            userId,
            'user',
            reason
        );
        
        const [ban] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        return ban;
    } catch (error) {
        console.error("Error banning user from community:", error);
        throw new Error('Failed to ban user from community');
    } finally {
        if (conn) conn.release();
    }
}

export async function unbanUserFromCommunity(
    communityId: string,
    userId: string,
    unbannedBy: string,
    reason?: string
): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check if user is banned
        const [existingBan] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!existingBan) {
            return false; // User wasn't banned
        }
        
        // Remove ban
        await conn.query(
            "DELETE FROM banned_user WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        // Log the unban action
        await createModerationLog(
            communityId,
            unbannedBy,
            'unban_user',
            userId,
            'user',
            reason
        );
        
        return true;
    } catch (error) {
        console.error("Error unbanning user from community:", error);
        throw new Error('Failed to unban user from community');
    } finally {
        if (conn) conn.release();
    }
}

export async function getBannedUsers(communityId: string): Promise<any[]> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        const bannedUsers = await conn.query(
            `SELECT bu.*, 
                    u.username as banned_username, 
                    m.username as moderator_username
             FROM banned_user bu
             JOIN user u ON bu.user_id = u.id
             JOIN user m ON bu.banned_by = m.id
             WHERE bu.community_id = ?
             ORDER BY bu.created_at DESC`,
            [communityId]
        );
        
        return bannedUsers;
    } catch (error) {
        console.error("Error fetching banned users:", error);
        throw new Error('Failed to fetch banned users');
    } finally {
        if (conn) conn.release();
    }
}

export async function isUserBanned(communityId: string, userId: string): Promise<boolean> {
    let conn;
    try {
        conn = await pool.getConnection();
        
        // Check for active bans
        const [ban] = await conn.query(
            "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
            [communityId, userId]
        );
        
        return !!ban;
    } catch (error) {
        console.error("Error checking if user is banned:", error);
        throw new Error('Failed to check if user is banned');
    } finally {
        if (conn) conn.release();
    }
}

================
File: backend/api/posts_enhanced.js
================
dotenv.config();
const pool = mariadb.createPool({
    port: Number(process.env.DB_PORT),
const getCommunityIdFromPost = async (postId) => {
        conn = await pool.getConnection();
        const [post] = await conn.query(
        console.error("Error fetching community ID from post:", error);
        throw new Error('Failed to fetch community ID from post');
        if (conn) conn.release();
const createPostEnhanced = async (req, res) => {
            return res.status(400).json({ message: 'Title, content, and communityId are required' });
        const [community] = await conn.query(
            return res.status(404).json({ message: 'Community not found' });
        await conn.beginTransaction();
            const banned = await isUserBanned(communityId, userId);
                return res.status(403).json({ message: 'You are banned from this community and cannot create posts' });
            const settings = await getEnhancedCommunitySettings(communityId);
            const id = uuidv4();
            const now = new Date().toISOString().slice(0, 19).replace('T', ' ');
            await conn.query(
                await addPostToModQueue(id);
            await conn.commit();
            const [newPost] = await conn.query(`
            res.status(201).json(formattedPost);
            await conn.rollback();
        console.error("Error creating post:", error);
        res.status(500).json({ message: 'Error creating post' });
const getPostsEnhanced = async (req, res) => {
            isModerator = await isUserModerator(communityId, userId);
                posts = await conn.query(query, [communityId, userId]);
                posts = await conn.query(query, [communityId]);
            posts = await conn.query(query);
        let formattedPosts = await Promise.all(posts.map(async (post) => {
                const modStatus = await getPostModerationStatus(post.id);
        res.status(200).json(formattedPosts);
        console.error("Error fetching posts:", error);
        res.status(500).json({ message: 'Error fetching posts' });
const getPostEnhanced = async (req, res) => {
        const [post] = await conn.query(`
            return res.status(404).json({ message: 'Post not found' });
            const settings = await getEnhancedCommunitySettings(post.community_id);
                const modStatus = await getPostModerationStatus(postId);
                    const isModerator = await isUserModerator(post.community_id, userId);
                        return res.status(403).json({ message: 'Post is pending moderator approval' });
                        return res.status(403).json({ message: 'Post has been removed by moderators' });
        res.status(200).json(formattedPost);
        console.error("Error fetching post:", error);
        res.status(500).json({ message: 'Error fetching post' });
const updatePostEnhanced = async (req, res) => {
            const canManagePosts = await hasModeratorPermission(post.community_id, userId, 'can_manage_posts');
                return res.status(403).json({ message: 'You do not have permission to update this post' });
            await createModerationLog(
        const [updatedPost] = await conn.query(`
        console.error("Error updating post:", error);
        res.status(500).json({ message: 'Error updating post' });
const deletePostEnhanced = async (req, res) => {
                return res.status(403).json({ message: 'You do not have permission to delete this post' });
            res.status(204).send();
        console.error("Error deleting post:", error);
        res.status(500).json({ message: 'Error deleting post' });
const getPendingPosts = async (req, res) => {
        const isModerator = await isUserModerator(communityId, userId);
        const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
            return res.status(403).json({ message: 'You do not have permission to view pending posts' });
        const pendingPosts = await conn.query(`
        const formattedPosts = pendingPosts.map(post => ({
        console.error("Error fetching pending posts:", error);
        res.status(500).json({ message: 'Error fetching pending posts' });
const moderatePostAction = async (req, res) => {
            return res.status(400).json({ message: 'Invalid action. Must be "approve" or "reject"' });
            return res.status(403).json({ message: 'You do not have permission to moderate posts' });
        await moderatePost(postId, userId, action, reason);
        res.status(200).json({ 
        console.error("Error moderating post:", error);
        res.status(500).json({ message: 'Error moderating post' });

================
File: backend/api/posts.js
================
const getPosts = async (req, res) => {
    conn = await pool.getConnection();
      queryParams.push(communityId);
    const posts = await conn.query(query, queryParams);
    const formattedPosts = posts.map(post => ({
    res.status(200).json(formattedPosts);
    console.error("Error fetching posts:", error);
    res.status(500).json({ message: 'Error fetching posts' });
    if (conn) conn.release();
const getPost = async (req, res) => {
    const [post] = await conn.query(`
      return res.status(404).json({ message: 'Post not found' });
    res.status(200).json(formattedPost);
    console.error("Error fetching post:", error);
    res.status(500).json({ message: 'Error fetching post' });
const createPost = async (req, res) => {
      return res.status(400).json({ message: 'Title, content, and communityId are required' });
    const [community] = await conn.query(
      return res.status(404).json({ message: 'Community not found' });
    await conn.beginTransaction();
      const id = uuidv4();
      await conn.query(
      const [newPost] = await conn.query(`
      await conn.commit();
      res.status(201).json(formattedPost);
      await conn.rollback();
    console.error("Error creating post:", error);
    res.status(500).json({ message: 'Error creating post' });
const updatePost = async (req, res) => {
    const [post] = await conn.query(
      return res.status(403).json({ message: 'You can only update your own posts' });
      const [updatedPost] = await conn.query(`
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'UPDATE');
          uuidv4(),
          JSON.stringify({
    console.error("Error updating post:", error);
    res.status(500).json({ message: 'Error updating post' });
const deletePost = async (req, res) => {
      const [moderator] = await conn.query(
        return res.status(403).json({ message: 'You can only delete your own posts or posts in communities you moderate' });
      const actionId = await getActionId(conn, 'DELETE');
      res.status(204).send();
    console.error("Error deleting post:", error);
    res.status(500).json({ message: 'Error deleting post' });
const getCommunityPosts = async (req, res) => {
    const posts = await conn.query(`
    console.error("Error fetching community posts:", error);
    res.status(500).json({ message: 'Error fetching community posts' });
const getUserPosts = async (req, res) => {
    const [user] = await conn.query(
      return res.status(404).json({ message: 'User not found' });
    console.error("Error fetching user posts:", error);
    res.status(500).json({ message: 'Error fetching user posts' });
const canPostInCommunity = async (req, res, next) => {
    return next(); // No community specified, allow the post
    const [banned] = await conn.query(
      return res.status(403).json({ message: 'You are banned from this community' });
    const [settings] = await conn.query(
      const [membership] = await conn.query(
        return res.status(403).json({ message: 'You must be a member to post in this community' });
    next();
    console.error("Error checking post permission:", error);
    return res.status(500).json({ message: 'Error checking post permission' });
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
async function getActionId(conn, actionName) {
  const [action] = await conn.query(

================
File: backend/api/posts.js.new
================
// JavaScript version of posts.ts
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Get all posts with user information
const getPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get community filter if provided
    const communityId = req.query.communityId;
    
    // Build the query based on whether a community filter is provided
    let query = `
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
    `;
    
    const queryParams = [];
    
    if (communityId) {
      query += " WHERE p.community_id = ?";
      queryParams.push(communityId);
    }
    
    query += " ORDER BY p.created_at DESC";
    
    const posts = await conn.query(query, queryParams);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching posts:", error);
    res.status(500).json({ message: 'Error fetching posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get a single post with user information
const getPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const [post] = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.id = ?
    `, [req.params.id]);
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    // Format the post for the frontend
    const formattedPost = {
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    };
    
    res.status(200).json(formattedPost);
  } catch (error) {
    console.error("Error fetching post:", error);
    res.status(500).json({ message: 'Error fetching post' });
  } finally {
    if (conn) conn.release();
  }
};

// Create a new post
const createPost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content, communityId } = req.body;
    const userId = req.user.id;
    
    // Validate required fields
    if (!title || !content || !communityId) {
      return res.status(400).json({ message: 'Title, content, and communityId are required' });
    }
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Create the post
      const id = uuidv4();
      
      await conn.query(
        "INSERT INTO post (id, title, content, user_id, community_id) VALUES (?, ?, ?, ?, ?)",
        [id, title, content, userId, communityId]
      );
      
      // Get the created post with user information
      const [newPost] = await conn.query(`
        SELECT p.*, u.username
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [id]);
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: newPost.id,
        title: newPost.title,
        content: newPost.content,
        username: newPost.username || 'Anonymous',
        userId: newPost.user_id,
        communityId: newPost.community_id,
        timestamp: newPost.created_at,
        comments: 0,
        votes: 0
      };
      
      res.status(201).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error creating post:", error);
    res.status(500).json({ message: 'Error creating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Update a post
const updatePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const { title, content } = req.body;
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      return res.status(403).json({ message: 'You can only update your own posts' });
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Update the post
      await conn.query(
        "UPDATE post SET title = ?, content = ? WHERE id = ?",
        [title, content, postId]
      );
      
      // Get the updated post with user information
      const [updatedPost] = await conn.query(`
        SELECT p.*, u.username, 
               (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
               COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
        FROM post p
        LEFT JOIN user u ON p.user_id = u.id
        WHERE p.id = ?
      `, [postId]);
      
      // Log activity
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'UPDATE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: title,
            community_id: post.community_id
          })
        ]
      );
      
      // Commit the transaction
      await conn.commit();
      
      // Format the post for the frontend
      const formattedPost = {
        id: updatedPost.id,
        title: updatedPost.title,
        content: updatedPost.content,
        username: updatedPost.username || 'Anonymous',
        userId: updatedPost.user_id,
        communityId: updatedPost.community_id,
        timestamp: updatedPost.created_at,
        comments: updatedPost.comments || 0,
        votes: updatedPost.votes || 0
      };
      
      res.status(200).json(formattedPost);
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error updating post:", error);
    res.status(500).json({ message: 'Error updating post' });
  } finally {
    if (conn) conn.release();
  }
};

// Delete a post
const deletePost = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const postId = req.params.id;
    const userId = req.user.id;
    
    // Check if post exists and belongs to the user
    const [post] = await conn.query(
      "SELECT * FROM post WHERE id = ?",
      [postId]
    );
    
    if (!post) {
      return res.status(404).json({ message: 'Post not found' });
    }
    
    if (post.user_id !== userId) {
      // Check if user is a moderator of the community
      const [moderator] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
        [post.community_id, userId]
      );
      
      if (!moderator) {
        return res.status(403).json({ message: 'You can only delete your own posts or posts in communities you moderate' });
      }
    }
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Log activity before deleting the post
      const activityTypeId = await getActivityTypeId(conn, 'POST');
      const actionId = await getActionId(conn, 'DELETE');
      
      await conn.query(
        `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
         VALUES (?, ?, ?, ?, ?, ?, ?)`,
        [
          uuidv4(),
          userId,
          activityTypeId,
          actionId,
          postId,
          'post',
          JSON.stringify({
            title: post.title,
            community_id: post.community_id
          })
        ]
      );
      
      // Delete votes associated with the post
      await conn.query(
        "DELETE FROM vote WHERE post_id = ?",
        [postId]
      );
      
      // Delete comments associated with the post
      await conn.query(
        "DELETE FROM comment WHERE post_id = ?",
        [postId]
      );
      
      // Delete the post
      await conn.query(
        "DELETE FROM post WHERE id = ?",
        [postId]
      );
      
      // Commit the transaction
      await conn.commit();
      
      res.status(204).send();
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error("Error deleting post:", error);
    res.status(500).json({ message: 'Error deleting post' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific community
const getCommunityPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const communityId = req.params.communityId;
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // Get posts for the community
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.community_id = ?
      ORDER BY p.created_at DESC
    `, [communityId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching community posts:", error);
    res.status(500).json({ message: 'Error fetching community posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Get posts for a specific user
const getUserPosts = async (req, res) => {
  let conn;
  try {
    conn = await pool.getConnection();
    
    const userId = req.params.userId;
    
    // Check if user exists
    const [user] = await conn.query(
      "SELECT * FROM user WHERE id = ?",
      [userId]
    );
    
    if (!user) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Get posts for the user
    const posts = await conn.query(`
      SELECT p.*, u.username, 
             (SELECT COUNT(*) FROM comment c WHERE c.post_id = p.id) as comments,
             COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes
      FROM post p
      LEFT JOIN user u ON p.user_id = u.id
      WHERE p.user_id = ?
      ORDER BY p.created_at DESC
    `, [userId]);
    
    // Format the posts for the frontend
    const formattedPosts = posts.map(post => ({
      id: post.id,
      title: post.title,
      content: post.content,
      username: post.username || 'Anonymous',
      userId: post.user_id,
      communityId: post.community_id,
      timestamp: post.created_at,
      comments: post.comments || 0,
      votes: post.votes || 0
    }));
    
    res.status(200).json(formattedPosts);
  } catch (error) {
    console.error("Error fetching user posts:", error);
    res.status(500).json({ message: 'Error fetching user posts' });
  } finally {
    if (conn) conn.release();
  }
};

// Check if user can post in a community
const canPostInCommunity = async (req, res, next) => {
  const communityId = req.body.communityId;
  const userId = req.user.id;
  
  if (!communityId) {
    return next(); // No community specified, allow the post
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Check if community exists
    const [community] = await conn.query(
      "SELECT * FROM community WHERE id = ?",
      [communityId]
    );
    
    if (!community) {
      return res.status(404).json({ message: 'Community not found' });
    }
    
    // If community is public, check if user is banned
    const [banned] = await conn.query(
      "SELECT * FROM banned_user WHERE community_id = ? AND user_id = ? AND (ban_expires_at IS NULL OR ban_expires_at > NOW())",
      [communityId, userId]
    );
    
    if (banned) {
      return res.status(403).json({ message: 'You are banned from this community' });
    }
    
    // Check community settings for post approval
    const [settings] = await conn.query(
      "SELECT * FROM community_setting WHERE community_id = ?",
      [communityId]
    );
    
    if (settings && settings.require_post_approval) {
      // Set a flag to indicate that this post needs approval
      req.needsApproval = true;
    }
    
    // If community is private, check if user is a member
    if (community.privacy === 'private') {
      const [membership] = await conn.query(
        "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
        [communityId, userId]
      );
      
      if (!membership) {
        return res.status(403).json({ message: 'You must be a member to post in this community' });
      }
    }
    
    next();
  } catch (error) {
    console.error("Error checking post permission:", error);
    return res.status(500).json({ message: 'Error checking post permission' });
  } finally {
    if (conn) conn.release();
  }
};

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

module.exports = {
  getPosts,
  getPost,
  createPost,
  updatePost,
  deletePost,
  getCommunityPosts,
  getUserPosts,
  canPostInCommunity
};

================
File: backend/api/posts.ts
================
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
export const getPosts = async (req: Request, res: Response) => {
export const getPost = async (req: Request, res: Response) => {
export const createPost = async (req: Request, res: Response) => {
export const updatePost = async (req: Request, res: Response) => {
export const deletePost = async (req: Request, res: Response) => {

================
File: backend/api/users.ts
================
export async function getUserPosts(userId: string) {

================
File: backend/api/votes.js
================
async function voteOnPost(userId, postId, value) {
    throw new Error('Vote value must be 1, -1, or 0');
    conn = await pool.getConnection();
    await conn.beginTransaction();
      const [post] = await conn.query('SELECT * FROM post WHERE id = ?', [postId]);
        throw new Error('Post not found');
      const [existingVote] = await conn.query(
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
          await conn.query(
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', existingVote.value);
          await conn.commit();
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
      await conn.rollback();
    console.error('Error voting on post:', error);
    if (conn) conn.release();
async function voteOnComment(userId, commentId, value) {
      const [comment] = await conn.query('SELECT * FROM comment WHERE id = ?', [commentId]);
        throw new Error('Comment not found');
          await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', existingVote.value);
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
    console.error('Error voting on comment:', error);
async function getUserPostVote(userId, postId) {
    const [vote] = await conn.query(
    console.error('Error getting user post vote:', error);
async function getUserCommentVote(userId, commentId) {
    console.error('Error getting user comment vote:', error);
async function getPostVoteCounts(postId) {
    const [result] = await conn.query(
    console.error('Error getting post vote counts:', error);
async function getCommentVoteCounts(commentId) {
    console.error('Error getting comment vote counts:', error);
async function getUserVotes(userId) {
    const postVotes = await conn.query(
    const commentVotes = await conn.query(
    console.error('Error getting user votes:', error);
function includePostVotesInQuery(baseQuery) {
function includeCommentVotesInQuery(baseQuery) {
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
async function logVoteActivity(conn, userId, activityTypeId, actionId, entityId, entityType, voteValue) {
      uuidv4(),
      JSON.stringify({ value: voteValue })

================
File: backend/api/votes.js.new
================
const { v4: uuidv4 } = require('uuid');
const pool = require('../db/connection.js');

// Vote on a post
async function voteOnPost(userId, postId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the post exists
      const [post] = await conn.query('SELECT * FROM post WHERE id = ?', [postId]);
      if (!post) {
        throw new Error('Post not found');
      }
      
      // Check if the user has already voted on this post
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND post_id = ?',
        [userId, postId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND post_id = ?',
            [userId, postId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND post_id = ?',
          [value, userId, postId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, post_id, value) VALUES (?, ?, ?)',
          [userId, postId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, postId, 'post', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on post:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Vote on a comment
async function voteOnComment(userId, commentId, value) {
  if (value !== 1 && value !== -1 && value !== 0) {
    throw new Error('Vote value must be 1, -1, or 0');
  }
  
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Start a transaction
    await conn.beginTransaction();
    
    try {
      // Check if the comment exists
      const [comment] = await conn.query('SELECT * FROM comment WHERE id = ?', [commentId]);
      if (!comment) {
        throw new Error('Comment not found');
      }
      
      // Check if the user has already voted on this comment
      const [existingVote] = await conn.query(
        'SELECT * FROM vote WHERE user_id = ? AND comment_id = ?',
        [userId, commentId]
      );
      
      // Get activity type and action IDs for logging
      const activityTypeId = await getActivityTypeId(conn, 'VOTE');
      let actionId;
      
      if (value === 0) {
        // If value is 0, remove the vote if it exists
        if (existingVote) {
          await conn.query(
            'DELETE FROM vote WHERE user_id = ? AND comment_id = ?',
            [userId, commentId]
          );
          
          // Log activity for vote removal
          actionId = await getActionId(conn, 'DELETE');
          await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', existingVote.value);
          
          await conn.commit();
          return { message: 'Vote removed' };
        }
        
        await conn.commit();
        return { message: 'No vote to remove' };
      }
      
      if (existingVote) {
        // Update the existing vote
        await conn.query(
          'UPDATE vote SET value = ? WHERE user_id = ? AND comment_id = ?',
          [value, userId, commentId]
        );
        
        // Log activity for vote update
        actionId = await getActionId(conn, 'UPDATE');
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote updated' };
      } else {
        // Insert a new vote
        await conn.query(
          'INSERT INTO vote (user_id, comment_id, value) VALUES (?, ?, ?)',
          [userId, commentId, value]
        );
        
        // Log activity for new vote
        actionId = value === 1 ? 
          await getActionId(conn, 'UPVOTE') : 
          await getActionId(conn, 'DOWNVOTE');
        
        await logVoteActivity(conn, userId, activityTypeId, actionId, commentId, 'comment', value);
        
        await conn.commit();
        return { message: 'Vote added' };
      }
    } catch (error) {
      // Rollback the transaction if anything goes wrong
      await conn.rollback();
      throw error;
    }
  } catch (error) {
    console.error('Error voting on comment:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a post
async function getUserPostVote(userId, postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND post_id = ?',
      [userId, postId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user post vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get user's vote on a comment
async function getUserCommentVote(userId, commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [vote] = await conn.query(
      'SELECT value FROM vote WHERE user_id = ? AND comment_id = ?',
      [userId, commentId]
    );
    
    return vote ? vote.value : 0;
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a post
async function getPostVoteCounts(postId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE post_id = ?`,
      [postId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get vote counts for a comment
async function getCommentVoteCounts(commentId) {
  let conn;
  try {
    conn = await pool.getConnection();
    const [result] = await conn.query(
      `SELECT 
        COUNT(CASE WHEN value = 1 THEN 1 END) as upvotes,
        COUNT(CASE WHEN value = -1 THEN 1 END) as downvotes
      FROM vote 
      WHERE comment_id = ?`,
      [commentId]
    );
    
    const upvotes = result.upvotes || 0;
    const downvotes = result.downvotes || 0;
    
    return {
      upvotes,
      downvotes,
      total: upvotes - downvotes
    };
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Get all votes for a user
async function getUserVotes(userId) {
  let conn;
  try {
    conn = await pool.getConnection();
    
    // Get post votes
    const postVotes = await conn.query(
      `SELECT v.*, p.title as post_title, p.community_id
       FROM vote v
       JOIN post p ON v.post_id = p.id
       WHERE v.user_id = ? AND v.post_id IS NOT NULL`,
      [userId]
    );
    
    // Get comment votes
    const commentVotes = await conn.query(
      `SELECT v.*, c.content as comment_content, p.id as post_id, p.title as post_title, p.community_id
       FROM vote v
       JOIN comment c ON v.comment_id = c.id
       JOIN post p ON c.post_id = p.id
       WHERE v.user_id = ? AND v.comment_id IS NOT NULL`,
      [userId]
    );
    
    return {
      postVotes,
      commentVotes
    };
  } catch (error) {
    console.error('Error getting user votes:', error);
    throw error;
  } finally {
    if (conn) conn.release();
  }
}

// Helper function to update SQL queries to include votes
function includePostVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.post_id = p.id), 0) as votes`;
}

function includeCommentVotesInQuery(baseQuery) {
  return baseQuery + `, COALESCE((SELECT SUM(value) FROM vote v WHERE v.comment_id = c.id), 0) as votes`;
}

// Helper function to get activity type ID
async function getActivityTypeId(conn, typeName) {
  const [activityType] = await conn.query(
    "SELECT id FROM activity_type WHERE name = ?",
    [typeName]
  );
  
  return activityType ? activityType.id : null;
}

// Helper function to get action ID
async function getActionId(conn, actionName) {
  const [action] = await conn.query(
    "SELECT id FROM action WHERE name = ?",
    [actionName]
  );
  
  return action ? action.id : null;
}

// Helper function to log vote activity
async function logVoteActivity(conn, userId, activityTypeId, actionId, entityId, entityType, voteValue) {
  await conn.query(
    `INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      uuidv4(),
      userId,
      activityTypeId,
      actionId,
      entityId,
      entityType,
      JSON.stringify({ value: voteValue })
    ]
  );
}

module.exports = {
  voteOnPost,
  voteOnComment,
  getUserPostVote,
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes,
  includePostVotesInQuery,
  includeCommentVotesInQuery
};

================
File: backend/api/votes.ts
================
export async function voteOnPost(userId: string, postId: string, value: number): Promise<any> {
    throw new Error('Vote value must be 1, -1, or 0');
      throw new Error('Post not found');
export async function voteOnComment(userId: string, commentId: string, value: number): Promise<any> {
      throw new Error('Comment not found');
export async function getUserPostVote(userId: string, postId: string): Promise<number> {
export async function getUserCommentVote(userId: string, commentId: string): Promise<number> {
export async function getPostVoteCounts(postId: string): Promise<{upvotes: number, downvotes: number, total: number}> {
export async function getCommentVoteCounts(commentId: string): Promise<{upvotes: number, downvotes: number, total: number}> {
export function includePostVotesInQuery(baseQuery: string): string {
export function includeCommentVotesInQuery(baseQuery: string): string {

================
File: backend/check-community.js
================
require('dotenv').config();
async function run() {
    const connection = await mysql.createConnection({
      const [community] = await connection.query('SELECT * FROM community WHERE id = ?', [communityId]);
      console.log('Community found:', community.length > 0);
        console.log('Community details:', community[0]);
      console.error('Error accessing community:', err.message);
      const [members] = await connection.query('SELECT * FROM community_member WHERE community_id = ?', [communityId]);
      console.log('\nCommunity members found:', members.length);
        console.log('Sample member:', members[0]);
      console.error('Error accessing community members:', err.message);
      const [rules] = await connection.query('SELECT * FROM community_rule WHERE community_id = ?', [communityId]);
      console.log('\nCommunity rules found:', rules.length);
        console.log('Sample rule:', rules[0]);
      console.error('Error accessing community rules:', err.message);
      const [settings] = await connection.query('SELECT * FROM community_setting WHERE community_id = ?', [communityId]);
      console.log('\nCommunity settings found:', settings.length);
        console.log('Settings:', settings[0]);
      console.error('Error accessing community settings:', err.message);
      const [posts] = await connection.query('SELECT * FROM post WHERE community_id = ? LIMIT 5', [communityId]);
      console.log('\nPosts found:', posts.length);
        console.log('Sample post:', { 
      console.error('Error accessing posts:', err.message);
    await connection.end();
    console.error('Database error:', err);
run();

================
File: backend/check-tables.js
================
require('dotenv').config();
async function run() {
    const connection = await mysql.createConnection({
    console.log(`Connected to database: ${process.env.DB_NAME} on ${process.env.DB_HOST}`);
    const [tables] = await connection.query('SHOW TABLES');
    console.log('Tables in the database:');
    tables.forEach(row => {
      const tableName = Object.values(row)[0];
      console.log(tableName);
        [communities] = await connection.query('SELECT id, name FROM community LIMIT 5');
        console.log("\nUsing singular 'community' table name");
        [communities] = await connection.query('SELECT id, name FROM communities LIMIT 5');
        console.log("\nUsing plural 'communities' table name");
      console.log('Sample community data:');
      communities.forEach(community => {
        console.log(`ID: ${community.id}, Name: ${community.name}`);
      console.error('Error accessing community data:', err.message);
    await connection.end();
    console.error('Database error:', err);
run();

================
File: backend/db/add_admin_user.js
================
async function executeQuery(connection, query, params = []) {
    const [result] = await connection.execute(query, params);
    console.error(`Error executing query: ${query}`);
    console.error(error);
async function addAdminUser() {
    connection = await mysql.createConnection(dbConfig);
    console.log('Connected to database');
    const userId = uuidv4();
    const passwordHash = await bcrypt.hash(adminUser.password, saltRounds);
    const existingUsers = await executeQuery(
      console.log('Admin user already exists. Skipping creation.');
    await executeQuery(
    console.log(`Admin user created successfully with ID: ${userId}`);
    console.log(`Username: ${adminUser.username}`);
    console.log(`Password: ${adminUser.password}`);
    console.error('Error adding admin user:', error);
    if (connection) await connection.end();
addAdminUser();

================
File: backend/db/apply_auth_schema.js
================
async function applyAuthSchema() {
  console.log('Applying auth schema changes...');
    console.log('Creating backups of original files...');
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Backed up ${file.src} to ${file.dest}`);
        console.log(`Warning: ${file.src} does not exist, skipping backup`);
    console.log('Applying database schema changes...');
    const conn = await pool.getConnection();
      await conn.beginTransaction();
      const [userTableExists] = await conn.query(
        console.log('Creating user table...');
        const [usersTableExists] = await conn.query(
          await conn.query("RENAME TABLE users TO user");
          console.log('Renamed users table to user');
              await conn.query(`ALTER TABLE user ${column}`);
              console.log(`Added column: ${column}`);
              console.warn(`Warning: Could not add column: ${column}`, error.message);
          await conn.query(`
          console.log('Created user table');
        console.log('User table already exists, skipping creation');
      const [userStatisticTableExists] = await conn.query(
        console.log('Creating user_statistic table...');
        console.log('Created user_statistic table');
        console.log('Populated user_statistic table with existing users');
        console.log('User_statistic table already exists, skipping creation');
      const [userSettingTableExists] = await conn.query(
        console.log('Creating user_setting table...');
        console.log('Created user_setting table');
        console.log('Populated user_setting table with existing users');
        console.log('User_setting table already exists, skipping creation');
      await conn.commit();
      console.log('Database schema changes applied successfully');
      await conn.rollback();
      console.error('Error applying database schema changes:', error);
      conn.release();
    console.log('Replacing auth files with new versions...');
        console.log(`Replaced ${file.dest} with ${file.src}`);
        console.log(`Warning: ${file.src} does not exist, skipping replacement`);
    console.log('Auth schema changes applied successfully!');
    console.error('Error applying auth schema changes:', error);
    process.exit(1);
applyAuthSchema().then(() => {
  console.log('Auth schema update completed');
  process.exit(0);
}).catch(error => {
  console.error('Auth schema update failed:', error);

================
File: backend/db/apply_comments_schema.js
================
dotenv.config();
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
async function applyCommentsSchema() {
    conn = await pool.getConnection();
    console.log('Connected to the database');
    const sqlFilePath = path.join(__dirname, 'comments_schema_updates.sql');
    const sql = fs.readFileSync(sqlFilePath, 'utf8');
      .split(';')
      .filter(statement => statement.trim() !== '');
        await conn.query(statement);
        console.log('Executed statement:', statement.trim().substring(0, 50) + '...');
        console.error('Error executing statement:', statement.trim());
        console.error('Error details:', err);
    console.log('Comments schema updates applied successfully');
    console.error('Error applying comments schema updates:', err);
      conn.end();
    process.exit(0);
applyCommentsSchema();

================
File: backend/db/apply_community_updates.js
================
const pool = mariadb.createPool({
async function applySchemaUpdates() {
        conn = await pool.getConnection();
        console.log('Connected to database!');
        const sqlFilePath = path.join(__dirname, 'community_schema_updates.sql');
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
            await conn.query(statement);
        console.log('Schema updates applied successfully!');
        console.error('Error applying schema updates:', err);
            conn.end();
applySchemaUpdates();

================
File: backend/db/apply_moderator_schema.js
================
dotenv.config({ path: path.resolve(__dirname, '../.env') });
const pool = mariadb.createPool({
    port: Number(process.env.DB_PORT),
async function applySchemaUpdates() {
    console.log(`Attempting to connect to database: ${process.env.DB_NAME}`); // Log the database name
        conn = await pool.getConnection();
        console.log('Connected to database. Applying moderator schema updates...');
        const schemaFilePath = path.join(__dirname, 'moderator_schema_updates.sql');
        const schemaSQL = fs.readFileSync(schemaFilePath, 'utf8');
        const statements = schemaSQL.split(';').filter(stmt => stmt.trim());
            if (statement.trim()) {
                await conn.query(statement);
                console.log('Executed SQL statement.');
        console.log('Moderator schema updates applied successfully!');
        console.error('Error applying moderator schema updates:', error);
        if (conn) conn.end();
applySchemaUpdates();

================
File: backend/db/apply_new_schema.js
================
async function createDatabase() {
  const rootConnection = await mysql.createConnection({
    console.log('Creating database and user...');
    await rootConnection.query(`DROP DATABASE IF EXISTS rumfornew2`);
    await rootConnection.query(`CREATE DATABASE rumfornew2`);
      await rootConnection.query(`
      await rootConnection.query(`GRANT ALL PRIVILEGES ON rumfornew2.* TO 'rumfornew2'@'%'`);
      await rootConnection.query(`FLUSH PRIVILEGES`);
      console.log('User created and privileges granted.');
      console.log('User already exists or error creating user:', error.message);
      console.log('Privileges granted.');
    await rootConnection.end();
async function applySchema() {
  const schemaPath = path.join(__dirname, 'simple_schema.sql');
  const schema = fs.readFileSync(schemaPath, 'utf8');
  const connection = await mysql.createConnection({
    console.log('Applying schema...');
    await connection.query(schema);
    console.log('Schema applied successfully!');
    console.error('Error applying schema:', error);
    await connection.end();
async function main() {
    await createDatabase();
    await applySchema();
    console.log('Database setup completed successfully!');
    console.error('Error setting up database:', error);
    process.exit(1);
main();

================
File: backend/db/apply_user_auth_schema.js
================
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const pool = mariadb.createPool({
    port: Number(process.env.DB_PORT),
async function applyUserAuthSchema() {
        console.log('Connecting to MariaDB...');
        console.log('Connection details:', {
        conn = await pool.getConnection();
        console.log('Connected to MariaDB!');
        const sqlFilePath = path.join(__dirname, 'user_auth_schema.sql');
        console.log('Reading SQL file from:', sqlFilePath);
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
        console.log(`Found ${statements.length} SQL statements to execute`);
            console.log(`Executing: ${statement}`);
                const result = await conn.query(statement);
                console.log('Statement executed successfully');
                console.error('Error executing statement:', err.message);
        const adminId = uuidv4();
        const [existingAdmin] = await conn.query(
            console.log('Creating admin user...');
            const hashedPassword = await bcrypt.hash(adminPassword, saltRounds);
            await conn.query(
            console.log('Admin user created successfully!');
            console.log('Admin credentials:');
            console.log('Username:', adminUsername);
            console.log('Password:', adminPassword);
            console.log('Please change this password after first login!');
            console.log('Admin user already exists, skipping creation.');
        console.log('User authentication schema updates applied successfully!');
        console.error('Error applying user authentication schema:', err);
            console.log('Closing database connection');
            conn.end();
applyUserAuthSchema();

================
File: backend/db/apply_user_statistics_schema.js
================
require('dotenv').config();
async function applyUserStatisticsSchema() {
  const sqlFilePath = path.join(__dirname, 'user_statistics_schema.sql');
  const sql = fs.readFileSync(sqlFilePath, 'utf8');
    .replace(/DELIMITER \/\//g, '') // Remove DELIMITER statements
    .replace(/END \/\//g, 'END;')   // Replace END // with END;
    .replace(/DELIMITER ;/g, '')    // Remove DELIMITER ; statements
    .split(';')
    .filter(statement => statement.trim() !== '');
  const connection = await mysql.createConnection({
    console.log('Applying user statistics schema...');
        await connection.query(statement);
        console.log('Executed statement successfully');
        console.error('Error executing statement:', err);
        console.error('Statement:', statement);
    console.log('User statistics schema applied successfully');
    console.error('Error applying user statistics schema:', err);
    await connection.end();
applyUserStatisticsSchema().catch(console.error);

================
File: backend/db/apply_votes_schema.js
================
async function applyVotesSchema() {
  require('dotenv').config({ path: path.resolve(__dirname, '../.env') });
  console.log('Connecting to database with:', {
    port: Number(process.env.DB_PORT),
    conn = await mariadb.createConnection({
    const sqlPath = path.join(__dirname, 'votes_schema_update.sql');
    const sql = fs.readFileSync(sqlPath, 'utf8');
    console.log('Applying votes schema updates...');
    const result = await conn.query(sql);
    console.log('Votes schema updated successfully!');
    console.error('Error updating votes schema:', err);
      conn.end();
  applyVotesSchema()
    .then(() => {
      console.log('Schema update completed.');
      process.exit(0);
    .catch(err => {
      console.error('Failed to update schema:', err);
      process.exit(1);

================
File: backend/db/comments_schema_updates.sql
================
-- Add parent_comment_id column to comments table for threaded replies
ALTER TABLE comments ADD COLUMN IF NOT EXISTS parent_comment_id VARCHAR(36) DEFAULT NULL;

-- Add foreign key constraint for parent_comment_id
ALTER TABLE comments ADD CONSTRAINT IF NOT EXISTS fk_parent_comment
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id)
    ON DELETE SET NULL;

-- Add profile_post column to posts table to distinguish between community posts and profile posts
ALTER TABLE posts ADD COLUMN IF NOT EXISTS profile_post BOOLEAN DEFAULT FALSE;

-- Add user_profile_id column to posts table for posts on user profiles
ALTER TABLE posts ADD COLUMN IF NOT EXISTS user_profile_id VARCHAR(36) DEFAULT NULL;

-- Add foreign key constraint for user_profile_id
ALTER TABLE posts ADD CONSTRAINT IF NOT EXISTS fk_user_profile
    FOREIGN KEY (user_profile_id) REFERENCES users(id)
    ON DELETE CASCADE;

-- Create index for faster comment retrieval by post_id
CREATE INDEX IF NOT EXISTS idx_comments_post_id ON comments(post_id);

-- Create index for faster comment retrieval by parent_comment_id
CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON comments(parent_comment_id);

-- Create index for faster post retrieval by user_profile_id
CREATE INDEX IF NOT EXISTS idx_posts_user_profile ON posts(user_profile_id);

================
File: backend/db/community_schema_updates.sql
================
-- Add privacy column to communities table
ALTER TABLE communities ADD COLUMN IF NOT EXISTS privacy VARCHAR(10) DEFAULT 'public';

-- Create community_members table for tracking membership
CREATE TABLE IF NOT EXISTS community_members (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create community_rules table
CREATE TABLE IF NOT EXISTS community_rules (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

-- Create community_settings table
CREATE TABLE IF NOT EXISTS community_settings (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

-- Create join requests table for tracking pending membership requests
CREATE TABLE IF NOT EXISTS community_join_requests (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

================
File: backend/db/connection.d.ts
================
declare const pool: Pool;

================
File: backend/db/connection.js
================
require('dotenv').config();
function createConnectionPool() {
    port: parseInt(process.env.DB_PORT || '3306', 10),
  const pool = mysql.createPool(dbConfig);
  pool.getConnection()
    .then(conn => {
      console.log(`Connected to MySQL database: ${dbConfig.database} on ${dbConfig.host}:${dbConfig.port}`);
      conn.release();
    .catch(err => {
      console.error('Error connecting to database:', err.message);
      console.error('Please check your database connection settings in the .env file.');
        console.error('Connection refused. Make sure the database server is running and accessible.');
        console.error('Access denied. Check your database username and password.');
        console.error(`Database '${dbConfig.database}' does not exist. Run the database setup scripts first.`);
const pool = createConnectionPool();

================
File: backend/db/connection.ts
================
function createConnectionPool() {

================
File: backend/db/fetch_usernames.js
================
dotenv.config();
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
async function updateMembersWithUsernames() {
    conn = await pool.getConnection();
    const users = await conn.query("SELECT id, username FROM users");
      console.log("No users found in the database");
    console.log(`Found ${users.length} users`);
    const userMap = new Map();
    users.forEach(user => {
      userMap.set(user.id, user.username);
    const members = await conn.query("SELECT * FROM community_members");
      console.log("No community members found in the database");
    console.log(`Found ${members.length} community members`);
      const testResult = await conn.query(testQuery);
      console.log("Test query result:", testResult);
      console.log("LEFT JOIN to users table works correctly");
      console.error("LEFT JOIN test failed:", error.message);
      console.log("User IDs in community_members might not match users table IDs");
    const moderators = members.filter(m => m.role === 'moderator' || m.role === 'admin');
    console.log(`Found ${moderators.length} moderators/admins`);
      const username = userMap.get(mod.user_id) || 'Unknown User';
      console.log(`Community ${mod.community_id}: Moderator ${username} (${mod.user_id}), role: ${mod.role}`);
    console.log("Database check complete");
    console.error("Error updating members with usernames:", error);
    if (conn) conn.release();
    process.exit(0);
updateMembersWithUsernames();

================
File: backend/db/fix_community_api.js
================
dotenv.config({ path: path.resolve(__dirname, '../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
async function fixCommunityApi() {
    conn = await pool.getConnection();
      await conn.query(`
      console.log('Added privacy column to communities table');
      console.log('Skipping adding privacy column - may already exist or table structure is different');
      console.log('Created or verified community_members table');
      console.error('Error creating community_members table:', error);
      console.log('Created or verified community_rules table');
      console.error('Error creating community_rules table:', error);
      console.log('Created or verified community_settings table');
      console.error('Error creating community_settings table:', error);
      const communities = await conn.query('SELECT id FROM communities');
        const [setting] = await conn.query(
          await conn.query(
          console.log(`Added default settings for community ${community.id}`);
      console.error('Error setting up default community settings:', error);
    console.log('Database fixes complete');
    console.error('Error fixing community API:', error);
    if (conn) conn.release();
fixCommunityApi()
  .then(() => console.log('Fix script completed'))
  .catch(err => console.error('Fix script failed:', err))
  .finally(() => process.exit());

================
File: backend/db/fixed_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL, -- 'home', 'work', etc.
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User relationships
CREATE TABLE user_relationship (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    related_user_id VARCHAR(36) NOT NULL,
    relationship_type VARCHAR(20) NOT NULL, -- 'friend', 'follow', 'block'
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (related_user_id) REFERENCES user(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, related_user_id, relationship_type)
);

-- User achievements
CREATE TABLE user_achievement (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community join requests
CREATE TABLE community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User flair for communities
CREATE TABLE user_flair (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    text VARCHAR(50) NOT NULL,
    background_color VARCHAR(20) DEFAULT '#e0e0e0',
    text_color VARCHAR(20) DEFAULT '#000000',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, community_id)
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Vote table with support for both post and comment votes
CREATE TABLE vote (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, IFNULL(post_id, ''), IFNULL(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE,
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Saved items
CREATE TABLE saved_item (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    item_id VARCHAR(36) NOT NULL,
    item_type VARCHAR(20) NOT NULL, -- 'post', 'comment'
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    collection_name VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post moderation
CREATE TABLE post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE SET NULL
);

-- Banned users
CREATE TABLE banned_user (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (banned_by) REFERENCES user(id) ON DELETE CASCADE
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, community, etc.)
    entity_type VARCHAR(50), -- Type of the related entity (post, comment, community, etc.)
    metadata JSON, -- Additional data related to the activity
    ip_address VARCHAR(45), -- IPv4 or IPv6 address
    user_agent TEXT, -- Browser/client information
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Moderation logs
CREATE TABLE moderation_log (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Create indexes for faster queries
CREATE INDEX idx_post_user_id ON post(user_id);
CREATE INDEX idx_post_community_id ON post(community_id);
CREATE INDEX idx_comment_post_id ON comment(post_id);
CREATE INDEX idx_comment_user_id ON comment(user_id);
CREATE INDEX idx_comment_parent_id ON comment(parent_comment_id);
CREATE INDEX idx_vote_post_id ON vote(post_id);
CREATE INDEX idx_vote_comment_id ON vote(comment_id);
CREATE INDEX idx_activity_user_id ON activity(user_id);
CREATE INDEX idx_activity_type_id ON activity(activity_type_id);
CREATE INDEX idx_activity_action_id ON activity(action_id);
CREATE INDEX idx_activity_entity ON activity(entity_id, entity_type);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

================
File: backend/db/generate_sample_data.js
================
async function executeQuery(connection, query, params = []) {
    const [result] = await connection.execute(query, params);
    console.error(`Error executing query: ${query}`);
    console.error(error);
async function generateUsers(connection, count = 10) {
  console.log(`Generating ${count} sample users...`);
    const userId = uuidv4();
    await executeQuery(
        new Date(2020, 0, i + 1) // Different cake days
        Math.floor(Math.random() * 1000), // Random karma
        Math.floor(Math.random() * 20), // Random posts count
        Math.floor(Math.random() * 50), // Random comments count
        Math.floor(Math.random() * 100), // Random upvotes received
        Math.floor(Math.random() * 20), // Random downvotes received
        Math.floor(Math.random() * 200), // Random upvotes given
        Math.floor(Math.random() * 50), // Random downvotes given
        Math.floor(Math.random() * 5) // Random communities joined
        Math.random() > 0.3 ? 1 : 0, // 70% chance of email notifications enabled
        Math.random() > 0.5 ? 1 : 0, // 50% chance of push notifications enabled
        Math.random() > 0.7 ? 'dark' : 'light', // 30% chance of dark theme
    users.push({
  console.log(`Generated ${users.length} users`);
async function generateCommunities(connection, users, count = 5) {
  console.log(`Generating ${count} sample communities...`);
    const communityId = uuidv4();
        `#${Math.floor(Math.random() * 16777215).toString(16)}`, // Random color
      if (i > 0 && j > 0 && Math.random() < 0.3) continue;
          Math.floor(Math.random() * 365) // Joined 0-365 days ago
    const ruleCount = Math.floor(Math.random() * 5) + 1; // 1-5 rules
          uuidv4(),
    communities.push({
  console.log(`Generated ${communities.length} communities`);
async function generatePosts(connection, users, communities, count = 20) {
  console.log(`Generating ${count} sample posts...`);
    const postId = uuidv4();
    const userIndex = Math.floor(Math.random() * users.length);
    const communityIndex = Math.floor(Math.random() * communities.length);
        Math.floor(Math.random() * 720), // 0-30 days ago
        Math.floor(Math.random() * 720) // 0-30 days ago
    posts.push({
  console.log(`Generated ${posts.length} posts`);
async function generateComments(connection, users, posts, count = 50) {
  console.log(`Generating ${count} sample comments...`);
    const commentId = uuidv4();
    const postIndex = Math.floor(Math.random() * posts.length);
    const isReply = i > 10 && Math.random() < 0.3; // 30% chance of being a reply after the first 10 comments
    const parentCommentId = isReply ? comments[Math.floor(Math.random() * comments.length)].id : null;
        Math.floor(Math.random() * 43200), // 0-30 days ago
        Math.floor(Math.random() * 43200) // 0-30 days ago
    comments.push({
  console.log(`Generated ${comments.length} comments`);
async function generateActivities(connection, users, posts, comments) {
  console.log('Generating sample activities...');
  const activityTypes = await executeQuery(connection, 'SELECT * FROM activity_type');
  const actions = await executeQuery(connection, 'SELECT * FROM action');
  activityTypes.forEach(type => {
  actions.forEach(action => {
        JSON.stringify({ title: post.title, community_id: post.communityId }),
        JSON.stringify({ post_id: comment.postId, parent_comment_id: comment.parentCommentId }),
    const isUpvote = Math.random() > 0.3; // 70% chance of upvote
    const isPostVote = Math.random() > 0.4; // 60% chance of post vote
      ? posts[Math.floor(Math.random() * posts.length)].id
      : comments[Math.floor(Math.random() * comments.length)].id;
        JSON.stringify({ value: isUpvote ? 1 : -1 }),
  console.log('Generated activities');
async function generateSampleData() {
    connection = await mysql.createConnection(dbConfig);
    console.log('Connected to database');
    await executeQuery(connection, 'SET FOREIGN_KEY_CHECKS = 0');
    const users = await generateUsers(connection);
    const communities = await generateCommunities(connection, users);
    const posts = await generatePosts(connection, users, communities);
    const comments = await generateComments(connection, users, posts);
    await generateActivities(connection, users, posts, comments);
    await executeQuery(connection, 'SET FOREIGN_KEY_CHECKS = 1');
    console.log('Sample data generation completed successfully!');
    console.error('Error generating sample data:', error);
    if (connection) await connection.end();
generateSampleData();

================
File: backend/db/init_schema.js
================
require('dotenv').config({ path: path.join(__dirname, '../.env') });
const pool = mariadb.createPool({
    port: Number(process.env.DB_PORT),
async function initSchema() {
        console.log('Connecting to MariaDB...');
        console.log('Connection details:', {
        conn = await pool.getConnection();
        console.log('Connected to MariaDB!');
        const sqlFilePath = path.join(__dirname, 'schema.sql');
        console.log('Reading SQL file from:', sqlFilePath);
        const sql = fs.readFileSync(sqlFilePath, 'utf8');
        const statements = sql.split(';').filter(statement => statement.trim() !== '');
        console.log(`Found ${statements.length} SQL statements to execute`);
            console.log(`Executing: ${statement}`);
                const result = await conn.query(statement);
                console.log('Statement executed successfully');
                console.error('Error executing statement:', err.message);
        console.log('Schema initialization completed!');
        console.error('Error initializing schema:', err);
            console.log('Closing database connection');
            conn.end();
initSchema();

================
File: backend/db/init.js
================
const pool = mariadb.createPool({
async function initializeDatabase() {
        const schemaPath = path.join(__dirname, 'schema.sql');
        const schema = fs.readFileSync(schemaPath, 'utf8');
        conn = await pool.getConnection();
        await conn.query(schema);
        console.log('Database schema initialized successfully');
        console.error('Error initializing database:', error);
        if (conn) conn.end();
initializeDatabase();

================
File: backend/db/migrate_data.js
================
async function executeQuery(connection, query, params = []) {
    const [result] = await connection.execute(query, params);
    console.error(`Error executing query: ${query}`);
    console.error(error);
async function migrateUsers(oldConn, newConn) {
  console.log('Migrating users...');
  const users = await executeQuery(oldConn, 'SELECT * FROM users');
  console.log(`Found ${users.length} users to migrate`);
    const userSettings = await executeQuery(oldConn, 'SELECT * FROM user_settings');
    userSettings.forEach(setting => {
    console.log(`Found ${userSettings.length} user settings to migrate`);
    console.log('No user_settings table found, skipping');
    const userStats = await executeQuery(oldConn, 'SELECT * FROM user_statistics');
    userStats.forEach(stat => {
    console.log(`Found ${userStats.length} user statistics to migrate`);
    console.log('No user_statistics table found, skipping');
    await executeQuery(
  console.log('Users migration completed');
async function migrateCommunities(oldConn, newConn) {
  console.log('Migrating communities...');
    const communities = await executeQuery(oldConn, 'SELECT * FROM communities');
    console.log(`Found ${communities.length} communities to migrate`);
      const communitySettings = await executeQuery(oldConn, 'SELECT * FROM community_settings');
      communitySettings.forEach(setting => {
      console.log(`Found ${communitySettings.length} community settings to migrate`);
      console.log('No community_settings table found, skipping');
    console.log('Communities migration completed');
    console.log('No communities table found, skipping');
async function migrateCommunityMembers(oldConn, newConn) {
  console.log('Migrating community members...');
    const members = await executeQuery(oldConn, 'SELECT * FROM community_members');
    console.log(`Found ${members.length} community members to migrate`);
    console.log('Community members migration completed');
    console.log('No community_members table found, skipping');
async function migrateCommunityRules(oldConn, newConn) {
  console.log('Migrating community rules...');
    const rules = await executeQuery(oldConn, 'SELECT * FROM community_rules');
    console.log(`Found ${rules.length} community rules to migrate`);
    console.log('Community rules migration completed');
    console.log('No community_rules table found, skipping');
async function migratePosts(oldConn, newConn) {
  console.log('Migrating posts...');
    const posts = await executeQuery(oldConn, 'SELECT * FROM posts');
    console.log(`Found ${posts.length} posts to migrate`);
    console.log('Posts migration completed');
    console.log('No posts table found, skipping');
async function migrateComments(oldConn, newConn) {
  console.log('Migrating comments...');
    const comments = await executeQuery(oldConn, 'SELECT * FROM comments');
    console.log(`Found ${comments.length} comments to migrate`);
    console.log('Comments migration completed');
    console.log('No comments table found, skipping');
async function migrateVotes(oldConn, newConn) {
  console.log('Migrating votes...');
  const postVotes = await executeQuery(oldConn, 'SELECT * FROM votes WHERE post_id IS NOT NULL');
  console.log(`Found ${postVotes.length} post votes to migrate`);
  const commentVotes = await executeQuery(oldConn, 'SELECT * FROM votes WHERE comment_id IS NOT NULL');
  console.log(`Found ${commentVotes.length} comment votes to migrate`);
  console.log('Votes migration completed');
async function migrateModeratorPermissions(oldConn, newConn) {
  console.log('Migrating moderator permissions...');
  const permissions = await executeQuery(oldConn, 'SELECT * FROM moderator_permissions');
  console.log(`Found ${permissions.length} moderator permissions to migrate`);
  console.log('Moderator permissions migration completed');
async function migrateBannedUsers(oldConn, newConn) {
  console.log('Migrating banned users...');
  const bannedUsers = await executeQuery(oldConn, 'SELECT * FROM banned_users');
  console.log(`Found ${bannedUsers.length} banned users to migrate`);
  console.log('Banned users migration completed');
async function migrateSavedItems(oldConn, newConn) {
  console.log('Migrating saved items...');
  const savedItems = await executeQuery(oldConn, 'SELECT * FROM saved_items');
  console.log(`Found ${savedItems.length} saved items to migrate`);
  console.log('Saved items migration completed');
async function migrateUserRelationships(oldConn, newConn) {
  console.log('Migrating user relationships...');
  const friends = await executeQuery(oldConn, 'SELECT * FROM user_friends');
  console.log(`Found ${friends.length} friendships to migrate`);
        uuidv4(),
    const followers = await executeQuery(oldConn, 'SELECT * FROM user_followers');
    console.log(`Found ${followers.length} followers to migrate`);
    console.log('No followers table found, skipping');
    const blocks = await executeQuery(oldConn, 'SELECT * FROM user_blocked');
    console.log(`Found ${blocks.length} blocks to migrate`);
    console.log('No blocks table found, skipping');
  console.log('User relationships migration completed');
async function migrateUserAchievements(oldConn, newConn) {
  console.log('Migrating user achievements...');
  const achievements = await executeQuery(oldConn, 'SELECT * FROM user_achievements');
  console.log(`Found ${achievements.length} user achievements to migrate`);
  console.log('User achievements migration completed');
async function migrateUserFlairs(oldConn, newConn) {
  console.log('Migrating user flairs...');
  const flairs = await executeQuery(oldConn, 'SELECT * FROM user_flair');
  console.log(`Found ${flairs.length} user flairs to migrate`);
  console.log('User flairs migration completed');
async function migrateData() {
    oldConn = await mysql.createConnection(oldDbConfig);
    newConn = await mysql.createConnection(newDbConfig);
    console.log('Connected to both databases');
    await executeQuery(newConn, 'SET FOREIGN_KEY_CHECKS = 0');
    await migrateUsers(oldConn, newConn);
    await migrateCommunities(oldConn, newConn);
    await migrateCommunityMembers(oldConn, newConn);
    await migrateCommunityRules(oldConn, newConn);
    await migratePosts(oldConn, newConn);
    await migrateComments(oldConn, newConn);
    await migrateVotes(oldConn, newConn);
    await migrateModeratorPermissions(oldConn, newConn);
    await migrateBannedUsers(oldConn, newConn);
    await migrateSavedItems(oldConn, newConn);
    await migrateUserRelationships(oldConn, newConn);
    await migrateUserAchievements(oldConn, newConn);
    await migrateUserFlairs(oldConn, newConn);
    await executeQuery(newConn, 'SET FOREIGN_KEY_CHECKS = 1');
    console.log('Migration completed successfully!');
    console.error('Error during migration:', error);
    if (oldConn) await oldConn.end();
    if (newConn) await newConn.end();
migrateData();

================
File: backend/db/migrate_database.bat
================
@echo off
echo ===================================================
echo Database Migration Utility for Windows
echo ===================================================
echo.

:menu
echo Choose an option:
echo 1. Create new database and apply schema
echo 2. Migrate data from old database to new database
echo 3. Generate sample data for new database
echo 4. Add admin user to new database
echo 5. Switch application to use new database
echo 6. Switch application to use old database
echo 7. Restore original .env file
echo 8. Run complete migration with existing data (steps 1-2-5)
echo 9. Run complete migration with sample data (steps 1-3-5)
echo 10. Run complete migration with sample data and admin user (steps 1-3-4-5)
echo 11. Exit
echo.

set /p choice="Enter your choice (1-11): "

if "%choice%"=="1" goto create_db
if "%choice%"=="2" goto migrate_data
if "%choice%"=="3" goto generate_data
if "%choice%"=="4" goto add_admin
if "%choice%"=="5" goto use_new_db
if "%choice%"=="6" goto use_old_db
if "%choice%"=="7" goto restore_env
if "%choice%"=="8" goto complete_migration_existing
if "%choice%"=="9" goto complete_migration_sample
if "%choice%"=="10" goto complete_migration_sample_admin
if "%choice%"=="11" goto end
goto invalid_choice

:create_db
echo.
echo Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
pause
goto menu

:migrate_data
echo.
echo Migrating data from old database to new database...
cd %~dp0
node migrate_data.js
echo.
pause
goto menu

:use_new_db
echo.
echo Switching application to use new database...
cd %~dp0
node update_connection.js
echo.
pause
goto menu

:use_old_db
echo.
echo Switching application to use old database...
cd %~dp0
node update_connection.js --old
echo.
pause
goto menu

:restore_env
echo.
echo Restoring original .env file...
cd %~dp0
node update_connection.js --restore
echo.
pause
goto menu

:generate_data
echo.
echo Generating sample data for new database...
cd %~dp0
node generate_sample_data.js
echo.
pause
goto menu

:add_admin
echo.
echo Adding admin user to new database...
cd %~dp0
node add_admin_user.js
echo.
pause
goto menu

:complete_migration_existing
echo.
echo Running complete migration process with existing data...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Migrating data from old database to new database...
node migrate_data.js
echo.
echo Step 3: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:complete_migration_sample
echo.
echo Running complete migration process with sample data...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Generating sample data for new database...
node generate_sample_data.js
echo.
echo Step 3: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:complete_migration_sample_admin
echo.
echo Running complete migration process with sample data and admin user...
echo.
echo Step 1: Creating new database and applying schema...
cd %~dp0
node apply_new_schema.js
echo.
echo Step 2: Generating sample data for new database...
node generate_sample_data.js
echo.
echo Step 3: Adding admin user to new database...
node add_admin_user.js
echo.
echo Step 4: Switching application to use new database...
node update_connection.js
echo.
echo Migration process completed!
echo.
pause
goto menu

:invalid_choice
echo.
echo Invalid choice. Please try again.
echo.
pause
goto menu

:end
echo.
echo Exiting Database Migration Utility.
echo.

================
File: backend/db/moderator_schema_updates.sql
================
-- Enhance community_settings table with additional moderation settings
ALTER TABLE community_settings 
ADD COLUMN IF NOT EXISTS require_post_approval BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS restricted_words TEXT,
ADD COLUMN IF NOT EXISTS custom_theme_color VARCHAR(20),
ADD COLUMN IF NOT EXISTS custom_banner_url TEXT,
ADD COLUMN IF NOT EXISTS minimum_account_age_days INT DEFAULT 0,
ADD COLUMN IF NOT EXISTS minimum_karma_required INT DEFAULT 0;

-- Create moderator_permissions table for granular control
CREATE TABLE IF NOT EXISTS moderator_permissions (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Create post_moderation table for post approval workflow
CREATE TABLE IF NOT EXISTS post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (moderator_id) REFERENCES users(id)
);

-- Create moderation_logs table for tracking all moderator actions
CREATE TABLE IF NOT EXISTS moderation_logs (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (moderator_id) REFERENCES users(id)
);

-- Create banned_users table for community-specific bans
CREATE TABLE IF NOT EXISTS banned_users (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES communities(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (banned_by) REFERENCES users(id)
);

================
File: backend/db/new_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL, -- 'home', 'work', etc.
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User relationships
CREATE TABLE user_relationship (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    related_user_id VARCHAR(36) NOT NULL,
    relationship_type VARCHAR(20) NOT NULL, -- 'friend', 'follow', 'block'
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (related_user_id) REFERENCES user(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, related_user_id, relationship_type)
);

-- User achievements
CREATE TABLE user_achievement (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve', -- 'auto_approve', 'requires_approval', 'invite_only'
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community join requests
CREATE TABLE community_join_request (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    requested_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User flair for communities
CREATE TABLE user_flair (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    text VARCHAR(50) NOT NULL,
    background_color VARCHAR(20) DEFAULT '#e0e0e0',
    text_color VARCHAR(20) DEFAULT '#000000',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    UNIQUE KEY (user_id, community_id)
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Vote table with support for both post and comment votes
CREATE TABLE vote (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, COALESCE(post_id, ''), COALESCE(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (comment_id) REFERENCES comment(id) ON DELETE CASCADE,
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Saved items
CREATE TABLE saved_item (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    item_id VARCHAR(36) NOT NULL,
    item_type VARCHAR(20) NOT NULL, -- 'post', 'comment'
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    collection_name VARCHAR(50),
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE, 
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post moderation
CREATE TABLE post_moderation (
    post_id VARCHAR(36) PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'approved', 'rejected'
    moderator_id VARCHAR(36),
    reason TEXT,
    moderated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE SET NULL
);

-- Banned users
CREATE TABLE banned_user (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    reason TEXT,
    banned_by VARCHAR(36) NOT NULL,
    ban_expires_at TIMESTAMP NULL, -- NULL for permanent ban
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (banned_by) REFERENCES user(id) ON DELETE CASCADE
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, community, etc.)
    entity_type VARCHAR(50), -- Type of the related entity (post, comment, community, etc.)
    metadata JSON, -- Additional data related to the activity
    ip_address VARCHAR(45), -- IPv4 or IPv6 address
    user_agent TEXT, -- Browser/client information
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Moderation logs
CREATE TABLE moderation_log (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    moderator_id VARCHAR(36) NOT NULL,
    action_type VARCHAR(50) NOT NULL, -- 'approve_post', 'remove_post', 'ban_user', etc.
    target_id VARCHAR(36), -- ID of the post, comment, or user that was acted upon
    target_type VARCHAR(20), -- 'post', 'comment', 'user', etc.
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (moderator_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Create indexes for faster queries
CREATE INDEX idx_post_user_id ON post(user_id);
CREATE INDEX idx_post_community_id ON post(community_id);
CREATE INDEX idx_comment_post_id ON comment(post_id);
CREATE INDEX idx_comment_user_id ON comment(user_id);
CREATE INDEX idx_comment_parent_id ON comment(parent_comment_id);
CREATE INDEX idx_vote_post_id ON vote(post_id);
CREATE INDEX idx_vote_comment_id ON vote(comment_id);
CREATE INDEX idx_activity_user_id ON activity(user_id);
CREATE INDEX idx_activity_type_id ON activity(activity_type_id);
CREATE INDEX idx_activity_action_id ON activity(action_id);
CREATE INDEX idx_activity_entity ON activity(entity_id, entity_type);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

-- Create triggers to automatically update user statistics

-- Update posts_count when a post is created
DELIMITER //
CREATE TRIGGER after_post_insert
AFTER INSERT ON post
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        posts_count = posts_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'POST'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        NEW.id,
        'post',
        JSON_OBJECT(
            'title', NEW.title,
            'community_id', NEW.community_id
        )
    );
END //
DELIMITER ;

-- Update posts_count when a post is deleted
DELIMITER //
CREATE TRIGGER after_post_delete
AFTER DELETE ON post
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        posts_count = GREATEST(0, posts_count - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'POST'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        OLD.id,
        'post'
    );
END //
DELIMITER ;

-- Update comments_count when a comment is created
DELIMITER //
CREATE TRIGGER after_comment_insert
AFTER INSERT ON comment
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        comments_count = comments_count + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMENT'),
        (SELECT id FROM action WHERE name = 'CREATE'),
        NEW.id,
        'comment',
        JSON_OBJECT(
            'post_id', NEW.post_id,
            'parent_comment_id', NEW.parent_comment_id
        )
    );
END //
DELIMITER ;

-- Update comments_count when a comment is deleted
DELIMITER //
CREATE TRIGGER after_comment_delete
AFTER DELETE ON comment
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        comments_count = GREATEST(0, comments_count - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMENT'),
        (SELECT id FROM action WHERE name = 'DELETE'),
        OLD.id,
        'comment'
    );
END //
DELIMITER ;

-- Update upvotes/downvotes when a vote is created or updated
DELIMITER //
CREATE TRIGGER after_vote_insert_update
AFTER INSERT ON vote
FOR EACH ROW
BEGIN
    DECLARE content_author_id VARCHAR(36);
    DECLARE content_type VARCHAR(20);
    
    -- Determine the content type and get the author
    IF NEW.post_id IS NOT NULL THEN
        SELECT user_id INTO content_author_id FROM post WHERE id = NEW.post_id;
        SET content_type = 'post';
    ELSE
        SELECT user_id INTO content_author_id FROM comment WHERE id = NEW.comment_id;
        SET content_type = 'comment';
    END IF;
    
    -- Update the voter's stats
    IF NEW.value = 1 THEN
        UPDATE user_statistic SET 
            upvotes_given = upvotes_given + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.user_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE user_statistic SET 
            downvotes_given = downvotes_given + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = NEW.user_id;
    END IF;
    
    -- Update the content author's stats
    IF NEW.value = 1 THEN
        UPDATE user_statistic SET 
            upvotes_received = upvotes_received + 1,
            karma = karma + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = content_author_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE user_statistic SET 
            downvotes_received = downvotes_received + 1,
            karma = GREATEST(0, karma - 1),
            updated_at = CURRENT_TIMESTAMP
        WHERE user_id = content_author_id;
    END IF;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'VOTE'),
        (SELECT id FROM action WHERE name = IF(NEW.value = 1, 'UPVOTE', 'DOWNVOTE')),
        IF(NEW.post_id IS NOT NULL, NEW.post_id, NEW.comment_id),
        content_type
    );
END //
DELIMITER ;

-- Update communities_joined when a user joins a community
DELIMITER //
CREATE TRIGGER after_community_member_insert
AFTER INSERT ON community_member
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        communities_joined = communities_joined + 1,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id;
    
    UPDATE user SET 
        last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'JOIN'),
        NEW.community_id,
        'community',
        JSON_OBJECT('role', NEW.role)
    );
END //
DELIMITER ;

-- Update communities_joined when a user leaves a community
DELIMITER //
CREATE TRIGGER after_community_member_delete
AFTER DELETE ON community_member
FOR EACH ROW
BEGIN
    UPDATE user_statistic SET 
        communities_joined = GREATEST(0, communities_joined - 1),
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = OLD.user_id;
    
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type)
    VALUES (
        UUID(),
        OLD.user_id,
        (SELECT id FROM activity_type WHERE name = 'COMMUNITY'),
        (SELECT id FROM action WHERE name = 'LEAVE'),
        OLD.community_id,
        'community'
    );
END //
DELIMITER ;

-- Log moderation actions
DELIMITER //
CREATE TRIGGER after_moderation_log_insert
AFTER INSERT ON moderation_log
FOR EACH ROW
BEGIN
    -- Log activity
    INSERT INTO activity (id, user_id, activity_type_id, action_id, entity_id, entity_type, metadata)
    VALUES (
        UUID(),
        NEW.moderator_id,
        (SELECT id FROM activity_type WHERE name = 'MODERATION'),
        (SELECT id FROM action WHERE name = 'MODERATE'),
        NEW.target_id,
        NEW.target_type,
        JSON_OBJECT(
            'action_type', NEW.action_type,
            'community_id', NEW.community_id,
            'reason', NEW.reason
        )
    );
END //
DELIMITER ;

================
File: backend/db/README_DATABASE_REFACTORING.md
================
# Database Refactoring Guide

This guide explains the database refactoring process and how to use the scripts provided to migrate from the old database structure to the new one.

## Overview

The database refactoring addresses several issues with the current database:

1. **Data Duplication**: Eliminated duplicate data across tables
2. **Missing Activity Tracking**: Added comprehensive activity tracking system
3. **Inconsistent Naming Conventions**: Standardized naming conventions
4. **Missing Personal Information**: Added support for more user information

## New Database Structure

The new database structure includes:

- Improved user tables with support for personal information and addresses
- Consolidated user statistics in a single table
- Comprehensive activity tracking system
- Standardized naming conventions
- Better relationship handling

## Scripts

The following scripts are provided to help with the migration:

### 1. `new_schema.sql`

This file contains the complete SQL schema for the new database. It defines all tables, indexes, triggers, and default data.

### 2. `apply_new_schema.js`

This script creates the new database and applies the schema. It:

- Creates the `rumfornew2` database if it doesn't exist
- Creates the `rumfornew2` user with the password `Oswald1986!`
- Grants necessary privileges
- Applies the schema from `new_schema.sql`

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\apply_new_schema.js
```

For Bash/Linux:
```bash
node backend/db/apply_new_schema.js
```

### 3. `migrate_data.js`

This script migrates data from the old database to the new one. It:

- Connects to both the old and new databases
- Reads data from the old database tables
- Transforms the data to fit the new schema
- Inserts the transformed data into the new database tables

### 3a. `generate_sample_data.js`

This script generates sample data for the new database. It:

- Connects to the new database
- Generates sample users, communities, posts, comments, and activities
- Inserts the sample data into the new database tables

This script is useful when you don't have an existing database to migrate from, or when you want to test the new database with sample data.

### 3b. `add_admin_user.js`

This script adds an admin user to the new database. It:

- Connects to the new database
- Creates an admin user with username 'admin' and password 'Oswald1986!'
- Sets up the necessary user statistics and settings for the admin user

This script is useful for quickly setting up an admin account to access the system.

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\add_admin_user.js
```

For Bash/Linux:
```bash
node backend/db/add_admin_user.js
```

Usage:

For Windows PowerShell:
```powershell
node .\backend\db\migrate_data.js
```

For Bash/Linux:
```bash
node backend/db/migrate_data.js
```

### 4. `update_connection.js`

This script updates the application's database connection to use either the old or new database. It:

- Creates a backup of the original `.env` file
- Updates the database connection parameters in the `.env` file
- Provides options to switch between the old and new databases

Usage:

For Windows PowerShell:
```powershell
# Switch to the new database (default)
node .\backend\db\update_connection.js

# Switch to the old database
node .\backend\db\update_connection.js --old

# Restore the original .env file
node .\backend\db\update_connection.js --restore

# Show help
node .\backend\db\update_connection.js --help
```

For Bash/Linux:
```bash
# Switch to the new database (default)
node backend/db/update_connection.js

# Switch to the old database
node backend/db/update_connection.js --old

# Restore the original .env file
node backend/db/update_connection.js --restore

# Show help
node backend/db/update_connection.js --help
```

## Migration Process

Follow these steps to migrate to the new database:

1. **Backup your data**: Ensure you have a backup of your current database before proceeding.

2. **Create the new database and apply the schema**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\apply_new_schema.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/apply_new_schema.js
   ```

3. **Migrate the data from the old database to the new one**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\migrate_data.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/migrate_data.js
   ```

4. **Update the application to use the new database**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\update_connection.js
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/update_connection.js
   ```

5. **Test the application with the new database**:
   Start your application and verify that everything works as expected.

6. **If needed, switch back to the old database**:
   
   For Windows PowerShell:
   ```powershell
   node .\backend\db\update_connection.js --old
   ```
   
   For Bash/Linux:
   ```bash
   node backend/db/update_connection.js --old
   ```

## Key Improvements

### 1. User Data Structure

- Added support for first name, last name, date of birth, and secondary email
- Added support for user addresses
- Consolidated user statistics in a single table

### 2. Activity Tracking

- Added activity types and actions tables
- Added comprehensive activity tracking
- Automatic activity logging through triggers

### 3. Naming Conventions

- Standardized table names to singular form
- Consistent field naming across related tables
- Consistent use of snake_case for all field names

### 4. Relationships

- Improved handling of user relationships (friends, follows, blocks)
- Better community membership and moderation tracking
- Enhanced post and comment relationships

## Database Diagram

The new database structure follows this general organization:

```
User-related tables:
  - user
  - user_address
  - user_statistic
  - user_setting
  - user_relationship
  - user_achievement
  - user_flair

Community-related tables:
  - community
  - community_member
  - community_rule
  - community_setting
  - community_join_request
  - moderator_permission
  - banned_user

Content-related tables:
  - post
  - comment
  - vote
  - saved_item
  - post_moderation

Activity tracking:
  - activity_type
  - action
  - activity
  - moderation_log
```

## Troubleshooting

If you encounter issues during the migration process:

1. **Database connection errors**: Verify the connection parameters in the scripts match your environment.

2. **Permission issues**: Ensure the database user has the necessary privileges.

3. **Schema errors**: Check the MySQL error logs for details about any schema errors.

4. **Data migration errors**: The migration script will log errors for specific tables. You can modify the script to skip problematic tables or fix the data issues.

5. **Application errors**: If the application doesn't work with the new database, you can switch back to the old one using `update_connection.js --old` while you troubleshoot.

## Windows-Specific Notes

### Batch File for Windows Users

For Windows users, we've provided a batch file that makes it easier to run the migration scripts. You can run the batch file by double-clicking on it or by running it from PowerShell/Command Prompt:

```powershell
# From the project root
.\backend\db\migrate_database.bat

# Or navigate to the backend/db directory first
cd .\backend\db
.\migrate_database.bat
```

This will display a menu with options to:
1. Create new database and apply schema
2. Migrate data from old database to new database
3. Generate sample data for new database
4. Switch application to use new database
5. Switch application to use old database
6. Restore original .env file
7. Run complete migration with existing data (steps 1-2-4)
8. Run complete migration with sample data (steps 1-3-4)
9. Exit

Simply choose the option you want by entering the corresponding number.

### Additional Windows Notes

When running these scripts on Windows:

1. Make sure you're using the correct path separator (`\` instead of `/`) when running commands in PowerShell or Command Prompt.

2. If you encounter permission issues, you might need to run PowerShell as Administrator.

3. If you have issues with MySQL connections, ensure that the MySQL service is running:
   ```powershell
   # Check MySQL service status
   Get-Service MySQL*
   
   # Start MySQL service if it's not running
   Start-Service MySQL*
   ```

4. For database root access, you might need to specify the password in the scripts if your MySQL installation requires it.

================
File: backend/db/schema.sql
================
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS communities (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS posts (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (community_id) REFERENCES communities(id)
);

CREATE TABLE IF NOT EXISTS comments (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (parent_comment_id) REFERENCES comments(id)
);

CREATE TABLE IF NOT EXISTS votes (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, post_id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id)
);

================
File: backend/db/seed_communities.js
================
dotenv.config({ path: path.resolve(__dirname, '../.env') });
const pool = mariadb.createPool({
  port: Number(process.env.DB_PORT),
async function seedCommunities() {
    conn = await pool.getConnection();
        id: uuidv4(),
        const [existingCommunity] = await conn.query('SELECT * FROM communities WHERE name = ?', [community.name]);
          await conn.query(
          console.log(`Created community: ${community.name}`);
          console.log(`Added rules for community: ${community.name}`);
            const users = await conn.query('SELECT id FROM users LIMIT 1');
              console.log(`Added moderator for community: ${community.name}`);
            console.log(`No users available to add as moderators for ${community.name}`);
          console.log(`Community ${community.name} already exists`);
        console.error(`Error creating community ${community.name}:`, error);
    console.log('Seeding completed');
    console.error('Error seeding communities:', error);
    if (conn) conn.release();
seedCommunities()
  .then(() => console.log('Seed script completed'))
  .catch(err => console.error('Seed script failed:', err))
  .finally(() => process.exit());

================
File: backend/db/simple_schema.sql
================
-- New database schema for rumfornew2
-- Addressing issues with the current database:
-- 1. Data duplication
-- 2. Missing activity tracking
-- 3. Inconsistent naming conventions
-- 4. Missing personal information

-- Core user table with essential information only
CREATE TABLE user (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    secondary_email VARCHAR(255),
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    display_name VARCHAR(100),
    date_of_birth DATE,
    role VARCHAR(20) DEFAULT 'user',
    bio TEXT,
    avatar_url VARCHAR(255),
    profile_banner_url VARCHAR(255),
    website VARCHAR(255),
    location VARCHAR(100),
    is_verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',
    cake_day TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User addresses
CREATE TABLE user_address (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    address_type VARCHAR(20) NOT NULL,
    country VARCHAR(50),
    county VARCHAR(50),
    city VARCHAR(50),
    street VARCHAR(100),
    street_number INT,
    building VARCHAR(10),
    floor INT,
    apartment_number INT,
    postal_code VARCHAR(20),
    is_primary BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User statistics (single source of truth for all user stats)
CREATE TABLE user_statistic (
    user_id VARCHAR(36) PRIMARY KEY,
    karma INT DEFAULT 0,
    posts_count INT DEFAULT 0,
    comments_count INT DEFAULT 0,
    upvotes_received INT DEFAULT 0,
    downvotes_received INT DEFAULT 0,
    upvotes_given INT DEFAULT 0,
    downvotes_given INT DEFAULT 0,
    communities_joined INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- User settings
CREATE TABLE user_setting (
    user_id VARCHAR(36) PRIMARY KEY,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    theme VARCHAR(20) DEFAULT 'light',
    content_filter VARCHAR(20) DEFAULT 'standard',
    allow_followers BOOLEAN DEFAULT TRUE,
    display_online_status BOOLEAN DEFAULT TRUE,
    language VARCHAR(10) DEFAULT 'en',
    timezone VARCHAR(50) DEFAULT 'UTC',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community table
CREATE TABLE community (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL,
    description TEXT,
    privacy VARCHAR(10) DEFAULT 'public',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Community settings
CREATE TABLE community_setting (
    community_id VARCHAR(36) PRIMARY KEY,
    allow_post_images BOOLEAN DEFAULT TRUE,
    allow_post_links BOOLEAN DEFAULT TRUE,
    join_method VARCHAR(20) DEFAULT 'auto_approve',
    require_post_approval BOOLEAN DEFAULT FALSE,
    restricted_words TEXT,
    custom_theme_color VARCHAR(20),
    custom_banner_url TEXT,
    minimum_account_age_days INT DEFAULT 0,
    minimum_karma_required INT DEFAULT 0,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Community rules
CREATE TABLE community_rule (
    id VARCHAR(36) PRIMARY KEY,
    community_id VARCHAR(36) NOT NULL,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE
);

-- Moderator permissions
CREATE TABLE moderator_permission (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    can_manage_settings BOOLEAN DEFAULT FALSE,
    can_manage_members BOOLEAN DEFAULT FALSE,
    can_manage_posts BOOLEAN DEFAULT FALSE,
    can_manage_comments BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Community members
CREATE TABLE community_member (
    community_id VARCHAR(36) NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    role VARCHAR(20) DEFAULT 'member',
    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (community_id, user_id),
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Post table
CREATE TABLE post (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    community_id VARCHAR(36) NOT NULL,
    profile_post BOOLEAN DEFAULT FALSE,
    user_profile_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (community_id) REFERENCES community(id) ON DELETE CASCADE,
    FOREIGN KEY (user_profile_id) REFERENCES user(id) ON DELETE CASCADE
);

-- Comment table
CREATE TABLE comment (
    id VARCHAR(36) PRIMARY KEY,
    content TEXT NOT NULL,
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36) NOT NULL,
    parent_comment_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (post_id) REFERENCES post(id) ON DELETE CASCADE,
    FOREIGN KEY (parent_comment_id) REFERENCES comment(id) ON DELETE SET NULL
);

-- Activity types
CREATE TABLE activity_type (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Actions
CREATE TABLE action (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Activities
CREATE TABLE activity (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type_id VARCHAR(36) NOT NULL,
    action_id VARCHAR(36) NOT NULL,
    entity_id VARCHAR(36),
    entity_type VARCHAR(50),
    metadata JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES user(id) ON DELETE CASCADE,
    FOREIGN KEY (activity_type_id) REFERENCES activity_type(id),
    FOREIGN KEY (action_id) REFERENCES action(id)
);

-- Insert default activity types
INSERT INTO activity_type (id, name, description) VALUES
(UUID(), 'POST', 'Activities related to posts'),
(UUID(), 'COMMENT', 'Activities related to comments'),
(UUID(), 'VOTE', 'Activities related to voting'),
(UUID(), 'COMMUNITY', 'Activities related to communities'),
(UUID(), 'USER', 'Activities related to user accounts'),
(UUID(), 'MODERATION', 'Activities related to moderation actions'),
(UUID(), 'SYSTEM', 'System-level activities');

-- Insert default actions
INSERT INTO action (id, name, description) VALUES
(UUID(), 'CREATE', 'Creating a new entity'),
(UUID(), 'READ', 'Viewing or reading content'),
(UUID(), 'UPDATE', 'Updating existing content'),
(UUID(), 'DELETE', 'Deleting content'),
(UUID(), 'UPVOTE', 'Upvoting content'),
(UUID(), 'DOWNVOTE', 'Downvoting content'),
(UUID(), 'JOIN', 'Joining a community'),
(UUID(), 'LEAVE', 'Leaving a community'),
(UUID(), 'LOGIN', 'User login'),
(UUID(), 'LOGOUT', 'User logout'),
(UUID(), 'REGISTER', 'User registration'),
(UUID(), 'MODERATE', 'Moderation action'),
(UUID(), 'REPORT', 'Reporting content'),
(UUID(), 'APPROVE', 'Approving content'),
(UUID(), 'REJECT', 'Rejecting content'),
(UUID(), 'BAN', 'Banning a user'),
(UUID(), 'UNBAN', 'Unbanning a user');

================
File: backend/db/update_auth_files.js
================
async function updateAuthFiles() {
  console.log('Updating auth-related files...');
    console.log('Creating backups of original files...');
      const srcPath = path.join(__dirname, file.src);
      const destPath = path.join(__dirname, file.dest);
      if (fs.existsSync(srcPath)) {
        fs.copyFileSync(srcPath, destPath);
        console.log(`Backed up ${file.src} to ${file.dest}`);
        console.log(`Warning: ${file.src} does not exist, skipping backup`);
    console.log('Replacing auth files with new versions...');
        console.log(`Replaced ${file.dest} with ${file.src}`);
        console.log(`Warning: ${file.src} does not exist, skipping replacement`);
    console.log('Auth files updated successfully!');
    console.error('Error updating auth files:', error);
    process.exit(1);
updateAuthFiles().then(() => {
  console.log('Auth files update completed');
  process.exit(0);
}).catch(error => {
  console.error('Auth files update failed:', error);

================
File: backend/db/update_connection.js
================
function updateEnvFile(useNewDb = true) {
  const envPath = path.join(__dirname, '..', '.env');
    envContent = fs.readFileSync(envPath, 'utf8');
    console.error('Error reading .env file:', error);
  for (const [key, value] of Object.entries(dbConfig)) {
    const regex = new RegExp(`^${key}=.*$`, 'm');
    if (updatedContent.match(regex)) {
      updatedContent = updatedContent.replace(regex, `${key}=${value}`);
    fs.writeFileSync(envPath, updatedContent);
    console.log(`Successfully updated .env file to use ${useNewDb ? 'new' : 'old'} database`);
    console.error('Error writing .env file:', error);
function backupEnvFile() {
  const backupPath = path.join(__dirname, '..', '.env.backup');
    if (!fs.existsSync(backupPath)) {
      fs.copyFileSync(envPath, backupPath);
      console.log('Created backup of .env file at .env.backup');
      console.log('Backup of .env file already exists at .env.backup');
    console.error('Error creating backup of .env file:', error);
function restoreEnvFile() {
    if (fs.existsSync(backupPath)) {
      fs.copyFileSync(backupPath, envPath);
      console.log('Restored .env file from backup');
      console.error('No backup of .env file found at .env.backup');
    console.error('Error restoring .env file from backup:', error);
function parseArgs() {
  const args = process.argv.slice(2);
      console.log(`
      process.exit(0);
function main() {
  const options = parseArgs();
    if (restoreEnvFile()) {
      console.log('Successfully restored .env file from backup');
      console.error('Failed to restore .env file from backup');
      process.exit(1);
    if (!backupEnvFile()) {
      console.error('Failed to create backup of .env file');
  if (updateEnvFile(options.useNewDb)) {
    console.log(`Successfully updated .env file to use ${options.useNewDb ? 'new' : 'old'} database`);
    console.error(`Failed to update .env file to use ${options.useNewDb ? 'new' : 'old'} database`);
main();

================
File: backend/db/user_auth_schema.sql
================
-- Add role column to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS role VARCHAR(20) DEFAULT 'user';

-- Ensure community_members table has role column
ALTER TABLE community_members ADD COLUMN IF NOT EXISTS role VARCHAR(20) DEFAULT 'member';

-- Create initial admin user (will be executed via a separate script)
-- INSERT INTO users (id, username, email, password_hash, role) 
-- VALUES ('admin-uuid', 'admin', 'admin@example.com', 'hashed-password', 'admin');

================
File: backend/db/user_statistics_schema.sql
================
-- Add user statistics columns to users table
ALTER TABLE users ADD COLUMN IF NOT EXISTS bio TEXT DEFAULT NULL;
ALTER TABLE users ADD COLUMN IF NOT EXISTS avatar_url VARCHAR(255) DEFAULT NULL;
ALTER TABLE users ADD COLUMN IF NOT EXISTS post_count INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS comment_count INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS upvotes_received INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS downvotes_received INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS upvotes_given INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS downvotes_given INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS communities_joined INT DEFAULT 0;
ALTER TABLE users ADD COLUMN IF NOT EXISTS last_active TIMESTAMP DEFAULT CURRENT_TIMESTAMP;

-- Create user_friends table for tracking friendships
CREATE TABLE IF NOT EXISTS user_friends (
    user_id VARCHAR(36) NOT NULL,
    friend_id VARCHAR(36) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'pending', -- 'pending', 'accepted', 'rejected'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, friend_id),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (friend_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create user_achievements table for tracking achievements and badges
CREATE TABLE IF NOT EXISTS user_achievements (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    achievement_type VARCHAR(50) NOT NULL,
    achievement_name VARCHAR(100) NOT NULL,
    description TEXT,
    earned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create user_activity_log for tracking user activity (optional, for analytics)
CREATE TABLE IF NOT EXISTS user_activity_log (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL,
    activity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(36), -- ID of the related entity (post, comment, etc.)
    entity_type VARCHAR(50), -- Type of the related entity
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Create triggers to automatically update user statistics

-- Update post_count when a post is created
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_post_insert
AFTER INSERT ON posts
FOR EACH ROW
BEGIN
    UPDATE users SET post_count = post_count + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update post_count when a post is deleted
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_post_delete
AFTER DELETE ON posts
FOR EACH ROW
BEGIN
    UPDATE users SET post_count = GREATEST(0, post_count - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

-- Update comment_count when a comment is created
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_comment_insert
AFTER INSERT ON comments
FOR EACH ROW
BEGIN
    UPDATE users SET comment_count = comment_count + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update comment_count when a comment is deleted
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_comment_delete
AFTER DELETE ON comments
FOR EACH ROW
BEGIN
    UPDATE users SET comment_count = GREATEST(0, comment_count - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

-- Update upvotes/downvotes when a vote is created or updated
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_vote_insert_update
AFTER INSERT ON votes
FOR EACH ROW
BEGIN
    DECLARE post_author_id VARCHAR(36);
    
    -- Get the post author
    SELECT user_id INTO post_author_id FROM posts WHERE id = NEW.post_id;
    
    -- Update the voter's stats
    IF NEW.value = 1 THEN
        UPDATE users SET upvotes_given = upvotes_given + 1, last_active = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE users SET downvotes_given = downvotes_given + 1, last_active = CURRENT_TIMESTAMP
        WHERE id = NEW.user_id;
    END IF;
    
    -- Update the post author's stats
    IF NEW.value = 1 THEN
        UPDATE users SET upvotes_received = upvotes_received + 1
        WHERE id = post_author_id;
    ELSEIF NEW.value = -1 THEN
        UPDATE users SET downvotes_received = downvotes_received + 1
        WHERE id = post_author_id;
    END IF;
END //
DELIMITER ;

-- Update communities_joined when a user joins a community
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_community_member_insert
AFTER INSERT ON community_members
FOR EACH ROW
BEGIN
    UPDATE users SET communities_joined = communities_joined + 1, last_active = CURRENT_TIMESTAMP
    WHERE id = NEW.user_id;
END //
DELIMITER ;

-- Update communities_joined when a user leaves a community
DELIMITER //
CREATE TRIGGER IF NOT EXISTS after_community_member_delete
AFTER DELETE ON community_members
FOR EACH ROW
BEGIN
    UPDATE users SET communities_joined = GREATEST(0, communities_joined - 1)
    WHERE id = OLD.user_id;
END //
DELIMITER ;

================
File: backend/db/votes_schema_update.sql
================
-- Rename the old votes table
RENAME TABLE votes TO votes_old;

-- Create the new votes table with support for both post and comment votes
CREATE TABLE votes (
    user_id VARCHAR(36) NOT NULL,
    post_id VARCHAR(36),
    comment_id VARCHAR(36),
    value TINYINT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (user_id, COALESCE(post_id, ''), COALESCE(comment_id, '')),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (post_id) REFERENCES posts(id),
    FOREIGN KEY (comment_id) REFERENCES comments(id),
    CHECK (
        (post_id IS NOT NULL AND comment_id IS NULL) OR
        (post_id IS NULL AND comment_id IS NOT NULL)
    )
);

-- Migrate data from the old votes table
INSERT INTO votes (user_id, post_id, comment_id, value, created_at)
SELECT user_id, post_id, NULL, value, created_at FROM votes_old;

-- Drop the old votes table
DROP TABLE votes_old;

================
File: backend/fix_moderator_usernames.js
================
const pool = mariadb.createPool({
async function fixModeratorUsernames() {
    conn = await pool.getConnection();
      await conn.query('SELECT 1 FROM users LIMIT 1');
      console.log('✅ Users table exists');
      console.error('❌ Users table does not exist or cannot be accessed');
      await conn.query('SELECT 1 FROM community_members LIMIT 1');
      console.log('✅ Community_members table exists');
      console.error('❌ Community_members table does not exist or cannot be accessed');
      const members = await conn.query(`
      console.log(`Found ${members.length} moderators/admins`);
        console.log('\nSample moderator data:');
        members.forEach((mod, i) => {
          console.log(`[${i+1}] User ID: ${mod.user_id}, Username: ${mod.username || 'NULL'}, Role: ${mod.role}`);
        const missingUsernames = members.filter(m => !m.username);
          console.log(`\n⚠️ ${missingUsernames.length} moderators are missing usernames`);
          console.log('\n✅ All moderators have usernames');
      console.error('❌ Failed to query moderators:', error.message);
      const testResult = await conn.query(testQuery);
      console.log('\nTest JOIN query result:');
      console.log(testResult);
        console.log('\n✅ JOIN works correctly and returns usernames');
        console.log('\n⚠️ JOIN works but found no results');
      console.error('\n❌ JOIN query failed:', error.message);
    console.error('Error:', error);
    if (conn) conn.release();
fixModeratorUsernames()
  .then(() => console.log('\nScript completed'))
  .catch(err => console.error('\nScript failed:', err))
  .finally(() => process.exit());

================
File: backend/fix-table-names.js
================
const indexPath = path.join(__dirname, 'index.ts');
let content = fs.readFileSync(indexPath, 'utf8');
content = content.replace(/FROM communities WHERE/g, 'FROM community WHERE');
content = content.replace(/FROM community_members WHERE/g, 'FROM community_member WHERE');
content = content.replace(/FROM posts WHERE/g, 'FROM post WHERE');
content = content.replace(/FROM comments WHERE/g, 'FROM comment WHERE');
content = content.replace(/FROM users WHERE/g, 'FROM user WHERE');
content = content.replace(/FROM votes WHERE/g, 'FROM vote WHERE');
content = content.replace(/INSERT INTO communities/g, 'INSERT INTO community');
content = content.replace(/INSERT INTO community_members/g, 'INSERT INTO community_member');
content = content.replace(/INSERT INTO posts/g, 'INSERT INTO post');
content = content.replace(/INSERT INTO comments/g, 'INSERT INTO comment');
content = content.replace(/INSERT INTO users/g, 'INSERT INTO user');
content = content.replace(/INSERT INTO votes/g, 'INSERT INTO vote');
content = content.replace(/UPDATE communities/g, 'UPDATE community');
content = content.replace(/UPDATE community_members/g, 'UPDATE community_member');
content = content.replace(/UPDATE posts/g, 'UPDATE post');
content = content.replace(/UPDATE comments/g, 'UPDATE comment');
content = content.replace(/UPDATE users/g, 'UPDATE user');
content = content.replace(/UPDATE votes/g, 'UPDATE vote');
content = content.replace(/DELETE FROM communities/g, 'DELETE FROM community');
content = content.replace(/DELETE FROM community_members/g, 'DELETE FROM community_member');
content = content.replace(/DELETE FROM posts/g, 'DELETE FROM post');
content = content.replace(/DELETE FROM comments/g, 'DELETE FROM comment');
content = content.replace(/DELETE FROM users/g, 'DELETE FROM user');
content = content.replace(/DELETE FROM votes/g, 'DELETE FROM vote');
fs.writeFileSync(indexPath, content, 'utf8');
console.log('Updated table names from plural to singular in index.ts');
const routesDir = path.join(__dirname, 'routes');
const routeFiles = fs.readdirSync(routesDir);
routeFiles.forEach(file => {
  if (file.endsWith('.js')) {
    const filePath = path.join(routesDir, file);
    let routeContent = fs.readFileSync(filePath, 'utf8');
    routeContent = routeContent.replace(/FROM communities/g, 'FROM community');
    routeContent = routeContent.replace(/FROM community_members/g, 'FROM community_member');
    routeContent = routeContent.replace(/FROM posts/g, 'FROM post');
    routeContent = routeContent.replace(/FROM comments/g, 'FROM comment');
    routeContent = routeContent.replace(/FROM users/g, 'FROM user');
    routeContent = routeContent.replace(/FROM votes/g, 'FROM vote');
    routeContent = routeContent.replace(/INSERT INTO communities/g, 'INSERT INTO community');
    routeContent = routeContent.replace(/INSERT INTO community_members/g, 'INSERT INTO community_member');
    routeContent = routeContent.replace(/INSERT INTO posts/g, 'INSERT INTO post');
    routeContent = routeContent.replace(/INSERT INTO comments/g, 'INSERT INTO comment');
    routeContent = routeContent.replace(/INSERT INTO users/g, 'INSERT INTO user');
    routeContent = routeContent.replace(/INSERT INTO votes/g, 'INSERT INTO vote');
    routeContent = routeContent.replace(/UPDATE communities/g, 'UPDATE community');
    routeContent = routeContent.replace(/UPDATE community_members/g, 'UPDATE community_member');
    routeContent = routeContent.replace(/UPDATE posts/g, 'UPDATE post');
    routeContent = routeContent.replace(/UPDATE comments/g, 'UPDATE comment');
    routeContent = routeContent.replace(/UPDATE users/g, 'UPDATE user');
    routeContent = routeContent.replace(/UPDATE votes/g, 'UPDATE vote');
    routeContent = routeContent.replace(/DELETE FROM communities/g, 'DELETE FROM community');
    routeContent = routeContent.replace(/DELETE FROM community_members/g, 'DELETE FROM community_member');
    routeContent = routeContent.replace(/DELETE FROM posts/g, 'DELETE FROM post');
    routeContent = routeContent.replace(/DELETE FROM comments/g, 'DELETE FROM comment');
    routeContent = routeContent.replace(/DELETE FROM users/g, 'DELETE FROM user');
    routeContent = routeContent.replace(/DELETE FROM votes/g, 'DELETE FROM vote');
    fs.writeFileSync(filePath, routeContent, 'utf8');
    console.log(`Updated table names in routes/${file}`);
console.log('Database table name corrections completed');

================
File: backend/index.js
================
dotenv.config();
const app = express();
app.use(express.json());
app.use(cors()); // Enable CORS for all routes
    return this.toString();
const authenticateOptional = (req, res, next) => {
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    next();
    const user = require('./api/auth').verifyToken(token);
    console.error('Token validation error:', error.message);
const errorHandler = (err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(statusCode).json({
app.use('/api/auth/login', logUserLogin);
app.use('/api/auth/register', logUserRegistration);
app.use('/api/auth/logout', authenticateOptional, logUserLogout);
app.use('/api/auth', authRoutes.router);
app.use('/api/communities', authenticateOptional, communitiesRoutes.router);
app.use('/api/posts', authenticateOptional, postsRoutes.router);
app.use('/api/comments', authenticateOptional, commentsRoutes);
app.use('/api/users', authenticateOptional, usersRoutes);
app.use('/api/votes', authenticateOptional, votesRoutes);
app.use('/api/activity', authenticateToken, activityRoutes);
app.get('/', (req, res) => {
  res.send('Hello from Express backend!');
app.use(errorHandler);
app.use((req, res) => {
  res.status(404).json({
app.listen(port, () => {
  console.log(`Backend server listening at http://localhost:${port}`);

================
File: backend/index.ts
================
interface AuthRequest extends Request {
const authenticateToken = (req: AuthRequest, res: Response, next: NextFunction): void => {
const isCommunityModerator = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
const canViewCommunity = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
const canPostInCommunity = async (req: AuthRequest, res: Response, next: NextFunction): Promise<void> => {
app.post('/api/auth/register', async (req: Request, res: Response): Promise<void> => {
app.post('/api/auth/login', async (req: Request, res: Response): Promise<void> => {
app.get('/api/auth/me', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.get('/api/communities', async (req: Request, res: Response): Promise<void> => {
app.get('/api/communities/:id', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
app.post('/api/communities', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.put('/api/communities/:id', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
app.delete('/api/communities/:id', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
app.get('/api/communities/:id/rules', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
app.post('/api/communities/:id/rules', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
app.put('/api/communities/:id/rules/:ruleId', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
app.delete('/api/communities/:id/rules/:ruleId', authenticateToken, isCommunityModerator, async (req: AuthRequest, res: Response): Promise<void> => {
app.get('/api/communities/:id/settings', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
app.put('/api/communities/:id/settings', authenticateToken, isCommunityModerator, async (req: Request, res: Response, next: NextFunction): Promise<void> => {
app.get('/api/communities/:id/members', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
app.post('/api/communities/:id/members', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.put('/api/communities/:id/members/:userId', authenticateToken, isCommunityModerator, async (req: Request, res: Response): Promise<void> => {
app.delete('/api/communities/:id/members/:userId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.get('/api/communities/:id/about', canViewCommunity, async (req: Request, res: Response): Promise<void> => {
app.get('/api/users/:id/communities', async (req: Request, res: Response): Promise<void> => {
app.get('/api/posts', async (req: Request, res: Response): Promise<void> => {
app.get('/api/posts/:id', async (req: Request, res: Response): Promise<void> => {
app.post('/api/posts', authenticateToken, canPostInCommunity, async (req: AuthRequest, res: Response): Promise<void> => {
app.put('/api/posts/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.delete('/api/posts/:id', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.get('/', (req: Request, res: Response): void => {
app.get('/api/posts/:postId/comments', async (req: Request, res: Response): Promise<void> => {
app.get('/api/comments/:commentId', async (req: Request, res: Response): Promise<void> => {
app.post('/api/posts/:postId/comments', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.put('/api/comments/:commentId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.delete('/api/comments/:commentId', authenticateToken, async (req: AuthRequest, res: Response): Promise<void> => {
app.get('/api/comments/:commentId/replies', async (req: Request, res: Response): Promise<void> => {

================
File: backend/middleware/activity.js
================
function logActivityMiddleware(activityType, actionType, getEntityInfo) {
        return originalEnd.call(this, chunk, encoding);
              entityInfo = getEntityInfo(req, res) || entityInfo;
              console.error('Error extracting entity info:', entityError);
            logActivity({
            }).catch(error => {
              console.error('Error logging activity:', error);
          console.error('Error in activity middleware:', error);
    next();
function logUserLogin(req, res, next) {
            const responseBody = JSON.parse(chunk.toString());
            console.error('Error parsing response body:', parseError);
            console.error('Error logging login activity:', error);
        console.error('Error in login activity middleware:', error);
function logUserRegistration(req, res, next) {
            console.error('Error logging registration activity:', error);
        console.error('Error in registration activity middleware:', error);
function logUserLogout(req, res, next) {
      console.error('Error logging logout activity:', error);
    create: (req) => ({
    update: (req) => ({
    delete: (req) => ({
    create: (req) => {
    join: (req) => ({
    leave: (req) => ({

================
File: backend/middleware/auth.js
================
const authenticateToken = (req, res, next) => {
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    return res.status(401).json({ error: 'Access denied. No token provided.' });
    const user = jwt.verify(token, process.env.JWT_SECRET);
    next();
    return res.status(403).json({ error: 'Invalid token.' });

================
File: backend/middleware/moderation.js
================
const isCommunityModerator = async (req, res, next) => {
      return res.status(400).json({ error: 'Community ID is required' });
    const isModerator = await isUserModerator(communityId, userId);
      return res.status(403).json({ error: 'Only moderators can perform this action' });
    next();
    console.error('Error in moderator check middleware:', error);
    return res.status(500).json({ error: 'Server error checking moderator status' });
const hasPermission = (permission) => {
      const hasPermission = await hasModeratorPermission(communityId, userId, permission);
        return res.status(403).json({ error: 'You do not have permission to perform this action' });
      console.error(`Error in permission check middleware (${permission}):`, error);
      return res.status(500).json({ error: 'Server error checking permissions' });
const checkNotBanned = async (req, res, next) => {
    const isBanned = await isUserBanned(communityId, userId);
      return res.status(403).json({ error: 'You are banned from this community' });
    console.error('Error in ban check middleware:', error);
    return res.status(500).json({ error: 'Server error checking ban status' });

================
File: backend/middleware/moderation.js.new
================
// backend/middleware/moderation.js
const { isUserModerator, hasModeratorPermission, isUserBanned } = require('../api/moderation.ts.new');

// Middleware to check if a user is a moderator for a community
const isCommunityModerator = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isModerator = await isUserModerator(communityId, userId);
    
    if (!isModerator) {
      return res.status(403).json({ error: 'Only moderators can perform this action' });
    }
    
    next();
  } catch (error) {
    console.error('Error in moderator check middleware:', error);
    return res.status(500).json({ error: 'Server error checking moderator status' });
  }
};

// Middleware to check if a user has a specific moderator permission
const hasPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const { communityId } = req.params;
      const userId = req.user.id;
      
      if (!communityId) {
        return res.status(400).json({ error: 'Community ID is required' });
      }
      
      const hasPermission = await hasModeratorPermission(communityId, userId, permission);
      
      if (!hasPermission) {
        return res.status(403).json({ error: 'You do not have permission to perform this action' });
      }
      
      next();
    } catch (error) {
      console.error(`Error in permission check middleware (${permission}):`, error);
      return res.status(500).json({ error: 'Server error checking permissions' });
    }
  };
};

// Middleware to check if the user is banned from the community
const checkNotBanned = async (req, res, next) => {
  try {
    const { communityId } = req.params;
    const userId = req.user.id;
    
    if (!communityId) {
      return res.status(400).json({ error: 'Community ID is required' });
    }
    
    const isBanned = await isUserBanned(communityId, userId);
    
    if (isBanned) {
      return res.status(403).json({ error: 'You are banned from this community' });
    }
    
    next();
  } catch (error) {
    console.error('Error in ban check middleware:', error);
    return res.status(500).json({ error: 'Server error checking ban status' });
  }
};

module.exports = {
  isCommunityModerator,
  hasPermission,
  checkNotBanned
};

================
File: backend/package.json
================
{
  "name": "bolt-backend",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "node dist/index.js",
    "build": "tsc",
    "dev": "tsc --watch",
    "init-db": "node db/init.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@types/cors": "^2.8.17",
    "@types/uuid": "^10.0.0",
    "bcrypt": "^5.1.1",
    "bolt-backend": "file:",
    "cors": "^2.8.5",
    "dotenv": "^16.4.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "mariadb": "^3.2.4",
    "mysql2": "^3.12.0",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^5.0.0",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^20.12.8"
  }
}

================
File: backend/routes/activity.js
================
const router = express.Router();
router.use(authenticateToken);
router.get('/types', async (req, res) => {
    const activityTypes = await getActivityTypes();
    res.json(activityTypes);
    console.error('Error fetching activity types:', error);
    res.status(500).json({ error: 'Failed to fetch activity types' });
router.get('/actions', async (req, res) => {
    const actionTypes = await getActionTypes();
    res.json(actionTypes);
    console.error('Error fetching action types:', error);
    res.status(500).json({ error: 'Failed to fetch action types' });
router.get('/user/:userId', async (req, res) => {
      return res.status(403).json({ error: 'You can only view your own activities' });
    const activities = await getUserActivities(userId, options);
    res.json(activities);
    console.error('Error fetching user activities:', error);
    res.status(500).json({ error: 'Failed to fetch user activities' });
router.get('/me', async (req, res) => {
router.get('/community/:communityId', async (req, res) => {
    const conn = await pool.getConnection();
      const [membership] = await conn.query(
        return res.status(403).json({ error: 'You must be a member of this community to view its activities' });
      conn.release();
    const activities = await getCommunityActivities(communityId, options);
    console.error('Error fetching community activities:', error);
    res.status(500).json({ error: 'Failed to fetch community activities' });
router.get('/post/:postId', async (req, res) => {
    const activities = await getPostActivities(postId, options);
    console.error('Error fetching post activities:', error);
    res.status(500).json({ error: 'Failed to fetch post activities' });
router.post('/log', async (req, res) => {
      return res.status(403).json({ error: 'Only admins can manually log activities' });
      return res.status(400).json({ error: 'userId, activityType, and actionType are required' });
    const activity = await logActivity(activityData);
    res.status(201).json(activity);
    console.error('Error logging activity:', error);
    res.status(500).json({ error: 'Failed to log activity' });

================
File: backend/routes/auth.js
================
const router = express.Router();
const authenticateToken = (req, res, next) => {
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
        return res.status(401).json({ error: 'Authentication required' });
        const user = auth.verifyToken(token);
        next();
        return res.status(403).json({ error: 'Invalid or expired token' });
router.post('/register', async (req, res) => {
        return res.status(400).json({ error: 'Username, email, and password are required' });
        const result = await auth.register({ username, email, password });
        res.status(201).json(result);
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
router.post('/login', async (req, res) => {
        return res.status(400).json({ error: 'Username and password are required' });
        const result = await auth.login({ username, password });
        res.json(result);
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
router.post('/logout', authenticateToken, async (req, res) => {
        await auth.logout(req.user.id);
        res.json({ success: true, message: 'Logged out successfully' });
        console.error("Error logging out:", error);
        res.status(500).json({ error: error.message });
router.get('/me', authenticateToken, async (req, res) => {
        const user = await auth.getCurrentUser(req.user.id);
        res.json(user);
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });

================
File: backend/routes/auth.js.new
================
// Updated auth.js routes for the new database schema
const express = require('express');
const router = express.Router();
const auth = require('../api/auth.js');
const { logUserLogin, logUserRegistration, logUserLogout } = require('../middleware/activity');

// Authentication middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
    
    if (!token) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    
    try {
        const user = auth.verifyToken(token);
        req.user = user;
        next();
    } catch (error) {
        return res.status(403).json({ error: 'Invalid or expired token' });
    }
};

// Authentication routes
router.post('/register', async (req, res) => {
    const { username, email, password } = req.body;
    
    if (!username || !email || !password) {
        return res.status(400).json({ error: 'Username, email, and password are required' });
    }
    
    try {
        const result = await auth.register({ username, email, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.status(201).json(result);
    } catch (error) {
        console.error("Error registering user:", error);
        res.status(400).json({ error: error.message });
    }
});

router.post('/login', async (req, res) => {
    const { username, password } = req.body;
    
    if (!username || !password) {
        return res.status(400).json({ error: 'Username and password are required' });
    }
    
    try {
        const result = await auth.login({ username, password });
        
        // Get client info for activity logging
        const ipAddress = req.ip;
        const userAgent = req.headers['user-agent'];
        
        res.json(result);
    } catch (error) {
        console.error("Error logging in:", error);
        res.status(401).json({ error: error.message });
    }
});

router.post('/logout', authenticateToken, async (req, res) => {
    try {
        await auth.logout(req.user.id);
        
        res.json({ success: true, message: 'Logged out successfully' });
    } catch (error) {
        console.error("Error logging out:", error);
        res.status(500).json({ error: error.message });
    }
});

router.get('/me', authenticateToken, async (req, res) => {
    try {
        const user = await auth.getCurrentUser(req.user.id);
        res.json(user);
    } catch (error) {
        console.error("Error getting current user:", error);
        res.status(404).json({ error: error.message });
    }
});

module.exports = {
    router,
    authenticateToken
};

================
File: backend/routes/comments.js
================
const router = express.Router();
router.use(authenticateToken);
router.get('/posts/:postId', async (req, res) => {
            const threadedComments = await comments.getThreadedComments(postId);
            res.json(threadedComments);
            const allComments = await comments.getPostComments(postId);
            res.json(allComments);
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
router.get('/:commentId', async (req, res) => {
        const comment = await comments.getComment(commentId);
            return res.status(404).json({ error: 'Comment not found' });
        res.json(comment);
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
router.post('/posts/:postId', checkNotBanned, async (req, res) => {
        const newComment = await comments.createComment(userId, commentData);
        res.status(201).json(newComment);
        console.error("Error creating comment:", error);
            return res.status(404).json({ error: error.message });
        res.status(500).json({ error: 'Failed to create comment' });
router.put('/:commentId', async (req, res) => {
        const updatedComment = await comments.updateComment(commentId, userId, content);
        res.json(updatedComment);
        console.error("Error updating comment:", error);
            return res.status(403).json({ error: error.message });
        res.status(500).json({ error: 'Failed to update comment' });
router.delete('/:commentId', async (req, res) => {
        const success = await comments.deleteComment(commentId, userId);
        res.status(204).end();
        console.error("Error deleting comment:", error);
        res.status(500).json({ error: 'Failed to delete comment' });
router.get('/:commentId/replies', async (req, res) => {
        const replies = await comments.getCommentReplies(commentId);
        res.json(replies);
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
router.get('/user/:userId', async (req, res) => {
        const userComments = await comments.getUserComments(userId);
        res.json(userComments);
        console.error("Error fetching user comments:", error);
        res.status(500).json({ error: 'Failed to fetch user comments' });

================
File: backend/routes/comments.js.new
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const comments = require('../api/comments.js.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Get comments for a post (with optional threading)
router.get('/posts/:postId', async (req, res) => {
    const { postId } = req.params;
    try {
        const threaded = req.query.threaded === 'true';
        
        if (threaded) {
            const threadedComments = await comments.getThreadedComments(postId);
            res.json(threadedComments);
        } else {
            const allComments = await comments.getPostComments(postId);
            res.json(allComments);
        }
    } catch (error) {
        console.error("Error fetching comments:", error);
        res.status(500).json({ error: 'Failed to fetch comments' });
    }
});

// Get a specific comment
router.get('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    try {
        const comment = await comments.getComment(commentId);
        if (!comment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(comment);
    } catch (error) {
        console.error("Error fetching comment:", error);
        res.status(500).json({ error: 'Failed to fetch comment' });
    }
});

// Create a new comment
router.post('/posts/:postId', checkNotBanned, async (req, res) => {
    const { postId } = req.params;
    const { content, parentCommentId } = req.body;
    const userId = req.user.id;
    
    try {
        const commentData = {
            content,
            post_id: postId,
            parent_comment_id: parentCommentId
        };
        
        const newComment = await comments.createComment(userId, commentData);
        res.status(201).json(newComment);
    } catch (error) {
        console.error("Error creating comment:", error);
        if (error.message === 'Post not found' || error.message === 'Parent comment not found') {
            return res.status(404).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to create comment' });
    }
});

// Update a comment
router.put('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user.id;
    
    try {
        const updatedComment = await comments.updateComment(commentId, userId, content);
        if (!updatedComment) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.json(updatedComment);
    } catch (error) {
        console.error("Error updating comment:", error);
        if (error.message === 'You can only update your own comments') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to update comment' });
    }
});

// Delete a comment
router.delete('/:commentId', async (req, res) => {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    try {
        const success = await comments.deleteComment(commentId, userId);
        if (!success) {
            return res.status(404).json({ error: 'Comment not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting comment:", error);
        if (error.message === 'You can only delete your own comments or comments in communities you moderate') {
            return res.status(403).json({ error: error.message });
        }
        res.status(500).json({ error: 'Failed to delete comment' });
    }
});

// Get replies to a comment
router.get('/:commentId/replies', async (req, res) => {
    const { commentId } = req.params;
    try {
        const replies = await comments.getCommentReplies(commentId);
        res.json(replies);
    } catch (error) {
        console.error("Error fetching comment replies:", error);
        res.status(500).json({ error: 'Failed to fetch comment replies' });
    }
});

// Get comments for a specific user
router.get('/user/:userId', async (req, res) => {
    const { userId } = req.params;
    try {
        const userComments = await comments.getUserComments(userId);
        res.json(userComments);
    } catch (error) {
        console.error("Error fetching user comments:", error);
        res.status(500).json({ error: 'Failed to fetch user comments' });
    }
});

module.exports = router;

================
File: backend/routes/communities.js
================
const router = express.Router();
dotenv.config();
const isCommunityModerator = async (req, res, next) => {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            return res.status(403).json({ error: 'Moderator access required' });
        next();
        console.error("Error checking moderator status:", error);
        return res.status(500).json({ error: 'Failed to check moderator status' });
        if (conn) conn.release();
const canViewCommunity = async (req, res, next) => {
        const [community] = await conn.query(
            return res.status(404).json({ error: 'Community not found' });
            return next();
            return res.status(401).json({ error: 'Authentication required' });
            return res.status(403).json({ error: 'Membership required' });
        console.error("Error checking community access:", error);
        return res.status(500).json({ error: 'Failed to check community access' });
router.get('/', async (req, res) => {
            const communitiesList = await communityApi.searchCommunities(searchTerm);
            res.json(communitiesList);
            const allCommunities = await communityApi.getCommunities();
            res.json(allCommunities);
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
router.get('/:id', canViewCommunity, async (req, res) => {
        const community = await communityApi.getCommunity(id);
        res.json(community);
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
router.post('/', async (req, res) => {
        const newCommunity = await communityApi.createCommunity({ name, description, privacy });
        await communityApi.addCommunityMember(newCommunity.id, userId, 'moderator');
        res.status(201).json(newCommunity);
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
router.put('/:id', isCommunityModerator, async (req, res) => {
        const updatedCommunity = await communityApi.updateCommunity(id, { name, description, privacy });
        res.json(updatedCommunity);
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
router.delete('/:id', isCommunityModerator, async (req, res) => {
        const success = await communityApi.deleteCommunity(id);
        res.status(204).end();
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
router.get('/:id/rules', canViewCommunity, async (req, res) => {
        const rules = await communityApi.getCommunityRules(id);
        res.json(rules);
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
router.post('/:id/rules', isCommunityModerator, async (req, res) => {
        const newRule = await communityApi.addCommunityRule(id, { title, description });
        res.status(201).json(newRule);
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
router.put('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
        const updatedRule = await communityApi.updateCommunityRule(ruleId, { title, description });
            return res.status(404).json({ error: 'Rule not found' });
        res.json(updatedRule);
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
router.delete('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
        const success = await communityApi.deleteCommunityRule(ruleId);
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
router.get('/:id/settings', canViewCommunity, async (req, res) => {
        const settings = await communityApi.getCommunitySettings(id);
            return res.status(404).json({ error: 'Settings not found' });
        res.json(settings);
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
router.put('/:id/settings', isCommunityModerator, async (req, res) => {
        const updatedSettings = await communityApi.updateCommunitySettings(id, { 
        res.json(updatedSettings);
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
router.get('/:id/members', canViewCommunity, async (req, res) => {
        const members = await communityApi.getCommunityMembers(id);
        res.json(members);
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
router.get('/:id/members/:userId', async (req, res) => {
    console.log(`GET request for member: community ${id}, user ${userId}`);
        const member = await communityApi.getCommunityMember(id, userId);
        console.log("Member result:", member);
            return res.status(404).json({ error: 'Member not found' });
        res.json(member);
        console.error("Error fetching community member:", error);
        res.status(500).json({ error: 'Failed to fetch community member' });
router.post('/:id/members', async (req, res) => {
    console.log(`POST request for member: community ${id}, user ${userId}`);
        console.log("Community settings:", settings);
                console.log("Auto-approving join request");
                const newMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(newMember);
                console.log("Creating pending join request");
                const joinRequest = await communityApi.createJoinRequest(id, userId);
                return res.status(202).json({
                console.log("Rejecting invite-only join request");
                return res.status(403).json({ error: 'This community is invite-only' });
                console.log("Using fallback auto-approve method");
                const fallbackMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(fallbackMember);
        console.error("Error joining community:", error);
        res.status(500).json({ error: 'Failed to join community' });
router.put('/:id/members/:userId', isCommunityModerator, async (req, res) => {
        const updatedMember = await communityApi.updateCommunityMemberRole(id, userId, role);
        res.json(updatedMember);
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
router.delete('/:id/members', async (req, res) => {
    console.log(`DELETE request for current user to leave: community ${id}, user ${currentUserId}`);
        console.log(`Removing member ${currentUserId} from community ${id}`);
        const success = await communityApi.removeCommunityMember(id, currentUserId);
        console.log(`Successfully removed member ${currentUserId} from community ${id}`);
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
router.delete('/:id/members/:userId', async (req, res) => {
    console.log(`DELETE request for specific member: community ${id}, target user ${userId}, current user ${currentUserId}`);
                return res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
        console.log(`Removing member ${userId} from community ${id}`);
        const success = await communityApi.removeCommunityMember(id, userId);
        console.log(`Successfully removed member ${userId} from community ${id}`);
router.get('/:id/join-requests', isCommunityModerator, async (req, res) => {
        const requests = await communityApi.getJoinRequests(id);
        res.json(requests);
        console.error("Error fetching join requests:", error);
        res.status(500).json({ error: 'Failed to fetch join requests' });
router.get('/:id/join-requests/:requestId', isCommunityModerator, async (req, res) => {
        const request = await communityApi.getJoinRequest(requestId);
            return res.status(404).json({ error: 'Join request not found' });
        res.json(request);
        console.error("Error fetching join request:", error);
        res.status(500).json({ error: 'Failed to fetch join request' });
router.post('/:id/join-requests/:requestId/approve', isCommunityModerator, async (req, res) => {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'approved');
        res.status(200).json({ message: 'Join request approved' });
        console.error("Error approving join request:", error);
        res.status(500).json({ error: 'Failed to approve join request' });
router.post('/:id/join-requests/:requestId/reject', isCommunityModerator, async (req, res) => {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'rejected');
        res.status(200).json({ message: 'Join request rejected' });
        console.error("Error rejecting join request:", error);
        res.status(500).json({ error: 'Failed to reject join request' });
router.get('/:id/about', canViewCommunity, async (req, res) => {
        const about = await communityApi.getCommunity(id);
            member_count: await communityApi.getCommunityMemberCount(id)
        res.json(aboutInfo);
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
router.get('/users/:id', async (req, res) => {
        const userCommunities = await communityApi.getUserCommunities(id);
        res.json(userCommunities);
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
router.get('/discover/trending', async (req, res) => {
        const trendingCommunities = await communityApi.getTrendingCommunities();
        res.json(trendingCommunities);
        console.error("Error fetching trending communities:", error);
        res.status(500).json({ error: 'Failed to fetch trending communities' });
router.get('/discover/recommended', async (req, res) => {
        const recommendedCommunities = await communityApi.getRecommendedCommunities(userId);
        res.json(recommendedCommunities);
        console.error("Error fetching recommended communities:", error);
        res.status(500).json({ error: 'Failed to fetch recommended communities' });

================
File: backend/routes/communities.js.new
================
import express from 'express';
const router = express.Router();
import dotenv from 'dotenv';
import pool from '../db/connection.js';
import communityApi from '../api/community/index.js';

dotenv.config();

// Check if user is a community moderator
const isCommunityModerator = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user.id;
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Moderator access required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking moderator status:", error);
        return res.status(500).json({ error: 'Failed to check moderator status' });
    } finally {
        if (conn) conn.release();
    }
};

// Check if user can view a community (public or member of private)
const canViewCommunity = async (req, res, next) => {
    const communityId = req.params.id;
    const userId = req.user?.id; // Optional, might be unauthenticated
    
    let conn;
    try {
        conn = await pool.getConnection();
        const [community] = await conn.query(
            "SELECT * FROM community WHERE id = ?",
            [communityId]
        );
        
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Public communities are visible to everyone
        if (community.privacy === 'public') {
            return next();
        }
        
        // Private communities require membership
        if (!userId) {
            return res.status(401).json({ error: 'Authentication required' });
        }
        
        const [membership] = await conn.query(
            "SELECT * FROM community_member WHERE community_id = ? AND user_id = ?",
            [communityId, userId]
        );
        
        if (!membership) {
            return res.status(403).json({ error: 'Membership required' });
        }
        
        next();
    } catch (error) {
        console.error("Error checking community access:", error);
        return res.status(500).json({ error: 'Failed to check community access' });
    } finally {
        if (conn) conn.release();
    }
};

// Communities API
router.get('/', async (req, res) => {
    try {
        const searchTerm = req.query.search;
        
        if (searchTerm) {
            const communitiesList = await communityApi.searchCommunities(searchTerm);
            res.json(communitiesList);
        } else {
            const allCommunities = await communityApi.getCommunities();
            res.json(allCommunities);
        }
    } catch (error) {
        console.error("Error fetching communities:", error);
        res.status(500).json({ error: 'Failed to fetch communities' });
    }
});

router.get('/:id', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const community = await communityApi.getCommunity(id);
        if (!community) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(community);
    } catch (error) {
        console.error("Error fetching community:", error);
        res.status(500).json({ error: 'Failed to fetch community' });
    }
});

router.post('/', async (req, res) => {
    const { name, description, privacy } = req.body;
    const userId = req.user.id;
    
    try {
        // Create the community
        const newCommunity = await communityApi.createCommunity({ name, description, privacy });
        
        // Add the creator as a moderator
        await communityApi.addCommunityMember(newCommunity.id, userId, 'moderator');
        
        // Activity logging is now handled within the community API functions
        
        res.status(201).json(newCommunity);
    } catch (error) {
        console.error("Error creating community:", error);
        res.status(500).json({ error: 'Failed to create community' });
    }
});

router.put('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { name, description, privacy } = req.body;
    try {
        const updatedCommunity = await communityApi.updateCommunity(id, { name, description, privacy });
        if (!updatedCommunity) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.json(updatedCommunity);
    } catch (error) {
        console.error("Error updating community:", error);
        res.status(500).json({ error: 'Failed to update community' });
    }
});

router.delete('/:id', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const success = await communityApi.deleteCommunity(id);
        if (!success) {
            return res.status(404).json({ error: 'Community not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community:", error);
        res.status(500).json({ error: 'Failed to delete community' });
    }
});

// Community Rules API
router.get('/:id/rules', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const rules = await communityApi.getCommunityRules(id);
        res.json(rules);
    } catch (error) {
        console.error("Error fetching community rules:", error);
        res.status(500).json({ error: 'Failed to fetch community rules' });
    }
});

router.post('/:id/rules', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { title, description } = req.body;
    try {
        const newRule = await communityApi.addCommunityRule(id, { title, description });
        res.status(201).json(newRule);
    } catch (error) {
        console.error("Error adding community rule:", error);
        res.status(500).json({ error: 'Failed to add community rule' });
    }
});

router.put('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    const { title, description } = req.body;
    try {
        const updatedRule = await communityApi.updateCommunityRule(ruleId, { title, description });
        if (!updatedRule) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.json(updatedRule);
    } catch (error) {
        console.error("Error updating community rule:", error);
        res.status(500).json({ error: 'Failed to update community rule' });
    }
});

router.delete('/:id/rules/:ruleId', isCommunityModerator, async (req, res) => {
    const { ruleId } = req.params;
    try {
        const success = await communityApi.deleteCommunityRule(ruleId);
        if (!success) {
            return res.status(404).json({ error: 'Rule not found' });
        }
        res.status(204).end();
    } catch (error) {
        console.error("Error deleting community rule:", error);
        res.status(500).json({ error: 'Failed to delete community rule' });
    }
});

// Community Settings API
router.get('/:id/settings', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const settings = await communityApi.getCommunitySettings(id);
        if (!settings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        res.json(settings);
    } catch (error) {
        console.error("Error fetching community settings:", error);
        res.status(500).json({ error: 'Failed to fetch community settings' });
    }
});

router.put('/:id/settings', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    const { 
        allow_post_images, 
        allow_post_links, 
        join_method,
        require_post_approval,
        restricted_words,
        custom_theme_color,
        custom_banner_url,
        minimum_account_age_days,
        minimum_karma_required
    } = req.body;
    
    try {
        const updatedSettings = await communityApi.updateCommunitySettings(id, { 
            allow_post_images, 
            allow_post_links,
            join_method,
            require_post_approval,
            restricted_words,
            custom_theme_color,
            custom_banner_url,
            minimum_account_age_days,
            minimum_karma_required
        });
        
        if (!updatedSettings) {
            return res.status(404).json({ error: 'Settings not found' });
        }
        
        res.json(updatedSettings);
    } catch (error) {
        console.error("Error updating community settings:", error);
        res.status(500).json({ error: 'Failed to update community settings' });
    }
});

// Community Members API
router.get('/:id/members', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const members = await communityApi.getCommunityMembers(id);
        res.json(members);
    } catch (error) {
        console.error("Error fetching community members:", error);
        res.status(500).json({ error: 'Failed to fetch community members' });
    }
});

// Get a specific member
router.get('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    console.log(`GET request for member: community ${id}, user ${userId}`);
    
    try {
        const member = await communityApi.getCommunityMember(id, userId);
        console.log("Member result:", member);
        
        if (!member) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        res.json(member);
    } catch (error) {
        console.error("Error fetching community member:", error);
        res.status(500).json({ error: 'Failed to fetch community member' });
    }
});

router.post('/:id/members', async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id; // User joins themselves
    console.log(`POST request for member: community ${id}, user ${userId}`);
    
    try {
        // Get community settings to check join method
        const settings = await communityApi.getCommunitySettings(id);
        
        if (!settings) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        console.log("Community settings:", settings);
        
        // Handle based on join method
        switch (settings.join_method) {
            case 'auto_approve':
                console.log("Auto-approving join request");
                // Directly add as member
                const newMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(newMember);
                
            case 'requires_approval':
                console.log("Creating pending join request");
                // Create a join request
                const joinRequest = await communityApi.createJoinRequest(id, userId);
                return res.status(202).json({
                    message: 'Join request submitted for approval',
                    request: joinRequest
                });
                
            case 'invite_only':
                console.log("Rejecting invite-only join request");
                return res.status(403).json({ error: 'This community is invite-only' });
                
            default:
                console.log("Using fallback auto-approve method");
                // Fallback to auto-approve for any unexpected values
                const fallbackMember = await communityApi.addCommunityMember(id, userId, 'member');
                return res.status(201).json(fallbackMember);
        }
    } catch (error) {
        console.error("Error joining community:", error);
        res.status(500).json({ error: 'Failed to join community' });
    }
});

router.put('/:id/members/:userId', isCommunityModerator, async (req, res) => {
    const { id, userId } = req.params;
    const { role } = req.body;
    try {
        const updatedMember = await communityApi.updateCommunityMemberRole(id, userId, role);
        if (!updatedMember) {
            return res.status(404).json({ error: 'Member not found' });
        }
        res.json(updatedMember);
    } catch (error) {
        console.error("Error updating community member role:", error);
        res.status(500).json({ error: 'Failed to update community member role' });
    }
});

router.delete('/:id/members', async (req, res) => {
    const { id } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for current user to leave: community ${id}, user ${currentUserId}`);
    
    try {
        console.log(`Removing member ${currentUserId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, currentUserId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${currentUserId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

router.delete('/:id/members/:userId', async (req, res) => {
    const { id, userId } = req.params;
    const currentUserId = req.user.id;
    
    console.log(`DELETE request for specific member: community ${id}, target user ${userId}, current user ${currentUserId}`);
    
    // Check if user is removing themselves or is a moderator
    if (userId !== currentUserId) {
        let conn;
        try {
            conn = await pool.getConnection();
            const [membership] = await conn.query(
                "SELECT * FROM community_member WHERE community_id = ? AND user_id = ? AND role IN ('moderator', 'admin')",
                [id, currentUserId]
            );
            
            if (!membership) {
                return res.status(403).json({ error: 'You can only remove yourself unless you are a moderator' });
            }
        } catch (error) {
            console.error("Error checking moderator status:", error);
            return res.status(500).json({ error: 'Failed to check moderator status' });
        } finally {
            if (conn) conn.release();
        }
    }
    
    try {
        console.log(`Removing member ${userId} from community ${id}`);
        
        const success = await communityApi.removeCommunityMember(id, userId);
        
        if (!success) {
            return res.status(404).json({ error: 'Member not found' });
        }
        
        console.log(`Successfully removed member ${userId} from community ${id}`);
        res.status(204).end();
    } catch (error) {
        console.error("Error removing community member:", error);
        res.status(500).json({ error: 'Failed to remove community member' });
    }
});

// Join Requests API
router.get('/:id/join-requests', isCommunityModerator, async (req, res) => {
    const { id } = req.params;
    try {
        const requests = await communityApi.getJoinRequests(id);
        res.json(requests);
    } catch (error) {
        console.error("Error fetching join requests:", error);
        res.status(500).json({ error: 'Failed to fetch join requests' });
    }
});

router.get('/:id/join-requests/:requestId', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const request = await communityApi.getJoinRequest(requestId);
        if (!request) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.json(request);
    } catch (error) {
        console.error("Error fetching join request:", error);
        res.status(500).json({ error: 'Failed to fetch join request' });
    }
});

router.post('/:id/join-requests/:requestId/approve', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'approved');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request approved' });
    } catch (error) {
        console.error("Error approving join request:", error);
        res.status(500).json({ error: 'Failed to approve join request' });
    }
});

router.post('/:id/join-requests/:requestId/reject', isCommunityModerator, async (req, res) => {
    const { requestId } = req.params;
    try {
        const success = await communityApi.updateJoinRequestStatus(requestId, 'rejected');
        if (!success) {
            return res.status(404).json({ error: 'Join request not found' });
        }
        res.status(200).json({ message: 'Join request rejected' });
    } catch (error) {
        console.error("Error rejecting join request:", error);
        res.status(500).json({ error: 'Failed to reject join request' });
    }
});

// Community About API
router.get('/:id/about', canViewCommunity, async (req, res) => {
    const { id } = req.params;
    try {
        const about = await communityApi.getCommunity(id);
        if (!about) {
            return res.status(404).json({ error: 'Community not found' });
        }
        
        // Format the response to include only the about information
        const aboutInfo = {
            id: about.id,
            name: about.name,
            description: about.description,
            privacy: about.privacy,
            created_at: about.created_at,
            member_count: await communityApi.getCommunityMemberCount(id)
        };
        
        res.json(aboutInfo);
    } catch (error) {
        console.error("Error fetching community about:", error);
        res.status(500).json({ error: 'Failed to fetch community about' });
    }
});

// User Communities API
router.get('/users/:id', async (req, res) => {
    const { id } = req.params;
    try {
        const userCommunities = await communityApi.getUserCommunities(id);
        res.json(userCommunities);
    } catch (error) {
        console.error("Error fetching user communities:", error);
        res.status(500).json({ error: 'Failed to fetch user communities' });
    }
});

// Discover Communities API
router.get('/discover/trending', async (req, res) => {
    try {
        const trendingCommunities = await communityApi.getTrendingCommunities();
        res.json(trendingCommunities);
    } catch (error) {
        console.error("Error fetching trending communities:", error);
        res.status(500).json({ error: 'Failed to fetch trending communities' });
    }
});

router.get('/discover/recommended', async (req, res) => {
    const userId = req.user?.id;
    try {
        const recommendedCommunities = await communityApi.getRecommendedCommunities(userId);
        res.json(recommendedCommunities);
    } catch (error) {
        console.error("Error fetching recommended communities:", error);
        res.status(500).json({ error: 'Failed to fetch recommended communities' });
    }
});

export {
    router,
    canViewCommunity,
    isCommunityModerator
};

================
File: backend/routes/moderation.js
================
const router = express.Router();
router.use(authenticateToken);
router.get('/communities/:communityId/moderator-permissions/:userId', 
      const permissions = await getModeratorPermissions(communityId, userId);
      res.json(permissions || { message: 'No specific permissions found' });
      console.error('Error fetching moderator permissions:', error);
      res.status(500).json({ error: 'Failed to fetch moderator permissions' });
router.post('/communities/:communityId/moderator-permissions/:userId', 
  hasPermission('can_manage_members'),
      const updatedPermissions = await setModeratorPermissions(communityId, userId, permissions);
      res.json(updatedPermissions);
      console.error('Error setting moderator permissions:', error);
      res.status(500).json({ error: 'Failed to set moderator permissions' });
router.get('/communities/:communityId/settings', 
      const settings = await getEnhancedCommunitySettings(communityId);
      res.json(settings);
      console.error('Error fetching community settings:', error);
      res.status(500).json({ error: 'Failed to fetch community settings' });
router.put('/communities/:communityId/settings', 
  hasPermission('can_manage_settings'),
      const updatedSettings = await updateEnhancedCommunitySettings(communityId, settings);
      res.json(updatedSettings);
      console.error('Error updating community settings:', error);
      res.status(500).json({ error: 'Failed to update community settings' });
router.get('/communities/:communityId/mod-queue', 
  hasPermission('can_manage_posts'),
      const pendingPosts = await getPendingModQueue(communityId);
      res.json(pendingPosts);
      console.error('Error fetching moderation queue:', error);
      res.status(500).json({ error: 'Failed to fetch moderation queue' });
router.post('/posts/:postId/moderate', 
      const communityId = await getCommunityIdFromPost(postId);
        return res.status(404).json({ error: 'Post not found' });
      const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
        return res.status(403).json({ error: 'You do not have permission to moderate posts' });
        return res.status(400).json({ error: 'Invalid action. Must be "approve" or "reject"' });
      const result = await moderatePost(postId, userId, action, reason);
      res.json(result);
      console.error('Error moderating post:', error);
      res.status(500).json({ error: 'Failed to moderate post' });
router.get('/communities/:communityId/logs', 
      const logs = await getModerationLogs(communityId, parseInt(limit), parseInt(offset));
      res.json(logs);
      console.error('Error fetching moderation logs:', error);
      res.status(500).json({ error: 'Failed to fetch moderation logs' });
router.get('/communities/:communityId/banned-users', 
      const bannedUsers = await getBannedUsers(communityId);
      res.json(bannedUsers);
      console.error('Error fetching banned users:', error);
      res.status(500).json({ error: 'Failed to fetch banned users' });
router.post('/communities/:communityId/ban/:userId', 
      const ban = await banUserFromCommunity(communityId, userId, bannedBy, reason, duration);
      res.json(ban);
      console.error('Error banning user:', error);
      res.status(500).json({ error: 'Failed to ban user' });
router.post('/communities/:communityId/unban/:userId', 
      const result = await unbanUserFromCommunity(communityId, userId, unbannedBy, reason);
        res.json({ message: 'User has been unbanned' });
        res.status(404).json({ message: 'User was not banned' });
      console.error('Error unbanning user:', error);
      res.status(500).json({ error: 'Failed to unban user' });
router.post('/communities/:communityId/members/:userId', 
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      const member = await addCommunityMember(communityId, userId, role);
        await setModeratorPermissions(communityId, userId, {
      res.json(member);
      console.error('Error adding community member:', error);
      res.status(500).json({ error: 'Failed to add community member' });
router.put('/communities/:communityId/members/:userId', 
      const member = await updateCommunityMemberRole(communityId, userId, role);
      console.error('Error updating community member role:', error);
      res.status(500).json({ error: 'Failed to update community member role' });

================
File: backend/routes/moderation.js.new
================
// backend/routes/moderation.js
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { isCommunityModerator, hasPermission } = require('../middleware/moderation');
const {
  // Moderator permissions
  getModeratorPermissions,
  setModeratorPermissions,
  
  // Community settings
  getEnhancedCommunitySettings,
  updateEnhancedCommunitySettings,
  
  // Post moderation
  getPostModerationStatus,
  addPostToModQueue,
  moderatePost,
  getPendingModQueue,
  
  // Moderation logs
  getModerationLogs,
  
  // Banning
  banUserFromCommunity,
  unbanUserFromCommunity,
  getBannedUsers
} = require('../api/moderation.ts.new');

// Middleware to ensure routes are protected
router.use(authenticateToken);

// Moderator permissions routes
router.get('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = await getModeratorPermissions(communityId, userId);
      res.json(permissions || { message: 'No specific permissions found' });
    } catch (error) {
      console.error('Error fetching moderator permissions:', error);
      res.status(500).json({ error: 'Failed to fetch moderator permissions' });
    }
  }
);

router.post('/communities/:communityId/moderator-permissions/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const permissions = req.body;
      
      const updatedPermissions = await setModeratorPermissions(communityId, userId, permissions);
      res.json(updatedPermissions);
    } catch (error) {
      console.error('Error setting moderator permissions:', error);
      res.status(500).json({ error: 'Failed to set moderator permissions' });
    }
  }
);

// Community settings routes
router.get('/communities/:communityId/settings', 
  authenticateToken,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = await getEnhancedCommunitySettings(communityId);
      res.json(settings);
    } catch (error) {
      console.error('Error fetching community settings:', error);
      res.status(500).json({ error: 'Failed to fetch community settings' });
    }
  }
);

router.put('/communities/:communityId/settings', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_settings'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const settings = req.body;
      
      const updatedSettings = await updateEnhancedCommunitySettings(communityId, settings);
      res.json(updatedSettings);
    } catch (error) {
      console.error('Error updating community settings:', error);
      res.status(500).json({ error: 'Failed to update community settings' });
    }
  }
);

// Post moderation routes
router.get('/communities/:communityId/mod-queue', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_posts'),
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const pendingPosts = await getPendingModQueue(communityId);
      res.json(pendingPosts);
    } catch (error) {
      console.error('Error fetching moderation queue:', error);
      res.status(500).json({ error: 'Failed to fetch moderation queue' });
    }
  }
);

router.post('/posts/:postId/moderate', 
  authenticateToken,
  async (req, res) => {
    try {
      const { postId } = req.params;
      const { action, reason } = req.body;
      const userId = req.user.id;
      
      // Get community ID from the post to check permissions
      const { getCommunityIdFromPost } = require('../api/community/community-core');
      const communityId = await getCommunityIdFromPost(postId);
      
      if (!communityId) {
        return res.status(404).json({ error: 'Post not found' });
      }
      
      // Check if user is a moderator with post management permissions
      const canManagePosts = await hasModeratorPermission(communityId, userId, 'can_manage_posts');
      
      if (!canManagePosts) {
        return res.status(403).json({ error: 'You do not have permission to moderate posts' });
      }
      
      if (action !== 'approve' && action !== 'reject') {
        return res.status(400).json({ error: 'Invalid action. Must be "approve" or "reject"' });
      }
      
      const result = await moderatePost(postId, userId, action, reason);
      res.json(result);
    } catch (error) {
      console.error('Error moderating post:', error);
      res.status(500).json({ error: 'Failed to moderate post' });
    }
  }
);

// Moderation logs routes
router.get('/communities/:communityId/logs', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const { limit = 50, offset = 0 } = req.query;
      
      const logs = await getModerationLogs(communityId, parseInt(limit), parseInt(offset));
      res.json(logs);
    } catch (error) {
      console.error('Error fetching moderation logs:', error);
      res.status(500).json({ error: 'Failed to fetch moderation logs' });
    }
  }
);

// User ban routes
router.get('/communities/:communityId/banned-users', 
  authenticateToken,
  isCommunityModerator,
  async (req, res) => {
    try {
      const { communityId } = req.params;
      const bannedUsers = await getBannedUsers(communityId);
      res.json(bannedUsers);
    } catch (error) {
      console.error('Error fetching banned users:', error);
      res.status(500).json({ error: 'Failed to fetch banned users' });
    }
  }
);

router.post('/communities/:communityId/ban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason, duration } = req.body; // duration in days
      const bannedBy = req.user.id;
      
      const ban = await banUserFromCommunity(communityId, userId, bannedBy, reason, duration);
      res.json(ban);
    } catch (error) {
      console.error('Error banning user:', error);
      res.status(500).json({ error: 'Failed to ban user' });
    }
  }
);

router.post('/communities/:communityId/unban/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { reason } = req.body;
      const unbannedBy = req.user.id;
      
      const result = await unbanUserFromCommunity(communityId, userId, unbannedBy, reason);
      
      if (result) {
        res.json({ message: 'User has been unbanned' });
      } else {
        res.status(404).json({ message: 'User was not banned' });
      }
    } catch (error) {
      console.error('Error unbanning user:', error);
      res.status(500).json({ error: 'Failed to unban user' });
    }
  }
);

// Add community member route with role assignment
router.post('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { addCommunityMember } = require('../api/community/community-members');
      const member = await addCommunityMember(communityId, userId, role);
      
      // If setting as moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error adding community member:', error);
      res.status(500).json({ error: 'Failed to add community member' });
    }
  }
);

// Update community member role
router.put('/communities/:communityId/members/:userId', 
  authenticateToken,
  isCommunityModerator,
  hasPermission('can_manage_members'),
  async (req, res) => {
    try {
      const { communityId, userId } = req.params;
      const { role } = req.body;
      
      if (!['member', 'moderator', 'admin'].includes(role)) {
        return res.status(400).json({ error: 'Invalid role. Must be "member", "moderator", or "admin"' });
      }
      
      const { updateCommunityMemberRole } = require('../api/community/community-members');
      const member = await updateCommunityMemberRole(communityId, userId, role);
      
      // If promoting to moderator, set default permissions
      if (role === 'moderator') {
        await setModeratorPermissions(communityId, userId, {
          can_manage_posts: true,
          can_manage_comments: true
        });
      }
      
      res.json(member);
    } catch (error) {
      console.error('Error updating community member role:', error);
      res.status(500).json({ error: 'Failed to update community member role' });
    }
  }
);

module.exports = router;

================
File: backend/routes/posts.js
================
const router = express.Router();
router.use(authenticateToken);
router.get('/', async (req, res) => {
  await posts.getPosts(req, res);
router.get('/:id', async (req, res) => {
  await posts.getPost(req, res);
router.get('/community/:communityId', checkNotBanned, async (req, res) => {
  await posts.getCommunityPosts(req, res);
router.get('/user/:userId', async (req, res) => {
  await posts.getUserPosts(req, res);
router.post('/', authenticateToken, posts.canPostInCommunity, async (req, res) => {
  await posts.createPost(req, res);
router.put('/:id', authenticateToken, async (req, res) => {
  await posts.updatePost(req, res);
router.delete('/:id', authenticateToken, async (req, res) => {
  await posts.deletePost(req, res);

================
File: backend/routes/posts.js.new
================
const express = require('express');
const router = express.Router();
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');
const posts = require('../api/posts.js.new');

// Middleware to check if the user is authenticated for protected routes
router.use(authenticateToken);

// Get all posts (with optional filtering)
router.get('/', async (req, res) => {
  await posts.getPosts(req, res);
});

// Get a specific post by ID
router.get('/:id', async (req, res) => {
  await posts.getPost(req, res);
});

// Get posts for a specific community
router.get('/community/:communityId', checkNotBanned, async (req, res) => {
  req.params.communityId = req.params.communityId;
  await posts.getCommunityPosts(req, res);
});

// Get posts for a specific user
router.get('/user/:userId', async (req, res) => {
  await posts.getUserPosts(req, res);
});

// Create a new post
router.post('/', authenticateToken, posts.canPostInCommunity, async (req, res) => {
  await posts.createPost(req, res);
});

// Update a post
router.put('/:id', authenticateToken, async (req, res) => {
  await posts.updatePost(req, res);
});

// Delete a post
router.delete('/:id', authenticateToken, async (req, res) => {
  await posts.deletePost(req, res);
});

module.exports = router;

================
File: backend/routes/users.js
================
const router = express.Router();
router.get('/', async (req, res) => {
    const connection = await pool.getConnection();
      const [rows] = await connection.execute(
      const users = rows.map(user => {
      res.json(users);
      connection.release();
    console.error('Error fetching users:', error);
    res.status(500).json({ error: 'Internal server error' });
router.get('/:userId', async (req, res) => {
        return res.status(404).json({ error: 'User not found' });
      res.json(user);
    console.error('Error fetching user:', error);
router.put('/profile', authenticateToken, async (req, res) => {
      return res.status(400).json({ error: 'Username and email are required' });
      const [existingUsers] = await connection.execute(
        return res.status(400).json({ error: 'Username is already taken' });
      await connection.execute(
        [uuidv4(), userId, userId]
    console.error('Error updating user profile:', error);
router.get('/:userId/statistics', async (req, res) => {
        return res.status(404).json({ error: 'User statistics not found' });
      res.json(rows[0]);
    console.error('Error fetching user statistics:', error);
router.get('/settings', authenticateToken, async (req, res) => {
        return res.json(defaultSettings);
      res.json(settings);
    console.error('Error fetching user settings:', error);
router.put('/settings', authenticateToken, async (req, res) => {
      const [existingSettings] = await connection.execute(
    console.error('Error updating user settings:', error);
router.get('/:userId/friends', async (req, res) => {
      res.json(rows);
    console.error('Error fetching user friends:', error);
router.post('/friends/:targetUserId', authenticateToken, async (req, res) => {
      return res.status(400).json({ error: 'Cannot add yourself as a friend' });
      const [existingRelationship] = await connection.execute(
        return res.status(400).json({ 
      const relationshipId = uuidv4();
        [uuidv4(), userId, relationshipId]
      res.status(201).json({ message: 'Friend request sent' });
    console.error('Error sending friend request:', error);
router.put('/friends/:relationshipId', authenticateToken, async (req, res) => {
      return res.status(400).json({ error: 'Invalid status' });
      const [relationship] = await connection.execute(
        return res.status(404).json({ error: 'Friend request not found' });
      res.json({ message: `Friend request ${status}` });
    console.error('Error updating friend request:', error);
router.delete('/friends/:targetUserId', authenticateToken, async (req, res) => {
        [uuidv4(), userId, targetUserId]
      res.json({ message: 'Friend removed' });
    console.error('Error removing friend:', error);
router.get('/lookup/:username', async (req, res) => {
      res.json({ id: rows[0].id });
    console.error('Error looking up user:', error);
router.get('/:userId/communities', async (req, res) => {
    console.error('Error fetching user communities:', error);
router.get('/:userId/activities', async (req, res) => {
    console.error('Error fetching user activities:', error);

================
File: backend/routes/votes.js
================
const router = express.Router();
router.post('/posts/:postId', authenticateToken, checkNotBanned, async (req, res) => {
    const result = await voteOnPost(userId, postId, value);
    res.json(result);
    console.error('Error voting on post:', error);
    res.status(400).json({ error: error.message });
router.post('/comments/:commentId', authenticateToken, checkNotBanned, async (req, res) => {
    const result = await voteOnComment(userId, commentId, value);
    console.error('Error voting on comment:', error);
router.get('/posts/:postId/user', authenticateToken, async (req, res) => {
    const value = await getUserPostVote(userId, postId);
    res.json({ value });
    console.error('Error getting user post vote:', error);
router.get('/comments/:commentId/user', authenticateToken, async (req, res) => {
    const value = await getUserCommentVote(userId, commentId);
    console.error('Error getting user comment vote:', error);
router.get('/posts/:postId/counts', async (req, res) => {
    const counts = await getPostVoteCounts(postId);
    res.json(counts);
    console.error('Error getting post vote counts:', error);
router.get('/comments/:commentId/counts', async (req, res) => {
    const counts = await getCommentVoteCounts(commentId);
    console.error('Error getting comment vote counts:', error);
router.get('/user/:userId', authenticateToken, async (req, res) => {
      return res.status(403).json({ error: 'You can only view your own votes' });
    const votes = await getUserVotes(userId);
    res.json(votes);
    console.error('Error getting user votes:', error);
router.get('/user', authenticateToken, async (req, res) => {

================
File: backend/routes/votes.js.new
================
const express = require('express');
const router = express.Router();
const { 
  voteOnPost, 
  voteOnComment, 
  getUserPostVote, 
  getUserCommentVote,
  getPostVoteCounts,
  getCommentVoteCounts,
  getUserVotes
} = require('../api/votes.js.new');

// Middleware for authentication and ban checking
const { authenticateToken } = require('../middleware/auth');
const { checkNotBanned } = require('../middleware/moderation');

// Vote on a post
router.post('/posts/:postId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { postId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnPost(userId, postId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on post:', error);
    res.status(400).json({ error: error.message });
  }
});

// Vote on a comment
router.post('/comments/:commentId', authenticateToken, checkNotBanned, async (req, res) => {
  try {
    const { commentId } = req.params;
    const { value } = req.body;
    const userId = req.user.id;
    
    const result = await voteOnComment(userId, commentId, value);
    res.json(result);
  } catch (error) {
    console.error('Error voting on comment:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a post
router.get('/posts/:postId/user', authenticateToken, async (req, res) => {
  try {
    const { postId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserPostVote(userId, postId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user post vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get user's vote on a comment
router.get('/comments/:commentId/user', authenticateToken, async (req, res) => {
  try {
    const { commentId } = req.params;
    const userId = req.user.id;
    
    const value = await getUserCommentVote(userId, commentId);
    res.json({ value });
  } catch (error) {
    console.error('Error getting user comment vote:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a post
router.get('/posts/:postId/counts', async (req, res) => {
  try {
    const { postId } = req.params;
    
    const counts = await getPostVoteCounts(postId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting post vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get vote counts for a comment
router.get('/comments/:commentId/counts', async (req, res) => {
  try {
    const { commentId } = req.params;
    
    const counts = await getCommentVoteCounts(commentId);
    res.json(counts);
  } catch (error) {
    console.error('Error getting comment vote counts:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get all votes for a user
router.get('/user/:userId', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;
    
    // Check if the user is requesting their own votes
    if (userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'You can only view your own votes' });
    }
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

// Get current user's votes
router.get('/user', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.id;
    
    const votes = await getUserVotes(userId);
    res.json(votes);
  } catch (error) {
    console.error('Error getting user votes:', error);
    res.status(400).json({ error: error.message });
  }
});

module.exports = router;

================
File: backend/test-api.js
================
require('dotenv').config();
const app = express();
app.use(express.json());
app.use(cors());
const createConnection = async () => {
  return mysql.createConnection({
app.get('/', (req, res) => {
  res.json({ status: 'API is running' });
app.get('/api/communities', async (req, res) => {
    const conn = await createConnection();
    const [communities] = await conn.query('SELECT * FROM community');
    await conn.end();
    res.json(communities);
    console.error('Error fetching communities:', error);
    res.status(500).json({ error: 'Failed to fetch communities' });
app.get('/api/communities/:id', async (req, res) => {
    const [communities] = await conn.query('SELECT * FROM community WHERE id = ?', [id]);
      return res.status(404).json({ error: 'Community not found' });
    res.json(communities[0]);
    console.error('Error fetching community:', error);
    res.status(500).json({ error: 'Failed to fetch community' });
app.get('/api/communities/:id/members', async (req, res) => {
    const [members] = await conn.query(
    res.json(members);
    console.error('Error fetching community members:', error);
    res.status(500).json({ error: 'Failed to fetch community members' });
app.get('/api/communities/:id/rules', async (req, res) => {
    const [rules] = await conn.query('SELECT * FROM community_rule WHERE community_id = ?', [id]);
    res.json(rules);
    console.error('Error fetching community rules:', error);
    res.status(500).json({ error: 'Failed to fetch community rules' });
app.get('/api/communities/:id/settings', async (req, res) => {
    const [settings] = await conn.query('SELECT * FROM community_setting WHERE community_id = ?', [id]);
      return res.status(404).json({ error: 'Settings not found' });
    res.json(settings[0]);
    console.error('Error fetching community settings:', error);
    res.status(500).json({ error: 'Failed to fetch community settings' });
app.get('/api/posts', async (req, res) => {
      return res.status(400).json({ error: 'Community ID required' });
    const [posts] = await conn.query(
    res.json(posts);
    console.error('Error fetching posts:', error);
    res.status(500).json({ error: 'Failed to fetch posts' });
app.get('/api/auth/me', (req, res) => {
  res.json({
app.get('/api/activity/community/:id', (req, res) => {
  res.json([]);
app.listen(PORT, () => {
  console.log(`Test API server running on port ${PORT}`);

================
File: backend/testServer.js
================
const app = express();
app.use(express.json());
app.use(cors());
app.get('/api/test', async (req, res) => {
    const connection = await pool.getConnection();
    const [rows] = await connection.query('SELECT 1 as test');
    connection.release();
    res.json({ message: 'Database connection successful', data: rows });
    console.error('Database connection error:', error);
    res.status(500).json({ error: 'Database connection failed', details: error.message });
app.get('/api/communities', async (req, res) => {
      [rows] = await connection.query('SELECT * FROM community');
      [rows] = await connection.query('SELECT * FROM communities');
    res.json(rows);
    console.error('Error fetching communities:', error);
    res.status(500).json({ error: 'Failed to fetch communities', details: error.message });
app.get('/api/auth/me', (req, res) => {
  res.json({
app.listen(port, () => {
  console.log(`Backend test server is running on http://localhost:${port}`);

================
File: backend/tsconfig.json
================
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["*.ts", "api/**/*.ts", "db/**/*.ts", "middleware/**/*.ts", "routes/**/*.ts", "types/**/*.ts"],
  "files": ["index.ts"]
}

================
File: backend/types/index.ts
================
export interface ActivityOptions {
export interface ActivityData {
export interface Activity {
  created_at: Date;
export interface ActivityType {
export interface ActionType {
export interface ModeratorPermission {
  updated_at: Date;
export interface ModeratorPermissionInput {
export interface ExtendedCommunitySettings {
export interface ExtendedCommunitySettingsInput {
export interface PostModeration {
export interface ModerationLog {
export interface BannedUser {
export interface AuthRequest extends Express.Request {

================
File: eslint.config.js
================
export default tseslint.config(

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "vite-react-typescript-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@types/dotenv": "^6.1.1",
    "@types/express": "^5.0.0",
    "@types/react-router-dom": "^5.3.3",
    "axios": "^1.7.9",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "lucide-react": "^0.344.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.22.3",
    "vite-react-typescript-starter": "file:"
  },
  "devDependencies": {
    "@eslint/js": "^9.9.1",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "autoprefixer": "^10.4.18",
    "eslint": "^9.9.1",
    "eslint-plugin-react-hooks": "^5.1.0-rc.0",
    "eslint-plugin-react-refresh": "^0.4.11",
    "globals": "^15.9.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "^5.5.3",
    "typescript-eslint": "^8.3.0",
    "vite": "^6.2.0"
  }
}

================
File: postcss.config.js
================


================
File: REFACTORING.md
================
# Database Refactoring Progress

This document tracks the progress of refactoring the application to use the new database schema.

## Overview

We are refactoring the application to use a new database schema that addresses several issues with the current database:

1. Data duplication
2. Missing activity tracking
3. Inconsistent naming conventions
4. Missing personal information

The new database schema uses singular table names (e.g., `user` instead of `users`) and includes new tables for activity tracking, user statistics, and more.

## Large File Handling

Files exceeding 800 lines should be refactored into smaller modules following these guidelines:

1. Split files along logical boundaries
2. Create an index file for backward compatibility
3. Update imports in dependent files
4. Document the new file structure

### Refactored Large Files

| Original File | New Structure | Status | Date |
|---------------|---------------|--------|------|
| backend/api/communities.js | community-*.js modules | Completed | 2/26/2025 |

## Refactoring Plan Maintenance

This refactoring plan should be updated when:

1. New large files are identified for refactoring
2. New patterns or issues are discovered during refactoring
3. Changes to the database schema require additional refactoring
4. New functionality needs to be integrated with the refactored code

Updates should include:
- Date of the update
- Description of the new refactoring needs
- Updated checklist items
- Any new sections required

## Database Connection

- [x] Update backend/.env with new database connection details
- [x] Update backend/db/connection.js to use the new database
- [x] Remove any conditional logic that references the old database

## Backend API Refactoring

### User Management

- [x] Refactor backend/routes/users.js to use the new `user` table
- [x] Implement user statistics endpoints
- [x] Implement user settings endpoints
- [x] Update authentication to work with the new schema

### Community Management

- [x] Refactor backend/api/communities.js into smaller modules:
  - [x] community-core.js - Basic CRUD operations
  - [x] community-rules.js - Rule management
  - [x] community-settings.js - Settings operations
  - [x] community-members.js - Member management
  - [x] community-requests.js - Join request handling
  - [x] community-search.js - Search and discovery functions
  - [x] community-index.js - Main export file
- [x] Refactor backend/routes/communities.js to use the new schema
- [x] Implement community settings endpoints
- [x] Implement community rules endpoints
- [x] Add support for join requests
- [x] Update moderation functionality

### Content Management

- [x] Refactor post endpoints to use the new schema
- [x] Refactor comment endpoints to use the new schema
- [x] Update voting system to use the new schema
- [x] Implement activity tracking for content actions

### Activity Tracking

- [x] Create activity history endpoints
- [x] Implement activity logging middleware
- [x] Add support for filtering and querying activities

## Frontend Integration

### API Client Updates

- [x] Update src/api/users.ts to work with the new endpoints
- [x] Update src/api/communities.ts to work with the new endpoints
- [x] Update src/api/posts.ts to work with the new endpoints
- [x] Update src/api/comments.ts to work with the new endpoints
- [x] Update src/api/votes.ts to work with the new endpoints
- [x] Create src/api/activities.ts for the new activity endpoints

### Component Updates

- [x] Update user profile components
- [x] Update community components
- [x] Update post and comment components
- [x] Add activity tracking UI components

## Archived Files

Files that are no longer needed after the refactoring will be moved to the ARCHIVED directory.

| Original Path | Reason for Archiving | Date Archived |
|---------------|----------------------|---------------|
| backend/routes/users.js | Refactored to use new database schema with singular table names and activity tracking | 2/26/2025 |
| backend/api/communities.js | Refactored into smaller modules with improved organization and maintainability | 2/26/2025 |
| backend/routes/communities.js | Refactored to use the new schema with singular table names and the refactored community API modules | 2/26/2025 |
| backend/api/moderation.ts | Updated to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/middleware/moderation.js | Updated to use the new moderation API | 2/26/2025 |
| backend/routes/moderation.js | Updated to use the new moderation API and community module structure | 2/26/2025 |
| backend/api/posts.js | Refactored to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/routes/posts.js | Updated to use the refactored posts API and add support for user posts | 2/26/2025 |
| backend/api/comments.js | Refactored to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/routes/comments.js | Updated to use the refactored comments API and add support for user comments | 2/26/2025 |
| backend/api/votes.js | Refactored to use the new schema with singular table names and activity tracking | 2/26/2025 |
| backend/routes/votes.js | Updated to use the refactored votes API and add support for user votes | 2/26/2025 |

## Authentication Updates

- [x] Update auth.js to work with the new schema
- [x] Update auth.ts to work with the new schema
- [x] Update auth routes to work with the new schema
- [x] Add activity logging to auth operations
- [x] Create update_auth_files.js script to apply changes

## Testing

- [ ] Test user management functionality
- [ ] Test community management functionality
- [ ] Test post and comment functionality
- [ ] Test voting functionality
- [ ] Test activity tracking
- [ ] Test moderation tools
- [ ] Test authentication functionality

## Notes

### 2/26/2025 - Community API Refactoring

The `backend/api/communities.js` file has been refactored into smaller modules:

1. Created a new directory structure: `backend/api/community/`
2. Split the file into logical modules:
   - `community-core.js` - Basic CRUD operations
   - `community-rules.js` - Rule management
   - `community-settings.js` - Settings operations
   - `community-members.js` - Member management
   - `community-requests.js` - Join request handling
   - `community-search.js` - Search and discovery functions
   - `community-index.js` - Main export file
3. Added a README.md file with documentation and usage examples
4. Created a backward-compatible wrapper in the original location
5. Archived the original file

This refactoring improves maintainability, makes the code easier to understand, and follows the "Large File Handling" guidelines established in this document.

### 2/26/2025 - Community Routes Refactoring

The `backend/routes/communities.js` file has been refactored to use the new database schema:

1. Updated table names from plural to singular (e.g., `community_members` → `community_member`)
2. Replaced direct MariaDB pool with the connection pool from `backend/db/connection.js`
3. Updated imports to use the new community module structure
4. Enhanced endpoints to support all features of the new schema:
   - Added support for additional community settings fields
   - Implemented proper join request handling
   - Added new discovery endpoints for trending and recommended communities
5. Archived the original file

This refactoring ensures that the routes layer works correctly with the new database schema and the refactored community API modules.

### 2/26/2025 - Moderation Functionality Update

The moderation functionality has been updated to work with the new database schema:

1. Updated `backend/api/moderation.ts` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `moderator_permissions` → `moderator_permission`)
   - Add support for activity logging
   - Enhance error handling and transaction management

2. Updated `backend/middleware/moderation.js` to:
   - Use the updated moderation API
   - Improve permission checking for the new schema

3. Updated `backend/routes/moderation.js` to:
   - Use the updated moderation API
   - Use the new community module structure for member management
   - Enhance error handling and response formatting

These changes ensure that the moderation functionality works correctly with the new database schema and integrates with the activity tracking system.

### 2/26/2025 - Posts API Refactoring

The posts functionality has been updated to work with the new database schema:

1. Updated `backend/api/posts.js` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `posts` → `post`, `comments` → `comment`)
   - Add support for activity logging
   - Enhance error handling with transaction management
   - Add support for post moderation integration

2. Updated `backend/routes/posts.js` to:
   - Use the updated posts API
   - Add new endpoints for user posts
   - Integrate with the moderation system for post approval
   - Add ban checking middleware

3. Key improvements:
   - Added activity tracking for post creation, updates, and deletion
   - Enhanced permission checking for community posts
   - Added support for post moderation based on community settings
   - Improved error handling and response formatting

These changes ensure that the posts functionality works correctly with the new database schema and integrates with both the activity tracking and moderation systems.

### 2/26/2025 - Comments API Refactoring

The comments functionality has been updated to work with the new database schema:

1. Updated `backend/api/comments.js` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `comments` → `comment`)
   - Add support for activity logging
   - Enhance error handling with transaction management
   - Add support for moderation integration

2. Updated `backend/routes/comments.js` to:
   - Use the updated comments API
   - Add new endpoints for user comments
   - Integrate with the moderation system for comment management
   - Add ban checking middleware

3. Key improvements:
   - Added activity tracking for comment creation, updates, and deletion
   - Enhanced permission checking for comment management
   - Added support for moderator comment deletion
   - Improved error handling and response formatting
   - Added recursive comment deletion with activity logging

These changes ensure that the comments functionality works correctly with the new database schema and integrates with both the activity tracking and moderation systems.

### 2/26/2025 - Votes API Refactoring

The voting functionality has been updated to work with the new database schema:

1. Updated `backend/api/votes.js` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `votes` → `vote`)
   - Add support for activity logging
   - Enhance error handling with transaction management
   - Add support for moderation integration

2. Updated `backend/routes/votes.js` to:
   - Use the updated votes API
   - Add new endpoints for user votes
   - Integrate with the moderation system for vote management
   - Add ban checking middleware

3. Key improvements:
   - Added activity tracking for vote creation, updates, and deletion
   - Enhanced permission checking for vote management
   - Added support for retrieving user's voting history
   - Improved error handling and response formatting
   - Added specific action types for upvotes and downvotes

These changes ensure that the voting functionality works correctly with the new database schema and integrates with both the activity tracking and moderation systems. The refactored code also provides a more comprehensive API for retrieving vote information, which will be useful for the frontend integration.

### 2/26/2025 - Frontend Integration for Activity Tracking

The frontend has been updated to support the new activity tracking functionality:

1. Created `src/api/activities.ts` with:
   - Comprehensive API client for all activity endpoints
   - Support for filtering activities by type, action, and entity
   - Helper functions for formatting activity data

2. Created `src/components/ActivityHistory.tsx`:
   - Reusable component for displaying activity history
   - Support for user, community, and post activities
   - Filtering capabilities for activity types and actions
   - Pagination with "load more" functionality
   - Visual indicators for different activity types

3. Integrated activity tracking into key pages:
   - Added activity tab to user profiles
   - Added activity section to community sidebar
   - Added activity section to post detail pages

4. Key improvements:
   - Real-time activity tracking for user actions
   - Consistent UI for displaying activities across the application
   - Filtering capabilities for better user experience
   - Responsive design that works on all device sizes

These changes provide users with visibility into the activity happening in communities, on posts, and by specific users, enhancing the overall user experience and providing valuable insights into platform engagement.

### 2/27/2025 - Authentication System Updates

The authentication system has been updated to work with the new database schema:

1. Updated `backend/api/auth.js` and `backend/api/auth.ts` to:
   - Use the new connection pool from `backend/db/connection.js`
   - Update table names from plural to singular (e.g., `users` → `user`)
   - Add support for user statistics and settings tables
   - Implement transaction management for user registration
   - Add activity logging for authentication actions
   - Enhance error handling and validation

2. Updated `backend/routes/auth.js` to:
   - Use the updated auth API
   - Add a new logout endpoint
   - Improve error handling and response formatting
   - Capture client information for activity logging

3. Created `backend/db/update_auth_files.js` script to:
   - Create backups of original auth files
   - Replace auth files with the new versions
   - Apply changes without modifying the database schema

4. Key improvements:
   - Proper transaction management for user registration
   - Activity logging for login, registration, and logout
   - Enhanced user profile data in authentication responses
   - Better password validation and security
   - Improved error handling and user feedback

These changes ensure that the authentication system works correctly with the new database schema and integrates with the activity tracking system. The updated code provides a more robust and secure authentication experience while maintaining compatibility with the existing frontend components.

================
File: src/api/activities.ts
================
export interface Activity {
export interface ActivityType {
export interface ActionType {
export interface ActivityQueryOptions {
export async function getActivityTypes(token?: string | null): Promise<ActivityType[]> {
    throw new Error(errorData.error || 'Failed to fetch activity types');
export async function getActionTypes(token?: string | null): Promise<ActionType[]> {
    throw new Error(errorData.error || 'Failed to fetch action types');
export async function getCurrentUserActivities(
  options: ActivityQueryOptions = {},
  const queryParams = new URLSearchParams();
    throw new Error(errorData.error || 'Failed to fetch user activities');
export async function getUserActivities(
export async function getCommunityActivities(
    throw new Error(errorData.error || 'Failed to fetch community activities');
export async function getPostActivities(
    throw new Error(errorData.error || 'Failed to fetch post activities');
export async function logActivity(
    throw new Error(errorData.error || 'Failed to log activity');
export function formatActivity(activity: Activity): string {
  const date = new Date(created_at).toLocaleString();

================
File: src/api/comments.ts
================
export interface Comment {
export interface CommentInput {
export async function getPostComments(postId: string, threaded: boolean = false) {
export async function getComment(commentId: string) {
    throw new Error('Failed to fetch comment');
export async function createComment(
        throw new Error(errorData.error || `Failed to create comment: ${response.status}`);
        throw new Error(`Failed to create comment: ${response.status} - ${errorText.substring(0, 100)}`);
export async function updateComment(
    throw new Error(errorData.error || 'Failed to update comment');
export async function deleteComment(commentId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to delete comment');
export async function getCommentReplies(commentId: string) {
    throw new Error('Failed to fetch comment replies');
export async function getCommentCount(postId: string): Promise<number> {

================
File: src/api/communities.ts
================
export async function getCommunities(searchTerm?: string) {
    throw new Error('Failed to fetch communities');
export async function getCommunity(communityId: string) {
    throw new Error('Failed to fetch community');
export async function createCommunity(
    throw new Error(errorData.error || 'Failed to create community');
export async function updateCommunity(
    throw new Error(errorData.error || 'Failed to update community');
export async function deleteCommunity(communityId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to delete community');
export async function getUserCommunities(userId: string) {
    throw new Error('Failed to fetch user communities');
export async function getCommunityRules(communityId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch community rules');
export async function addCommunityRule(
    throw new Error(errorData.error || 'Failed to add community rule');
export async function updateCommunityRule(
    throw new Error(errorData.error || 'Failed to update community rule');
export async function deleteCommunityRule(
    throw new Error(errorData.error || 'Failed to delete community rule');
export async function getCommunitySettings(communityId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch community settings');
export async function updateCommunitySettings(
    throw new Error(errorData.error || 'Failed to update community settings');
export async function getCommunityMembers(communityId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch community members');
export async function joinCommunity(communityId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to join community');
export async function updateCommunityMemberRole(
    throw new Error(errorData.error || 'Failed to update community member role');
export async function leaveCommunity(communityId: string, userId?: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to leave community');
export async function getPendingJoinRequests(communityId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch join requests');
export async function approveJoinRequest(communityId: string, requestId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to approve join request');
export async function rejectJoinRequest(communityId: string, requestId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to reject join request');
export async function getCommunityAbout(communityId: string) {
    throw new Error('Failed to fetch community about');
export async function getCommunityModerators(communityId: string, token?: string | null) {
export async function getCommunityMember(communityId: string, userId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch member status');

================
File: src/api/compatibility.ts
================
export async function handleApiResponse(response: Response) {
    throw new Error(errorData.error || `Failed with status: ${response.status}`);
export async function safeGetArray(url: string, token?: string | null): Promise<any[]> {
export async function safeGetObject(url: string, token?: string | null): Promise<any | null> {
export async function getCommunityActivities(communityId: string, limit = 10): Promise<any[]> {
export async function getCommunityRules(communityId: string, token?: string | null): Promise<any[]> {
export async function getCommunityPosts(communityId: string, token?: string | null): Promise<any[]> {
export async function getCommunitySettings(communityId: string, token?: string | null): Promise<any | null> {
export async function getCommunityMembers(communityId: string, token?: string | null): Promise<any[]> {
export async function getCommunityDetails(communityId: string, token?: string | null): Promise<any | null> {
export async function getActivityHistory(entity: 'community' | 'user' | 'post', id: string, token?: string | null): Promise<any[]> {
export async function getPostComments(postId: string, threaded: boolean = false): Promise<any[]> {
export async function getUserVoteOnPost(postId: string, token?: string | null): Promise<number> {

================
File: src/api/mockData.ts
================


================
File: src/api/moderation.ts
================
export interface ModeratorPermission {
export interface CommunitySettings {
export interface BannedUser {
export interface ModerationLog {
export interface PendingPost {
export async function isUserModerator(communityId: string, token?: string | null): Promise<boolean> {
export async function getCommunitySettings(communityId: string, token?: string | null): Promise<CommunitySettings> {
    throw new Error(errorData.error || 'Failed to fetch community settings');
export async function updateCommunitySettings(
    throw new Error(errorData.error || 'Failed to update community settings');
export async function getModeratorPermissions(
    throw new Error(errorData.error || 'Failed to fetch moderator permissions');
export async function setModeratorPermissions(
    throw new Error(errorData.error || 'Failed to set moderator permissions');
export async function getPendingModQueue(communityId: string, token?: string | null): Promise<PendingPost[]> {
    throw new Error(errorData.error || 'Failed to fetch moderation queue');
export async function moderatePost(
    throw new Error(errorData.error || 'Failed to moderate post');
export async function getModerationLogs(
    throw new Error(errorData.error || 'Failed to fetch moderation logs');
export async function getBannedUsers(communityId: string, token?: string | null): Promise<BannedUser[]> {
    throw new Error(errorData.error || 'Failed to fetch banned users');
export async function banUser(
    throw new Error(errorData.error || 'Failed to ban user');
export async function unbanUser(
    throw new Error(errorData.error || 'Failed to unban user');
export async function updateMemberRole(
    throw new Error(errorData.error || 'Failed to update member role');

================
File: src/api/posts.ts
================
export async function getPosts(communityId?: string | null, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch posts');
export async function getPost(postId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to fetch post');
export async function createPost(
    throw new Error(errorData.error || 'Failed to create post');
export async function updatePost(
    throw new Error(errorData.error || 'Failed to update post');
export async function deletePost(postId: string, token?: string | null) {
    throw new Error(errorData.error || 'Failed to delete post');

================
File: src/api/users.ts
================
interface User {
export async function getCurrentUser(token?: string | null): Promise<User> {
    throw new Error(errorData.error || 'Failed to fetch current user');
export async function getUserById(userId: string): Promise<User> {
      throw new Error('User not found');
    throw new Error(errorData.error || 'Failed to fetch user');
export async function getUserByUsername(username: string): Promise<User> {
    throw new Error(errorData.error || 'Failed to lookup user');
export async function getAllUsers(): Promise<User[]> {
    throw new Error(errorData.error || 'Failed to fetch users');
export async function updateUserProfile(
    throw new Error(errorData.error || 'Failed to update profile');
export async function getUsername(userId: string): Promise<string> {

================
File: src/api/votes.ts
================
export async function voteOnPost(
    throw new Error(errorData.error || 'Failed to vote on post');
export async function voteOnComment(
    throw new Error(errorData.error || 'Failed to vote on comment');
export async function getUserPostVote(
    throw new Error(errorData.error || 'Failed to get user post vote');
export async function getUserCommentVote(
    throw new Error(errorData.error || 'Failed to get user comment vote');

================
File: src/App.tsx
================
export default function App() {

================
File: src/components/ActivityHistory.tsx
================
interface Activity {
interface ActivityHistoryProps {
  const fetchActivities = async () => {
  const loadMore = () => {

================
File: src/components/ActivityHistory.tsxold
================
import React, { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { 
  formatActivity,
  ActivityQueryOptions
} from '../api/activities';
import { getActivityHistory } from '../api/compatibility';

interface Activity {
  id: string;
  user_id: string;
  activity_type_id: string;
  action_id: string;
  entity_id?: string;
  entity_type?: string;
  metadata?: any;
  created_at: string;
  activity_type_name: string;
  action_name: string;
  username?: string;
  entity_details?: any;
}

interface ActivityHistoryProps {
  userId?: string;
  communityId?: string;
  postId?: string;
  limit?: number;
  showFilters?: boolean;
}

const ActivityHistory: React.FC<ActivityHistoryProps> = ({ 
  userId, 
  communityId, 
  postId, 
  limit = 20,
  showFilters = false
}) => {
  const { token } = useAuth();
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [offset, setOffset] = useState(0);
  const [hasMore, setHasMore] = useState(true);
  
  // Filter states
  const [activityType, setActivityType] = useState<string>('');
  const [actionType, setActionType] = useState<string>('');
  const [entityType, setEntityType] = useState<string>('');
  
  useEffect(() => {
    fetchActivities();
  }, [userId, communityId, postId, offset, activityType, actionType, entityType]);
  
  const fetchActivities = async () => {
    setLoading(true);
    setError(null);
    
    try {
      let result: Activity[] = [];
      
      // Use the compatibility layer to get activities
      if (communityId) {
        result = await getActivityHistory('community', communityId, token) as Activity[];
      } else if (userId) {
        result = await getActivityHistory('user', userId, token) as Activity[];
      } else if (postId) {
        result = await getActivityHistory('post', postId, token) as Activity[];
      }
      
      setActivities(result);
      setHasMore(result.length === limit);
    } catch (error: any) {
      console.error('Error fetching activities:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  
  const loadMore = () => {
    setOffset(prev => prev + limit);
  };
  
  if (loading && activities.length === 0) {
    return <div className="text-center py-4">Loading activities...</div>;
  }
  
  if (error && activities.length === 0) {
    return (
      <div className="text-center text-red-500 py-4">
        Error loading activities: {error}
      </div>
    );
  }
  
  if (activities.length === 0) {
    return <div className="text-center py-4">No activities found.</div>;
  }
  
  return (
    <div className="activity-history mt-4">
      {showFilters && (
        <div className="filters mb-4 flex gap-2 flex-wrap">
          <select 
            value={activityType} 
            onChange={e => setActivityType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Activity Types</option>
            <option value="POST">Posts</option>
            <option value="COMMENT">Comments</option>
            <option value="VOTE">Votes</option>
            <option value="COMMUNITY">Communities</option>
          </select>
          
          <select 
            value={actionType} 
            onChange={e => setActionType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Actions</option>
            <option value="CREATE">Create</option>
            <option value="UPDATE">Update</option>
            <option value="DELETE">Delete</option>
            <option value="UPVOTE">Upvote</option>
            <option value="DOWNVOTE">Downvote</option>
            <option value="JOIN">Join</option>
            <option value="LEAVE">Leave</option>
          </select>
          
          <select 
            value={entityType} 
            onChange={e => setEntityType(e.target.value)}
            className="px-3 py-2 border rounded"
          >
            <option value="">All Entities</option>
            <option value="post">Posts</option>
            <option value="comment">Comments</option>
            <option value="community">Communities</option>
            <option value="user">Users</option>
          </select>
        </div>
      )}
      
      <ul className="divide-y">
        {activities.map(activity => (
          <li key={activity.id} className="py-2">
            <div className="flex justify-between">
              <div>
                <strong>{activity.username || 'User'}</strong> {' '}
                {formatActivity(activity)}
              </div>
              <div className="text-gray-500 text-sm">
                {new Date(activity.created_at).toLocaleString()}
              </div>
            </div>
          </li>
        ))}
      </ul>
      
      {hasMore && (
        <button 
          onClick={loadMore} 
          className="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          disabled={loading}
        >
          {loading ? 'Loading...' : 'Load More'}
        </button>
      )}
    </div>
  );
};

export default ActivityHistory;

================
File: src/components/CommentItem.tsx
================
interface CommentItemProps {
export default function CommentItem({ comment, onReply, level = 0 }: CommentItemProps) {
    const fetchUserVote = async () => {
  const handleVote = async (voteValue: number) => {
  const handleSubmitReply = async (e: React.FormEvent) => {
  const handleEditComment = async (e: React.FormEvent) => {
  const handleDeleteComment = async () => {
  const getIndentClass = () => {

================
File: src/components/CommentSection.tsx
================
interface CommentSectionProps {
export default function CommentSection({ postId }: CommentSectionProps) {
    const fetchComments = async () => {
  const handleSubmitComment = async (e: React.FormEvent) => {
  const handleReply = async (parentId: string, content: string) => {
        const findAndAddReply = (comments: any[]) => {
  const formatCommentForDisplay = (comment: Comment): any => {
      timestamp: comment.created_at ? formatDistanceToNow(new Date(comment.created_at), { addSuffix: true }) : '',
      return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
      return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
            onChange={(e) => setCommentText(e.target.value)}

================
File: src/components/CommunityAbout.tsx
================
interface CommunityAboutInfo {
interface Props {
export default function CommunityAbout({ communityId }: Props) {
    async function fetchData() {

================
File: src/components/CommunityCard.tsx
================
interface CommunityCardProps {
export default function CommunityCard({ community }: CommunityCardProps) {
  const handleJoin = async (e: React.MouseEvent) => {

================
File: src/components/CommunityDiscovery.tsx
================
interface Community {
    const fetchCommunities = async () => {
          (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  const goToRandomCommunity = () => {

================
File: src/components/CommunityDiscoverySidebar.tsx
================
interface Community {
    async function fetchData() {
          (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  const goToRandomCommunity = () => {

================
File: src/components/CommunityHeader.tsx
================
interface CommunityAbout {
interface Props {
export default function CommunityHeader({ communityId }: Props) {
  const getDemoStats = (community: any) => {
    async function fetchCommunity() {
  const joinCommunity = async () => {
  const leaveCommunity = async () => {
              Created {new Date(community.created_at).toLocaleDateString()}

================
File: src/components/CommunityInfo.tsx
================
interface CommunityAbout {
interface Props {
export default function CommunityInfo({ communityId }: Props) {
    async function fetchCommunity() {

================
File: src/components/CommunityList.tsx
================
interface Community {
interface CommunityListProps {
export default function CommunityList({ communities }: CommunityListProps) {
  const getColorClass = (index: number) => {
  const handleJoin = async (e: React.MouseEvent, communityId: string) => {

================
File: src/components/CommunityModControls.tsx
================
interface CommunityModControlsProps {
  const loadPendingCounts = async () => {

================
File: src/components/CommunityRules.tsx
================
interface CommunityRule {
interface Props {
export default function CommunityRules({ communityId }: Props) {
    async function fetchRules() {

================
File: src/components/CommunitySearch.tsx
================
interface Props {
export default function CommunitySearch({ onSearch, onSearchStart, onSearchError }: Props) {
  const handleSearch = async (e: React.FormEvent) => {
          onChange={(e) => setSearchTerm(e.target.value)}

================
File: src/components/CommunitySettings.tsx
================
interface CommunitySettings {
  updated_at: Date;
interface Community {
interface Props {
export default function CommunitySettings({ communityId }: Props) {
    async function fetchData() {
        updated_at: new Date()
  const handleTogglePrivacy = async () => {
  const handleTogglePostImages = async () => {
  const handleTogglePostLinks = async () => {
  const handleJoinMethodChange = async (e: React.ChangeEvent<HTMLSelectElement>) => {
            <option value="auto_approve">Auto Approve (anyone can join)</option>
            <option value="requires_approval">Requires Approval (moderator must approve joins)</option>

================
File: src/components/CommunitySidebar.tsx
================
interface CommunitySidebarProps {
  const checkMembershipStatus = async () => {
  const handleJoinCommunity = async () => {
  const handleLeaveCommunity = async () => {

================
File: src/components/CreateCommunityModal.tsx
================
interface CreateCommunityModalProps {
export default function CreateCommunityModal({ onClose, onSuccess }: CreateCommunityModalProps) {
  const handleSubmit = async (e: React.FormEvent) => {

================
File: src/components/CreatePostModal.tsx
================
interface Props {
interface Community {
export default function CreatePostModal({ onClose, communityId, onSuccess }: Props) {
    async function fetchData() {
  const handleSubmit = async (e: React.FormEvent) => {

================
File: src/components/EditProfileModal.tsx
================
interface EditProfileModalProps {
export default function EditProfileModal({ onClose, onSuccess }: EditProfileModalProps) {
  const handleSubmit = async (e: React.FormEvent) => {

================
File: src/components/ModeratorDashboard.tsx
================
interface ModeratorDashboardProps {
  const loadData = async () => {
  const handleSettingsChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
  const saveSettings = async () => {
  const handleRoleChange = async (userId: string, newRole: 'member' | 'moderator' | 'admin') => {
  const approvePost = async (postId: string) => {
  const showRejectForm = (postId: string) => {
  const rejectPost = async () => {
  const showBanUserForm = (userId: string) => {
  const submitBan = async () => {
  const unbanUserAction = async (userId: string) => {
  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
                      <h4 className="text-lg font-medium">{post.title}</h4>

================
File: src/components/Navbar.tsx
================
  const handleLogout = () => {

================
File: src/components/Post.tsx
================
interface PostProps {
export default function Post({ postId }: PostProps) {
    const fetchPost = async () => {
    const fetchUserVote = async () => {
  const handleVote = async (voteValue: number) => {
    ? formatDistanceToNow(new Date(timestamp), { addSuffix: true })

================
File: src/components/PostCreationForm.tsx
================
interface PostCreationFormProps {
    const checkCommunitySettings = async () => {
  const handleSubmit = async (e: React.FormEvent) => {
        throw new Error(data.message || 'Failed to create post');

================
File: src/components/PostItem.tsx
================
interface PostItemProps {
export default function PostItem({ post, communityId }: PostItemProps) {
    ? formatDistanceToNow(new Date(post.timestamp), { addSuffix: true })
  const handleVote = async (voteValue: number) => {

================
File: src/components/PostList.tsx
================
interface Post {
interface PostListProps {
export default function PostList({ communityId, postType = 'all' }: PostListProps) {
    async function fetchData() {
              return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
          timestamp: post.created_at || new Date().toISOString(),

================
File: src/components/ProfileActions.tsx
================
interface ProfileActionsProps {
export default function ProfileActions({ onEditProfile }: ProfileActionsProps) {
  const handleLogout = () => {

================
File: src/components/Sidebar.tsx
================
    const fetchCommunities = async () => {

================
File: src/components/UserInfo.tsx
================
interface UserData {
interface UserInfoProps {
  userData?: UserData;
export default function UserInfo({ username, userData, isCurrentUser = false, onEditProfile }: UserInfoProps) {

================
File: src/components/UserPosts.tsx
================
interface Post {
interface UserPostsProps {
export default function UserPosts({ username, posts = [] }: UserPostsProps) {

================
File: src/context/AuthContext.tsx
================
interface User {
interface AuthContextType {
export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
    const loadUser = async () => {
  const login = async (username: string, password: string) => {
        throw new Error(errorData.error || 'Login failed');
  const register = async (username: string, email: string, password: string) => {
        throw new Error(errorData.error || 'Registration failed');
  const logout = () => {
  const contextValue: AuthContextType = {
export const useAuth = () => useContext(AuthContext);

================
File: src/context/CommunityContext.tsx
================
type CommunityContextType = {
  setCurrentCommunity: (community: Community) => void;
export const CommunityProvider = ({ children }: { children: ReactNode }) => {
export const useCommunity = () => {

================
File: src/debug/ModeratorDebug.tsx
================
interface Props {
export default function ModeratorDebug({ communityId }: Props) {
    async function fetchData() {

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Wireframe Styles */
.wireframe-border {
  border: 1px solid rgba(0,0,0,0.15);
}

.wireframe-shadow {
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

.wireframe-input {
  @apply border border-gray-300 outline-none focus:border-gray-500 transition-all duration-200;
}

.wireframe-link {
  text-decoration: none;
  position: relative;
  transition: all 0.2s ease;
}

.wireframe-link::after {
  content: '';
  position: absolute;
  width: 100%;
  height: 1px;
  bottom: -2px;
  left: 0;
  background-color: rgba(0,0,0,0.6);
  visibility: hidden;
  transform: scaleX(0);
  transition: all 0.2s ease;
}

.wireframe-link:hover::after {
  visibility: visible;
  transform: scaleX(1);
}

.wireframe-divider {
  border-bottom: 1px solid rgba(0,0,0,0.15);
}

================
File: src/main.tsx
================


================
File: src/pages/Communities.tsx
================
interface Community {
  const toggleCommunityExpansion = (communityId: string) => {
  const updateCommunitySearchTerm = (communityId: string, term: string) => {
  const sortCommunities = (sortType: 'trending' | 'new' | 'popular' | 'active') => {
          new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
          const dateA = new Date(a.created_at).getTime();
          const dateB = new Date(b.created_at).getTime();
  const filterCommunities = (filterType: 'all' | 'public' | 'private') => {
  const applyFilters = (communitiesToFilter: Community[]) => {
  const fetchCommunities = async () => {
  const handleCommunityCreated = (communityId: string) => {
  const handleSearch = async (e: React.FormEvent) => {
    const handleJoinCommunity = async (communityId: string) => {
                  onChange={(e) => setSearchTerm(e.target.value)}
                                    onChange={(e) => updateCommunitySearchTerm(community.id, e.target.value)}
                        style={{ borderLeftColor: communityColor }}
                                    Created: <span className="font-medium">{community.created_at ? new Date(community.created_at).toLocaleDateString() : 'recently'}</span>
                            <div onClick={(e) => e.stopPropagation()}>

================
File: src/pages/Community.tsx
================
  const handlePostCreated = () => {

================
File: src/pages/CommunityModeration.tsx
================
interface JoinRequest {
  const checkModeratorStatus = async () => {
  const loadCommunity = async () => {
  const loadJoinRequests = async () => {
  const handleApproveJoinRequest = async (requestId: string) => {
  const handleRejectJoinRequest = async (requestId: string) => {
              onClick={() => {
                        Requested {new Date(request.requested_at).toLocaleString()}

================
File: src/pages/Home.tsx
================
    const fetchTrendingCommunities = async () => {

================
File: src/pages/Login.tsx
================
export default function Login() {
  const handleSubmit = async (e: React.FormEvent) => {
              onChange={(e) => setUsername(e.target.value)}
              onChange={(e) => setPassword(e.target.value)}

================
File: src/pages/PostDetail.tsx
================
    const fetchPostDetails = async () => {

================
File: src/pages/Profile.tsx
================
interface ProfileProps {
interface Post {
export default function Profile({ isUser }: ProfileProps) {
    const fetchData = async () => {
              throw new Error('User not found')
            const userPosts = posts.filter((post: Post) => post.userId === matchedUser.id)

================
File: src/pages/Register.tsx
================
  const checkPasswordStrength = (password: string) => {
  const handleSubmit = async (e: React.FormEvent) => {
          Create a new account to join the community
              onChange={(e) => setUsername(e.target.value)}
              onChange={(e) => setEmail(e.target.value)}
                setPassword(e.target.value);
                checkPasswordStrength(e.target.value);

================
File: src/routes/index.tsx
================


================
File: src/types.ts
================
export interface Community {
export interface CommunityRule {
export interface CreateCommunityInput {
export interface UpdateCommunityInput {

================
File: src/vite-env.d.ts
================


================
File: tailwind.config.js
================


================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": ["vite.config.ts"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================


================
File: vite.config.ts.timestamp-1740451079238-bcbb258007fe8.mjs
================
// vite.config.ts
import { defineConfig } from "file:///C:/Users/sadow/Desktop/rumfor/git_project_bolt-vite-react-ts-template.git_(fork)_gu70k0/node_modules/vite/dist/node/index.js";
import react from "file:///C:/Users/sadow/Desktop/rumfor/git_project_bolt-vite-react-ts-template.git_(fork)_gu70k0/node_modules/@vitejs/plugin-react/dist/index.mjs";
import path from "path";
var __vite_injected_original_dirname = "C:\\Users\\sadow\\Desktop\\rumfor\\git_project_bolt-vite-react-ts-template.git_(fork)_gu70k0";
var vite_config_default = defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      "@": path.resolve(__vite_injected_original_dirname, "src")
    }
  },
  optimizeDeps: {
    exclude: ["lucide-react"]
  }
});
export {
  vite_config_default as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidml0ZS5jb25maWcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJDOlxcXFxVc2Vyc1xcXFxzYWRvd1xcXFxEZXNrdG9wXFxcXHJ1bWZvclxcXFxnaXRfcHJvamVjdF9ib2x0LXZpdGUtcmVhY3QtdHMtdGVtcGxhdGUuZ2l0Xyhmb3JrKV9ndTcwazBcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkM6XFxcXFVzZXJzXFxcXHNhZG93XFxcXERlc2t0b3BcXFxccnVtZm9yXFxcXGdpdF9wcm9qZWN0X2JvbHQtdml0ZS1yZWFjdC10cy10ZW1wbGF0ZS5naXRfKGZvcmspX2d1NzBrMFxcXFx2aXRlLmNvbmZpZy50c1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vQzovVXNlcnMvc2Fkb3cvRGVza3RvcC9ydW1mb3IvZ2l0X3Byb2plY3RfYm9sdC12aXRlLXJlYWN0LXRzLXRlbXBsYXRlLmdpdF8oZm9yaylfZ3U3MGswL3ZpdGUuY29uZmlnLnRzXCI7aW1wb3J0IHsgZGVmaW5lQ29uZmlnIH0gZnJvbSAndml0ZSdcbmltcG9ydCByZWFjdCBmcm9tICdAdml0ZWpzL3BsdWdpbi1yZWFjdCdcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXG5cbi8vIGh0dHBzOi8vdml0ZWpzLmRldi9jb25maWcvXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xuICBwbHVnaW5zOiBbcmVhY3QoKV0sXG4gIHJlc29sdmU6IHtcbiAgICBhbGlhczoge1xuICAgICAgJ0AnOiBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnc3JjJyksXG4gICAgfSxcbiAgfSxcbiAgb3B0aW1pemVEZXBzOiB7XG4gICAgZXhjbHVkZTogWydsdWNpZGUtcmVhY3QnXSxcbiAgfSxcbn0pXG4iXSwKICAibWFwcGluZ3MiOiAiO0FBQW1jLFNBQVMsb0JBQW9CO0FBQ2hlLE9BQU8sV0FBVztBQUNsQixPQUFPLFVBQVU7QUFGakIsSUFBTSxtQ0FBbUM7QUFLekMsSUFBTyxzQkFBUSxhQUFhO0FBQUEsRUFDMUIsU0FBUyxDQUFDLE1BQU0sQ0FBQztBQUFBLEVBQ2pCLFNBQVM7QUFBQSxJQUNQLE9BQU87QUFBQSxNQUNMLEtBQUssS0FBSyxRQUFRLGtDQUFXLEtBQUs7QUFBQSxJQUNwQztBQUFBLEVBQ0Y7QUFBQSxFQUNBLGNBQWM7QUFBQSxJQUNaLFNBQVMsQ0FBQyxjQUFjO0FBQUEsRUFDMUI7QUFDRixDQUFDOyIsCiAgIm5hbWVzIjogW10KfQo=



================================================================
End of Codebase
================================================================
